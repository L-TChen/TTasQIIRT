\documentclass[sigplan,screen,natbib,pbalance]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[CPP '26]{Certified Programs and Proofs}{January 12--13, 2026}{Rennes, France}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}

%%% Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage[UKenglish]{babel}
\usepackage{newunicodechar}
\usepackage{xspace}
\usepackage{xcolor}
%\usepackage{natbib}
\setcitestyle{numbers,sort&compress}
\usepackage{mathtools}
\let\Bbbk\relax
\usepackage{amsmath,amssymb,mathbbol}
\usepackage{bbold}
\usepackage[inline]{enumitem}

%% Remove the following if there are no todo items.
\setlength {\marginparwidth }{2cm}
\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage[capitalise]{cleveref}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},color={pink},#1]{#2}}
\newcommand{\FNF}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}

\usepackage{microtype}
\usepackage{newunicodechar}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Macros %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\CA}{\textrm{Cubical Agda}\xspace}
\newcommand{\Agda}{\textrm{Agda}\xspace}
\newcommand{\Set}{\mathbf{Set}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% lhs2tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cons}[1]{\mathbf{#1}}
\newcommand{\iden}{\mathit}

\newcommand{\awa}[2]{\mathrlap{#2}\phantom{#1}} % as wide as

\definecolor{addition}{RGB}{204,255,216}
\definecolor{keyword}{RGB}{204,255,216}
\definecolor{identifier}{RGB}{204,255,216}
\newcommand{\highlight}[2]{\smash{\text{\colorbox{#1}{\kern-.1em\vphantom{\vrule height 1.2ex depth 0.1ex}\smash{\ensuremath{#2}}\kern-.1em}}}}

\let\Bbbk\relax
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{agda.fmt}%


\RequirePackage[T1]{fontenc}
\RequirePackage[utf8]{inputenc}
\RequirePackage{amsfonts}
\RequirePackage{newunicodechar}

\providecommand\mathbbm{\mathbb}

% TODO: Define more of these ...
\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{27E6}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{27E7}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{2200}{\ensuremath{\forall}}

\DeclareUnicodeCharacter{2294}{\ensuremath{\sqcup}}
\DeclareUnicodeCharacter{2080}{\ensuremath{_0}}
\DeclareUnicodeCharacter{2081}{\ensuremath{_1}}
\DeclareUnicodeCharacter{2082}{\ensuremath{_2}}
\DeclareUnicodeCharacter{2083}{\ensuremath{_3}}

\DeclareUnicodeCharacter{2115}{\ensuremath{\mathbb{N}}}
\DeclareUnicodeCharacter{2236}{:}
\DeclareUnicodeCharacter{2237}{\ensuremath{\mathrel{::}}}
\DeclareUnicodeCharacter{03A3}{\ensuremath{\Sigma}}
\DeclareUnicodeCharacter{03BB}{\ensuremath{\lambda}}
\DeclareUnicodeCharacter{039B}{\ensuremath{\Lambda}}
\DeclareUnicodeCharacter{03C0}{\ensuremath{\pi}}
\DeclareUnicodeCharacter{03C3}{\ensuremath{\sigma}}
\DeclareUnicodeCharacter{03C9}{\ensuremath{\omega}}
\newunicodechar{Î²}{\ensuremath{\beta}}
\newunicodechar{Î·}{\ensuremath{\eta}}
\newunicodechar{Î“}{\ensuremath{\Gamma}}
\newunicodechar{Î”}{\ensuremath{\Delta}}
\newunicodechar{Î˜}{\ensuremath{\Theta}}
\newunicodechar{Î}{\ensuremath{\Xi}}
\newunicodechar{Î }{\ensuremath{\Pi}}
\newunicodechar{Ï„}{\ensuremath{\tau}}
\newunicodechar{Î³}{\ensuremath{\gamma}}
\newunicodechar{Î´}{\ensuremath{\delta}}
\newunicodechar{âˆ…}{\ensuremath{\emptyset}}
\newunicodechar{â‰¡}{\ensuremath{\equiv}}
\newunicodechar{âˆ˜}{\ensuremath{\circ}}
\newunicodechar{ğ”¹}{\ensuremath{\mathbb{B}}}
\newunicodechar{ğ•“}{\ensuremath{\mathbb{b}}}
\newunicodechar{âˆ}{\ensuremath{\blacksquare}}
\newunicodechar{âˆˆ}{\ensuremath{\in}}
\newunicodechar{â‹†}{\ensuremath{\star}}
\newunicodechar{âŒœ}{\ensuremath{\ulcorner}}
\newunicodechar{âŒ}{\ensuremath{\urcorner}}
\newunicodechar{Ê¸}{\ensuremath{{}^y}}
\newunicodechar{â¿}{\ensuremath{{}^n}}
\newunicodechar{á´¾}{\ensuremath{{}^P}}

\DeclareUnicodeCharacter{2032}{\ensuremath{\prime}}
\DeclareUnicodeCharacter{2113}{\ensuremath{\ell}}
\DeclareUnicodeCharacter{2207}{\ensuremath{\nabla}}
\DeclareUnicodeCharacter{220B}{\ensuremath{\ni}}
\DeclareUnicodeCharacter{2264}{\ensuremath{\leq}}
\DeclareUnicodeCharacter{21D2}{\ensuremath{\Rightarrow}}
\DeclareUnicodeCharacter{22A2}{\ensuremath{\vdash}}
\DeclareUnicodeCharacter{22A4}{\ensuremath{\top}}
\DeclareUnicodeCharacter{22A5}{\ensuremath{\bot}}

\DeclareUnicodeCharacter{1D57}{\ensuremath{^t}}
\newunicodechar{âˆ™}{\ensuremath{\cdot}}


% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}


%Actually, varsyms should not occur in Agda output.

% TODO: Make this configurable. IMHO, italics doesn't work well
% for Agda code.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput










\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
%\let\Conid\Varid
%\newcommand\Keyword[1]{\textsf{\textbf{#1}}}

%% end of the preamble, start of the body of the document source.


\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Can We Formalise Type Theory Intrinsically without Any Compromise?}
\subtitle{A Case Study in \CA}
%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Liang-Ting Chen}
\affiliation{%
  \institution{Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
\email{liangtingchen@as.edu.tw}

\author{Fredrik Nordvall Forsberg}
\affiliation{%
  \institution{University of Strathclyde}
  \city{Glasgow}
  \country{United Kingdom}}
\email{fredrik.nordvall-forsberg@strath.ac.uk}

\author{Tzu-Chun Tsai}
\affiliation{%
  \institution{Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
%\affiliation{%
%  \institution{University of Amsterdam}
%  \city{Amsterdam}
%  \country{Netherlands}}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato et al.}

\begin{abstract}
  We present an intrinsic representation of type theory in the proof assistant \CA, inspired by Awodeyâ€™s natural models of type theory.
  The initial natural model is defined as quotient inductive-inductive-recursive types, leading us to a syntax accepted by \CA without using any transports, postulates, or custom rewrite rules.
We formalise some meta-properties such as the standard model, normalisation by evaluation for typed terms, and strictification constructions.
Since our formalisation is carried out using \CA's native support for quotient inductive types, all our constructions compute at a reasonable speed.
When we try to develop more sophisticated metatheory, however, the `transport hell' problem reappears.  Ultimately, it remains a considerable struggle to develop the metatheory of type theory using an intrinsic representation that lacks strict equations.
The effort required is about the same whether or not the notion of natural model is used.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
\begin{CCSXML}\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{ccs2012>}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}

\keywords{Proof Assistants, Formalisation, Cubical Agda, Quotient Inductive-Inductive-Recursive Type}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\maketitle
\bibliographystyle{ACM-Reference-Format}

\section{Introduction}

%\LT[inline]{Clearly articulate what has been formalised and what has not, when appropriate? Ideally finish formalisation, otherwise scale back and discuss what has been done. (R1, R3)}
%\LT[inline]{Alternative formulation? E.g., \url{https://web.archive.org/web/20241004151846/https://lists.chalmers.se/pipermail/agda/2019/011176.html} (R2)}

%\listoftodos

% FNF (Fri 5 Sep)

Internalising the syntax and semantics of type theory in type theory is a long-standing problem which stretches the limits of the theory~\cite{Dybjer1996,Danielsson2006,Chapman2009,McBride2010,Altenkirch2016a}.
%
There are both practical and theoretical reasons to pursue this problem.
%
On the practical side, an internal representation of type theory is needed for mechanised metatheory and metaprogramming.
%
On the theoretic side, if type theory is supposed to be a general constructive foundation of mathematics, then it should in particular be able to reason about its own syntax and semantics (up to inherent limitations due to G\"odel's incompleteness theorems).
%
In dependent type theory, types can depend on terms, which means that all of contexts, types and terms need to be defined simultaneously.
%
This is one reason why formalising type theory in type theory is hard.
%

Early approaches to formalising type theory, e.g.\ McKinna and Pollack~\cite{McKinna1999}, dealt with untyped terms that were later refined by a typing relation, setoid equality, or quotients, and thus had to prove a lot of congruence lemmas by hand~\cite{Danielsson2006,Chapman2009,Brunerie2019,Boer2020}.
%
A breakthrough was achieved by Altenkirch and Kaposi~\cite{Altenkirch2016a}, who showed that quotient inductive-inductive types (QIITs)~\cite{Altenkirch2018} can be employed to significantly simplify the internal representation of well typed terms (or, more precisely, derivations), since equality constructors can be used to represent equations such as $\beta$- and $\eta$-equality.
%
They took Dybjer's notion of a model of type theory in the form of a category with families~\cite{Dybjer1996}, and translated it into a QIIT definition.
%
In effect, this gives rise to the \emph{initial} category with families, with the elimination principles of the QIIT giving a unique morphism of categories with families to any other model.
%
This thus gives a both principled and practical way to formalise the syntax and equational theory of type theory in type theory; the feasibility of the approach was demonstrated by e.g.\ formalising normalisation by evaluation using this representation~\cite{Altenkirch2017}.

At the time of publication of Altenkirch and Kaposi~\cite{Altenkirch2016a}, the proof assistant \Agda did not allow equality constructors in data type declarations, so a workaround known as `Licata's trick'~\cite{Licata2011} was used by postulating (equality) constructors and writing down the eliminator explicitly, which meant giving up features of the proof assistant such as dependent pattern matching.
\CA, the cubical variant of \Agda~\cite{Vezzosi2021}, is now equipped with a native support for QIITs, so it is natural to ask if we can use this support to formalise the intrinsic representation of type theory without the trick or any other compromise.

In this paper, we explore this question and see what the proof assistant provides and lacks to achieve this goal.
We quickly find that their QIIT definitions break the strict positivity --- a syntactic restriction imposed by \CA to ensure consistency.
Moreover, their definition is cumbersome to work with, since the type of later constructors or even equations often only make sense because of earlier equations.
%
In an intensional type theory, such as those implemented in proof assistants, this manifests itself in transport terms across equality proofs \emph{inside} other terms, and leads to the so-called `transport hell' --- rather than just reasoning about the terms you actually want to study, you now also have to do a lot of reasoning about transports themselves and their algebraic properties.
%
It turns out that we need an alternative way of representing type theory intrinsically without any transport hell, in order to make our formalisation of type theory more lightweight and accepted by \CA.

%
The framework of categories with families is only one of several (more or less) equivalent notions of models of type theory~\cite{Hofmann1997}, and we were wondering if any of the other notions might offer any advantages.
%
Bense~\cite{Bense2024} suggested that Awodey's notion of natural model~\cite{Awodey2018} might be a good candidate.
%
Indeed, in a natural model, the indexing of terms over their types $\mathsf{Tm}_{\Gamma} : \mathsf{Ty}(\Gamma) \to \mathsf{Set}$ (as in a category with families) is replaced by a `fibred' perspective where each term instead \emph{has} a type, as picked out by a function $\mathsf{tyOf} : \mathsf{Tm}(\Gamma) \to \mathsf{Ty}(\Gamma)$.
%
Terms and types are still indexed by contexts $\Gamma$, but since most `type mismatches' arise from equations between types, not equations between contexts (indeed many formulations of type theory does not even have a notion of context equality), this should mean that many uses of transports can be avoided.

We test this hypothesis by formalising type theory in a form inspired by natural models.
%
\CA is particularly a good fit for such a project, because not only does it support QIITs, it also supports inductive-recursive types~\cite{Dybjer1999}, which are needed to simultaneously define the recursive $\mathsf{tyOf}$ function together with the inductively defined types $\mathsf{Tm}(\Gamma)$ and $\mathsf{Ty}(\Gamma)$.
%
Indeed, it could be the lack of support for inductive-recursive definitions in many proof assistants which has held back formalisation attempts based on natural models so far.

While we manage to avoid transports occurring in its own syntax, the experiment is not an outright success.
%
Indeed, we found that when developing more sophisticated metatheory, such as when defining a logical predicate model, the use of transports along equations often reappeared.
%
Strictification~\cite{Donko2022,Kaposi2025}, a recent technique for strictifying equations, cannot be applied directly because of the lack of strict proposition in the metatheory.
%
Furthermore, we found that the use of natural models is less well supported in the Cubical Agda of today, compared to approaches based purely on QIITs.
%
This is because we are more reliant on the computational behaviour of the recursively defined $\mathsf{tyOf}$ function, and this behaviour is only available in `later' clauses, which leads to the need for hacks and tricks to work around this limitation.
%
We discuss proof assistant features and their helpfulness further towards the end of the paper, after presenting our formalisation.

\paragraph{Contributions} We make the following contributions:
\begin{itemize}
\item We present an intrinsically well typed representation of the syntax of type theory, inspired by Awodey's natural models (\cref{sec:tt}).
\item We derive elimination and recursion principles for the syntax (\cref{sec:tt:elim}), and show how the standard model and the term model are constructed (\cref{sec:standard-model}).
\item We discuss strictification constructions on models, and show that they also apply to our notion of natural models (\cref{sec:strictify}).
\item We develop normalisation by evaluation for substitution calculus~(\cref{sec:nbe}) as a proof of concept: our development is carried out in \CA, which has a computational implementation of QIITs and principles such as function extensionality, so the resulting normaliser computes, and can potentially be extracted as a verified program.
\item We discuss pros and cons of our approach compared to other approaches, and which features of a proof assistant and its metatheory would make future formalisation more feasible (\cref{sec:discussion}).
\end{itemize}

%\LT{the idea of using natural model appears at least in 2024 \cite{Bense2024}, and it is a natural idea to formalise type theory in this way.}
\section{Setting and metatheory}
% FNF (Sun 7 Sep)

%\LT{Should we discharge this assumption in our formalisation, eg set-truncate where needed instead? (R1, R2)}
Our formalisation is carried out in \CA without the use of the \ensuremath{\Conid{Glue}} type and, in particular, the univalence principle, checked using the option \text{\ttfamily \char45{}\char45{}cubical\char61{}no\char45{}glue} available in the forthcoming \Agda 2.9.0.
%
We explicitly set-truncate the types we define.
Therefore, the term \emph{set} is used interchangeably with type.
%
For the sake of simplicity we occasionally postulate uniqueness of identity proofs (UIP) locally, which is of course inconsistent with univalence but in principle compatible with cubical type theory. 
%
We believe that the cubical type theory XTT~\cite{Sterling2022}, which enjoys definitional UIP without univalence, justifies this local assumption.
%

\CA implements cubical type theory, and one of the important concepts therein is the interval type \ensuremath{\Conid{I}} with two distinguished endpoints \ensuremath{\Varid{i0}} and \ensuremath{\Varid{i1}}.
%
Propositional equality \ensuremath{\Varid{x}\;\mathop\equiv\;\Varid{y}} in a type \ensuremath{\Conid{A}} is given by \emph{paths} in \ensuremath{\Conid{A}}, i.e., by a functions \ensuremath{\Conid{I}\;\Varid{â†’}\;\Conid{A}}.
More generally, dependent paths \ensuremath{\Varid{p}\;\mathbin{:}\;\Conid{PathP}\;\Conid{P}\;\Varid{a}\;\Varid{b}} are dependent functions \ensuremath{\Varid{p}\;\mathbin{:}\;(\Varid{i}\;\mathbin{:}\;\Conid{I})\;\Varid{â†’}\;\Conid{P}\;\Varid{i}} sending \ensuremath{\Varid{i0}} to \ensuremath{\Varid{a}\;\mathbin{:}\;\Conid{P}\;\Varid{i0}} and \ensuremath{\Varid{i1}} to \ensuremath{\Varid{b}\;\mathbin{:}\;\Conid{P}\;\Varid{i1}}.
Note that \ensuremath{\Conid{P}\;\mathbin{:}\;\Conid{I}\;\Varid{â†’}\;\Conid{Type}} itself is a path in the universe \ensuremath{\Conid{Type}}, hence a witness that \ensuremath{\Conid{P}\;\Varid{i0}\;\mathop\equiv\;\Conid{P}\;\Varid{i1}}, which the dependent path is \emph{over}, so paths are special cases of \ensuremath{\Conid{PathP}} with \ensuremath{\Conid{P}} being a constant path.
%
The constant path \ensuremath{\Varid{refl}} defined as \ensuremath{\Varid{Î»}\;\anonymous \;\Varid{â†’}\;\Varid{a}} witnesses that equality is reflexive \ensuremath{\Varid{a}\;\mathop\equiv\;\Varid{a}}, and paths can be lifted to type families in the sense that there is a transport operation \ensuremath{\Varid{subst}\;\mathbin{:}\;(\Conid{P}\;\mathbin{:}\;\Conid{A}\;\Varid{â†’}\;\Conid{Type})\;\Varid{â†’}\;\Varid{x}\;\mathop\equiv\;\Varid{y}\;\Varid{â†’}\;\Conid{P}\;\Varid{x}\;\Varid{â†’}\;\Conid{P}\;\Varid{y}}.
%
See the literature on cubical type theory for details~\cite{Vezzosi2021}.
%

\CA also allows paths to appear as the target of constructors in inductive definitions.
That is, it implements higher inductive types~\cite{Lumsdaine2020}.
%
When defining a function \ensuremath{\Varid{f}\;\mathbin{:}\;\Conid{H}\;\Varid{â†’}\;\Conid{X}} by pattern matching out of a higher inductive type, \ensuremath{\Varid{f}} also needs to be defined on the path constructors: if \ensuremath{\Varid{e}\;\mathbin{:}\;\Varid{s}\;\mathop\equiv\;\Varid{t}} is a path from \ensuremath{\Varid{s}} to \ensuremath{\Varid{t}} in \ensuremath{\Conid{H}}, then \ensuremath{\Varid{f}\;\Varid{e}\;\mathbin{:}\;\Varid{f}\;\Varid{s}\;\mathop\equiv\;\Varid{f}\;\Varid{t}} should be a path from \ensuremath{\Varid{f}\;\Varid{s}} to \ensuremath{\Varid{f}\;\Varid{t}} in \ensuremath{\Conid{X}}.
%
Agda's support for simultaneous definitions allows us to define quotient inductive-inductive types (QIITs)~\cite{Altenkirch2018}, where a type \ensuremath{\Conid{A}\;\mathbin{:}\;\Conid{Type}} and a type family \ensuremath{\Conid{B}\;\mathbin{:}\;\Conid{A}\;\Varid{â†’}\;\Conid{Type}} are defined inductively simultaneously.
%
Agda even allows us to define quotient inductive-inductive-recursive types (QIIRTs), where \ensuremath{\Conid{A}\;\mathbin{:}\;\Conid{Type}} and \ensuremath{\Conid{B}\;\mathbin{:}\;\Conid{A}\;\Varid{â†’}\;\Conid{Type}} are defined inductively together with a recursive function \ensuremath{\Varid{f}\;\mathbin{:}\;\Conid{A}\;\Varid{â†’}\;\Conid{C}}.
%
We will make use of this feature to define types, terms and the \ensuremath{\Varid{tyOf}} function from terms to types simultaneously.

For the brevity of presentation, we have made arguments implicit for equality constructors, even though they are explicit in our formalisation.
%
Similarly, we are ignoring universe levels, but they are all present in the formalisation.

\section{Type theory as quotient inductive types} \label{sec:tt}

%\FNF{Discuss ``another approach is staying completely indexed and always using PathP instead of transports'' here, or in Discussion (R2)}

In this section, we will explain why Altenkirch and Kaposi's representation~\cite{Altenkirch2016a} is hard to use in practice and rejected by \CA arising from transports in its definition.
Then, we show how their representation can be transformed to a representation based on Awodey's natural models.
This representation is accepted by \CA, since it is free from transports.

%This section's aim is to exhibit that Altenkirch and Kaposi's representation, which contains the transport hells and violates the syntactic restriction imposed by \CA, can be transformed to a representation based on Awodey's natural model, which is free from transports and accepted by \CA.
%Then, we will show how other type formers can be represented in this way.
%In the reminder of this section, we will give its elimination principle and explain how these definitions are formalised in \CA.

\subsection{Type theory as the initial CwF model} \label{sec:tt:cwf}
We briefly recall the QIIT representation given by Altenkirch and Kaposi.
Each judgement therein is defined as an inductive type, each typing rule as a constructor, and each equality between types, terms, and substitutions as an \emph{equality constructor}.
The inhabitants of these types are valid derivations in type theory, because their validity is enforced by typing constraints.
The four types of judgements in type theory are represented inductive-inductively %and indexed by their context and by their types for terms
as
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Ctx}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{Sub}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;{}\<[24]%
\>[24]{}\Varid{â†’}\;(\Conid{Î”}\;\mathbin{:}\;\Conid{Ctx})\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{Ty}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;{}\<[24]%
\>[24]{}\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{Tm}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;{}\<[24]%
\>[24]{}\Varid{â†’}\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
For example, an inhabitant of \ensuremath{\Conid{Tm}\;\Conid{Î“}\;\Conid{A}} represents a derivation for a term of type $A$ in context \ensuremath{\Conid{Î“}}.
Rules are represented by constructors of these inductive types:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{âˆ…}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Ctx}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ,\char95 }\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Ctx}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\_[\_]_{\text{T}}\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î”})\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\_[\_]_{\text{t}}\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î”}\;\Conid{A})\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}\;(\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{idS}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 âˆ˜\char95 }\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Sub}\;\Conid{Î”}\;\Conid{Î˜}\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”}\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î˜}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ,\char95 }\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}\;(\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}))\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;(\Conid{Î”}\;\Varid{,}\;\Conid{A}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}[\circ]_{\text{T}}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï„}\;\Varid{âˆ˜}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 The constructor \ensuremath{\Varid{âˆ…}} represents the empty context, and \ensuremath{\Conid{Î“}\;\Varid{,}\;\Conid{A}} a context extension, while \ensuremath{\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} and \ensuremath{\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}} represent substituted types and terms, respectively.
Further, \ensuremath{\Varid{idS}} is the identity substitution, \ensuremath{\Varid{\char95 âˆ˜\char95 }} the constructor for substitution composition, and the second \ensuremath{\Varid{\char95 ,\char95 }} the constructor for extending a substitution \ensuremath{\Varid{Ïƒ}} with a term \ensuremath{\Varid{t}} of type \ensuremath{\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} (making use of \Agda's support for overloaded constructor names).
The equality constructor~\ensuremath{[\circ]_{\text{T}}} states that type substitution by \ensuremath{\Varid{Ï„}} followed by type substitution by \ensuremath{\Varid{Ïƒ}} is the same as a single substitution by the composition \ensuremath{\Varid{Ï„}\;\Varid{âˆ˜}\;\Varid{Ïƒ}}.

When formulating the corresponding rule for the interaction between \ensuremath{\Varid{\char95 âˆ˜\char95 }} and \ensuremath{\Varid{\char95 ,\char95 }}, we encounter a type mismatch that needs to be resolved by a transport (highlighted in \highlight{addition}{\text{green}}): %, leading to the transport hell when reasoning with this equality:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{,âˆ˜}\;{}\<[5]%
\>[5]{}\mathbin{:}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t})\;\Varid{âˆ˜}\;\Varid{Ï„}\;\mathop\equiv\;(\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„}\;\Varid{,}\;\highlight{addition}{\Varid{subst}\;(\Conid{Tm}\;\Conid{Î“})\;[\circ]_{\text{T}}}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The reason is that the type of \ensuremath{\Varid{t}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}}} is \ensuremath{\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}} rather than the required \ensuremath{\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}}.
However, since \ensuremath{\Conid{Tm}} is an argument to \ensuremath{\Varid{subst}}, the use of transport violates a syntactic restriction of \Agda, namely its strict positivity check.
In theory, transports are allowed in QIITs~\cite{Kaposi2019}, but it is not clear to us how this syntactic restriction should be relaxed for higher inductive types supported by \CA to take into account other cubical primitives (such as \ensuremath{\Varid{hcomp}}).

In other words, transport hell is not only an obstacle for reasoning, but also breaks strict positivity in \CA when arising in inductive definitions themselves.
The situation becomes worse once additional type formers are introduced --- such as $\Pi$-types and the type \ensuremath{\Conid{El}} of elements~\cite{Altenkirch2016a} --- since each brings further instances of this problem.
%
Of course, one could bypass the strict positivity check, but doing so would undermine the general trustworthiness of formalisation.
Another possibility is to fix the syntactic restriction for HIITs, but it is unclear what conditions should be.
Therefore, we seek for an equivalent definition without transports first.

Another source of transports arises from equations over equations, but this can be avoided by using dependent paths.
For example, the fact that the identity term substitution really acts as an identity is introduced as an equality constructor \ensuremath{[\mathsf{idS}]_{\text{t}}}, defined over the highlighted equality constructor \ensuremath{[\mathsf{idS}]_{\text{T}}\;\mathbin{:}\;\Conid{A}\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{idS}\;\kern-1.5pt]_{\text{T}}} for the identity type substitution:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}[\mathsf{idS}]_{\text{t}}\;\mathbin{:}\;\Conid{PathP}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}\;(\highlight{addition}{[\mathsf{idS}]_{\text{T}}\;\Varid{i}}))\;\Varid{t}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{idS}\;\kern-1.5pt]_{\text{t}}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Although equations over equations are in principle more manageable, it quickly leads us to \emph{equations over equations over yet more equations} in their elimination rules.
Hence, it is still preferable to avoid them if possible.

\subsection{The `Ford transformation' and index elimination} \label{sec:tt:terms-without-indices}

To avoid transports in the definition itself, we note that the index \ensuremath{\Conid{A}} of \ensuremath{\Conid{Tm}\;\Conid{Î“}\;\Conid{A}} often needs an explicit proof for the typing constraint --- for example, that the term \ensuremath{\Varid{t}} in the substitution \ensuremath{(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t})} has type \ensuremath{\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} --- if this does not happen to hold strictly (i.e., up to judgemental equality), so enforcing this constraint in the index of \ensuremath{\Conid{Tm}} just shoots ourselves in the foot.
Hence, we apply the `Ford transformation'~\cite{McBride1999} (`You can have any index you want, as long as it is equal to the specified one') to move the constraint on its index to its argument as an equality proof (highlighted below):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{\char95 ,\char95 âˆ¶[\char95 ]}\;\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}\;\Conid{B})\;\highlight{addition}{(\Varid{pt}\;\mathbin{:}\;\Conid{B}\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}})}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;(\Conid{Î”}\;\Varid{,}\;\Conid{A}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The constructor \ensuremath{\Varid{,âˆ˜}} which had a transport in its type becomes
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{,âˆ˜}\;{}\<[5]%
\>[5]{}\mathbin{:}\;\Varid{...}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{pt}\;\mskip1.5mu])\;\Varid{âˆ˜}\;\Varid{Ï„}\;{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\mathop\equiv\;(\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„}\;\Varid{,}\;\Varid{t}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}}\;\Varid{âˆ¶[}\;\highlight{addition}{\Varid{cong}\;\Varid{\char95 [}\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}\;\Varid{pt}\;\Varid{âˆ™}\;[\circ]_{\text{T}}}\;\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{\char95 âˆ™\char95 }} is the transitivity of equality.
Although transport is not needed this time, the use of \ensuremath{\Varid{cong}} and \ensuremath{\Varid{\char95 âˆ™\char95 }}
still prevent the definition from being seen as strictly positive.
Similar to the Ford transformation, this problem can be overcome by asking for another equality proof, highlighted below, as an argument:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{,âˆ˜}\;\mathbin{:}\;\Varid{...}\;\highlight{addition}{(\Varid{qt}\;\mathbin{:}\;\Conid{B}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}})}\;{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{â†’}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{pt}\;\mskip1.5mu])\;\Varid{âˆ˜}\;\Varid{Ï„}\;\mathop\equiv\;(\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„})\;\Varid{,}\;\Varid{t}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}}\;\Varid{âˆ¶[}\;\highlight{addition}{\Varid{qt}}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
As \ensuremath{\Conid{Sub}} is a set, the additional argument is essentially unique, so this updated constructor does not require any information but only defers the proof obligation.
%This redundant argument can be removed later when defining its eliminator (\Cref{sec:tt:elim}).

Once the Ford transformation has been applied, the index \ensuremath{\Conid{B}} in \ensuremath{\Conid{Tm}\;\Conid{Î“}\;\Conid{B}} no longer plays the role of enforcing constraints.
This opens the door to a simpler design: instead of carrying the index around, we can `Ford' all \ensuremath{\Conid{Tm}} constructors uniformly and remove the index entirely.
To preserve the necessary typing information, we simultaneously introduce an auxiliary function \ensuremath{\Varid{tyOf}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}} that records it explicitly.
In the end, the constructor \ensuremath{\Varid{,âˆ˜}} becomes
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{,âˆ˜}\;\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î”}\;\Conid{Î˜})\;(\Varid{t}\;\mathbin{:}\;\highlight{addition}{\Conid{Tm}\;\Conid{Î”}})\;(\Varid{Ï„}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{â†’}\;(\Varid{pt}\;\mathbin{:}\;\highlight{addition}{\Varid{tyOf}\;\Varid{t}}\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}})\;{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{â†’}\;(\Varid{qt}\;\mathbin{:}\;\highlight{addition}{\Varid{tyOf}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}})}\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}})\;{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{â†’}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{pt}\;\mskip1.5mu])\;\Varid{âˆ˜}\;\Varid{Ï„}\;\mathop\equiv\;(\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„})\;\Varid{,}\;\Varid{t}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}}\;\Varid{âˆ¶[}\;\Varid{qt}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As a side effect, this approach also removes the need for dependent paths in the definition.
Two terms can now be compared even when it is not known in advance whether their types are equal.
For instance, the equality constructor for the identity substitution becomes
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}[\mathsf{idS}]_{\text{t}}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{t}\;\mathop\equiv\;\Varid{t}\;[\kern-1.5pt\;\Varid{idS}\;\kern-1.5pt]_{\text{t}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where the fact that \ensuremath{\Varid{t}} and \ensuremath{\Varid{t}\;[\kern-1.5pt\;\Varid{idS}\;\kern-1.5pt]_{\text{t}}} share the same type follows from their term equality, rather than being a \emph{requirement}.

\subsection{Representing substitution calculus using QIIRT}
Building on the changes described in \Cref{sec:tt:terms-without-indices}, we now spell out our version of substitution calculus. The following types are defined simultaneously with a recursive function (changes compared to the QIIT version highlighted):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Ctx}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{Sub}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;\Varid{â†’}\;(\Conid{Î”}\;\mathbin{:}\;\Conid{Ctx})\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{Ty}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\Conid{Tm}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\highlight{addition}{(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;\Varid{â†’}\;\Conid{Set}}{}\<[E]%
\\
\>[B]{}\highlight{addition}{\Varid{tyOf}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Similarly to the QIIT representation, constructors are introduced for rules and equalities as follows, where we highlight constructors that are different from their QIIT counterpart:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{44}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{âˆ…}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{Ctx}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ,\char95 }\;{}\<[18]%
\>[18]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Ctx}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\_[\_]_{\text{T}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î”})\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\_[\_]_{\text{t}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î”})\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{âˆ…}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Varid{âˆ…}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\highlight{addition}{\Varid{\char95 ,\char95 âˆ¶[\char95 ]}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;(\Varid{pt}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{t}\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;(\Conid{Î”}\;\Varid{,}\;\Conid{A}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{idS}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 âˆ˜\char95 }\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{Sub}\;\Conid{Î”}\;\Conid{Î˜}\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”}\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î˜}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ï€â‚}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;(\Conid{Î”}\;\Varid{,}\;\Conid{A})\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ï€â‚‚}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;(\Conid{Î”}\;\Varid{,}\;\Conid{A})\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{idSâˆ˜\char95 }\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Varid{idS}\;\Varid{âˆ˜}\;\Varid{Ïƒ}\;\mathop\equiv\;\Varid{Ïƒ}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 âˆ˜idS}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{idS}\;\mathop\equiv\;\Varid{Ïƒ}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{assocS}\;{}\<[18]%
\>[18]{}\mathbin{:}\;(\Varid{Î³}\;\Varid{âˆ˜}\;\Varid{Ï„})\;\Varid{âˆ˜}\;\Varid{Ïƒ}\;\mathop\equiv\;\Varid{Î³}\;\Varid{âˆ˜}\;(\Varid{Ï„}\;\Varid{âˆ˜}\;\Varid{Ïƒ}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}[\mathsf{idS}]_{\text{T}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{A}\;{}\<[23]%
\>[23]{}\mathop\equiv\;{}\<[26]%
\>[26]{}\Conid{A}\;{}\<[29]%
\>[29]{}[\kern-1.5pt\;\Varid{idS}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\highlight{addition}{[\mathsf{idS}]_{\text{t}}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Varid{t}\;{}\<[23]%
\>[23]{}\mathop\equiv\;{}\<[26]%
\>[26]{}\Varid{t}\;{}\<[29]%
\>[29]{}[\kern-1.5pt\;\Varid{idS}\;\kern-1.5pt]_{\text{t}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}[\circ]_{\text{T}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Conid{A}\;{}\<[23]%
\>[23]{}[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}\;{}\<[31]%
\>[31]{}[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;{}\<[39]%
\>[39]{}\mathop\equiv\;\Conid{A}\;{}\<[44]%
\>[44]{}[\kern-1.5pt\;\Varid{Ï„}\;\Varid{âˆ˜}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\highlight{addition}{[\circ]_{\text{t}}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;\Varid{t}\;{}\<[23]%
\>[23]{}[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}}\;{}\<[31]%
\>[31]{}[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;{}\<[39]%
\>[39]{}\mathop\equiv\;\Varid{t}\;{}\<[44]%
\>[44]{}[\kern-1.5pt\;\Varid{Ï„}\;\Varid{âˆ˜}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\highlight{addition}{\Varid{,âˆ˜}}\;{}\<[18]%
\>[18]{}\mathbin{:}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{pt}\;\mskip1.5mu])\;\Varid{âˆ˜}\;\Varid{Ï„}\;\mathop\equiv\;(\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï„}\;\Varid{,}\;\Varid{t}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}}\;\Varid{âˆ¶[}\;\Varid{qt}\;\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We write \ensuremath{\Varid{wk}} for the `weakening' substitution \ensuremath{\Varid{wk}\;\mathrel{=}\;\Varid{Ï€â‚}\;\Varid{idS}\;\mathbin{:}\;\Conid{Sub}\;(\Conid{Î“}\;\Varid{,}\;\Conid{A})\;\Conid{Î“}}, and \ensuremath{\Varid{vz}} for the `top variable' \ensuremath{\Varid{vz}\;\mathrel{=}\;\Varid{Ï€â‚‚}\;\Varid{idS}\;\mathbin{:}\;\Conid{Tm}\;(\Conid{Î“}\;\Varid{,}\;\Conid{A})}.
This works well except that we have to interleave the function clauses of \ensuremath{\Varid{tyOf}} with constructors.
For example, we need define the function clause for \ensuremath{\Varid{Ï€â‚‚}\;\Varid{Ïƒ}} before the $\eta$-law for substitution:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{Î”}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mskip1.5mu\}\;\Varid{Ïƒ})\;{}\<[27]%
\>[27]{}\mathrel{=}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Î·Ï€}\;\mathbin{:}\;\Varid{Ïƒ}\;\mathop\equiv\;(\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\Varid{,}\;\Varid{Ï€â‚‚}\;\Varid{Ïƒ}\;\Varid{âˆ¶[}\;\Varid{refl}\;\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Otherwise, the proof obligation \ensuremath{\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\Varid{Ïƒ})\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} on the right hand side of \ensuremath{\Varid{Î·Ï€}} cannot be fulfilled by \ensuremath{\Varid{refl}}.
We proceed with other equality constructors:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Î·âˆ…}\;{}\<[8]%
\>[8]{}\mathbin{:}\;\Varid{Ïƒ}\;\mathop\equiv\;\Varid{âˆ…S}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Î²Ï€â‚}\;{}\<[8]%
\>[8]{}\mathbin{:}\;\Varid{Ï€â‚}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{p}\;\mskip1.5mu])\;\mathop\equiv\;\Varid{Ïƒ}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Î²Ï€â‚‚}\;{}\<[8]%
\>[8]{}\mathbin{:}\;\Varid{...}\;\highlight{addition}{(\Varid{q}\;\mathbin{:}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{p}\;\mskip1.5mu])\;\kern-1.5pt]_{\text{T}}\;\mathop\equiv\;\Varid{tyOf}\;\Varid{t})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Varid{Ï€â‚‚}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{p}\;\mskip1.5mu])\;\mathop\equiv\;\Varid{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Note that \ensuremath{\Varid{Î²Ï€â‚‚}} has an additional derivable equality proof \ensuremath{\highlight{addition}{\Varid{q}}}.
This argument is needed as the coherence condition for
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tyOf}\;(\Varid{Î²Ï€â‚‚}\;\Varid{...}\;\Varid{q}\;\Varid{i})\;{}\<[21]%
\>[21]{}\mathrel{=}\;\Varid{q}\;\Varid{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
since again using any other function while defining inductive types breaks the strict positivity check.
The remaining clauses are given as
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tyOf}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;{}\<[18]%
\>[18]{}\mathrel{=}\;(\Varid{tyOf}\;\Varid{t})\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;([\mathsf{idS}]_{\text{t}}\;\Varid{i})\;{}\<[18]%
\>[18]{}\mathrel{=}\;[\mathsf{idS}]_{\text{T}}\;\Varid{i}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;([\circ]_{\text{t}}\;\Varid{i})\;{}\<[18]%
\>[18]{}\mathrel{=}\;[\circ]_{\text{T}}\;\Varid{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This definition is accepted by \CA\footnote{At the time of writing, \CA does not support interleaved mutual definitions, but it can be equivalently defined using forward declarations.
We will discuss this idiom in \Cref{sec:tt:mutual}.}
without any warnings or errors.
Although \ensuremath{\Conid{Tm}} is only indexed by \ensuremath{\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx}}, the function \ensuremath{\Varid{tyOf}} ensures that every \ensuremath{\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}} has a type.
Hence, \ensuremath{\Conid{Tm}} only consists of valid derivations and is still an intrinsic representation of type theory.

Replacing the index \ensuremath{\Conid{A}\;\mathbin{:}\;\Conid{Ty}} of \ensuremath{\Conid{Tm}} by a function \ensuremath{\Varid{tyOf}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}} aligns with Awodey's notion of natural model~\cite{Awodey2018} where the collections of terms and types are represented as presheaves $\mathsf{Tm}, \mathsf{Ty} \colon \mathbb{C} \to \Set$ over the category of contexts $\mathbb{C}$ and connected by a natural transformation $\mathsf{Tm} \to \mathsf{Ty}$ satisfying that each substitution into a non-empty context is equivalent to a pair of substitution and a term.
That is, we have derived the intrinsic representation of type theory as a natural model using QIIRT in \CA.
This situates our family of inductive types and their algebras within a well-studied categorical models for type theory.

\subsection{\texorpdfstring{$\Pi$}{Pi}-types}

We extend our object type theory with dependent function types.
First we define the lifting of a substitution by a type as the following abbreviation:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{\char95 â†‘\char95 }\;\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Sub}\;(\Conid{Î“}\;\Varid{,}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}})\;(\Conid{Î”}\;\Varid{,}\;\Conid{A}){}\<[E]%
\\
\>[B]{}\Varid{\char95 â†‘\char95 }\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\Varid{Ïƒ}\;\Conid{A}\;\mathrel{=}\;{}\<[16]%
\>[16]{}\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï€â‚}\;\{\mskip1.5mu \Conid{Î“}\;\Varid{,}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\mskip1.5mu\}\;\Varid{idS,}\;{}\<[E]%
\\
\>[16]{}\Varid{Ï€â‚‚}\;(\Varid{idS}\;\{\mskip1.5mu \Conid{Î“}\;\Varid{,}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\mskip1.5mu\})\;\Varid{âˆ¶[}\;\Varid{p}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{p}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\Varid{idS})\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï€â‚}\;\Varid{idS}\;\kern-1.5pt]_{\text{T}}}.
We can use \ensuremath{[\circ]_{\text{T}}} to define \ensuremath{\Varid{p}}, as \ensuremath{\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;(\Varid{idS}\;\{\mskip1.5mu \Conid{Î“}\;\Varid{,}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\mskip1.5mu\}))} is equal to \ensuremath{\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{idS}\;\kern-1.5pt]_{\text{T}}} by definition.\footnote{%
Yet, as interleaving function clauses with inductive types is also not supported, the strict equality \ensuremath{\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\Varid{Ïƒ})\;\mathrel{=}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} is not available at this point for \ensuremath{\Varid{p}}.
We use forward declarations to introduce the required equalities \ensuremath{\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\Varid{Ïƒ})\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} and \ensuremath{\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\Varid{idS})\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï€â‚}\;\Varid{idS}\;\kern-1.5pt]_{\text{T}}} to be defined later as \ensuremath{\Varid{refl}} and \ensuremath{[\circ]_{\text{T}}}, see \Cref{sec:tt:mutual} for further details.}

Other constructors are introduced following the `Ford transformation', with differences compared to the usual QIIT presentation highlighted:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{49}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Î }\;{}\<[16]%
\>[16]{}\mathbin{:}\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;(\Conid{B}\;\mathbin{:}\;\Conid{Ty}\;(\Conid{Î“}\;\Varid{,}\;\Conid{A}))\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\highlight{addition}{\Varid{app}}\;{}\<[16]%
\>[16]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;(\Conid{B}\;\mathbin{:}\;\Conid{Ty}\;(\Conid{Î“}\;\Varid{,}\;\Conid{A}))\;\highlight{addition}{(\Varid{pt}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{t}\;\mathop\equiv\;\Conid{Î }\;\Conid{A}\;\Conid{B})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Conid{Tm}\;(\Conid{Î“}\;\Varid{,}\;\Conid{A}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{abs}\;{}\<[16]%
\>[16]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;(\Conid{Î“}\;\Varid{,}\;\Conid{A}))\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Î []}\;{}\<[16]%
\>[16]{}\mathbin{:}\;(\Conid{Î }\;\Conid{A}\;\Conid{B})\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;\mathop\equiv\;\Conid{Î }\;(\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}})\;(\Conid{B}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘}\;\Conid{A}\;\kern-1.5pt]_{\text{T}}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\highlight{addition}{\Varid{abs[]}}\;{}\<[16]%
\>[16]{}\mathbin{:}\;\Varid{abs}\;\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;\mathop\equiv\;\Varid{abs}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘}\;\Conid{A}\;\kern-1.5pt]_{\text{t}}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Î Î²}\;{}\<[16]%
\>[16]{}\mathbin{:}\;\Varid{app}\;(\Varid{abs}\;\Varid{t})\;(\Varid{tyOf}\;\Varid{t})\;\highlight{addition}{\Varid{pt}}\;{}\<[49]%
\>[49]{}\mathop\equiv\;\Varid{t}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Î Î·}\;{}\<[16]%
\>[16]{}\mathbin{:}\;\Varid{abs}\;(\Varid{app}\;\Varid{t}\;\Conid{B}\;\Varid{pt})\;{}\<[49]%
\>[49]{}\mathop\equiv\;\Varid{t}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tyOf}\;(\Varid{app}\;\Varid{t}\;\Conid{B}\;\Varid{p})\;{}\<[23]%
\>[23]{}\mathrel{=}\;\Conid{B}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;(\Varid{abs}\;\{\mskip1.5mu \Conid{A}\;\mathrel{=}\;\Conid{A}\mskip1.5mu\}\;\Varid{t})\;{}\<[23]%
\>[23]{}\mathrel{=}\;\Conid{Î }\;\Conid{A}\;(\Varid{tyOf}\;\Varid{t}){}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;(\Varid{abs[]}\;\Varid{Ïƒ}\;\Varid{t}\;\Varid{i})\;{}\<[23]%
\>[23]{}\mathrel{=}\;\Conid{Î []}\;\Varid{Ïƒ}\;(\Varid{tyOf}\;\Varid{t})\;\Varid{i}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;(\Conid{Î Î²}\;\Varid{t}\;\Varid{pt}\;\Varid{i})\;{}\<[23]%
\>[23]{}\mathrel{=}\;\Varid{tyOf}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;(\Conid{Î Î·}\;\Varid{t}\;\Varid{pt}\;\Varid{i})\;{}\<[23]%
\>[23]{}\mathrel{=}\;\Varid{pt}\;(\mathord{\sim}\;\Varid{i}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Apart from the extra clauses of \ensuremath{\Varid{tyOf}}, the main change happens in the constructor \ensuremath{\Varid{app}}.
The constraint that \ensuremath{\Varid{t}} is of type \ensuremath{\Conid{Î }\;\Conid{A}\;\Conid{B}} is enforced there, but every other constructor remains as almost the same as their QIIT definition.
We have formulated application and abstraction as an isomorphism between terms of type \ensuremath{\Conid{B}} in context \ensuremath{\Conid{Î“}\;\Varid{,}\;\Conid{A}} and terms of type \ensuremath{\Conid{Î }\;\Conid{A}\;\Conid{B}} in context \ensuremath{\Conid{Î“}}, but we can also derive ordinary application:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{\char95 âˆ¶[\char95 ]\$\$\char95 âˆ¶[\char95 ]}\;{}\<[15]%
\>[15]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;\Varid{â†’}\;\Varid{tyOf}\;\Varid{t}\;\mathop\equiv\;\Conid{Î }\;\Conid{A}\;\Conid{B}\;{}\<[E]%
\\
\>[15]{}\Varid{â†’}\;(\Varid{s}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;\Varid{â†’}\;\Varid{tyOf}\;\Varid{s}\;\mathop\equiv\;\Conid{A}\;{}\<[E]%
\\
\>[15]{}\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\Varid{t}\;\Varid{âˆ¶[}\;\Varid{p}\;\Varid{]\$\$}\;\Varid{s}\;\Varid{âˆ¶[}\;\Varid{q}\;\mskip1.5mu]\;\mathrel{=}\;\Varid{app}\;\Varid{t}\;\anonymous \;\Varid{p}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{s}\;\Varid{âˆ¶[}\;\Varid{q}\;\Varid{âˆ™}\;[\mathsf{idS}]_{\text{T}}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{t}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

As an example, we can write the identity function at type \ensuremath{\Conid{A}} as \ensuremath{\Varid{id}\;\Conid{A}\;\mathrel{=}\;\Varid{abs}\;\{\mskip1.5mu \Conid{A}\;\mathrel{=}\;\Conid{A}\mskip1.5mu\}\;(\Varid{Ï€â‚‚}\;\Varid{idS})}, and the identity function at type \ensuremath{\Conid{Î }\;\Conid{A}\;(\Conid{A}\;[\kern-1.5pt\;\Varid{wk}\;\kern-1.5pt]_{\text{T}})} applied to the identity function at type \ensuremath{\Conid{A}} is represented by
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{idid}\;\mathbin{:}\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\Varid{idid}\;\Conid{A}\;\mathrel{=}\;\Varid{id}\;(\Conid{Î }\;\Conid{A}\;(\Conid{A}\;[\kern-1.5pt\;\Varid{wk}\;\mskip1.5mu]))\;\Varid{âˆ¶[}\;\Varid{refl}\;\Varid{]\$\$}\;\Varid{id}\;\Conid{A}\;\Varid{âˆ¶[}\;\Varid{refl}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
and indeed using the equality constructors, we have a proof of \ensuremath{\Varid{tyOf}\;(\Varid{idid}\;\Conid{A})\;\mathop\equiv\;\Conid{Î }\;\Conid{A}\;(\Conid{A}\;[\kern-1.5pt\;\Varid{wk}\;\kern-1.5pt]_{\text{T}})} as expected.

\subsection{The type of Booleans}

To introduce the inductive type of Booleans, we need to specialise the substitution lifting.
Let us see its constructors (with differences highlighted) and explain why a specialisation is needed.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ğ”¹}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ğ”¹[]}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{ğ”¹}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;\mathop\equiv\;\Conid{ğ”¹}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{tt}\;\Varid{ff}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{tt[]}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{tt}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;\mathop\equiv\;\Varid{tt}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ff[]}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{ff}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;\mathop\equiv\;\Varid{ff}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tyOf}\;\Varid{tt}\;{}\<[10]%
\>[10]{}\mathrel{=}\;\Conid{ğ”¹}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;\Varid{ff}\;{}\<[10]%
\>[10]{}\mathrel{=}\;\Conid{ğ”¹}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;(\Varid{tt[]}\;\Varid{Ïƒ}\;\Varid{i})\;{}\<[18]%
\>[18]{}\mathrel{=}\;\Conid{ğ”¹[]}\;\Varid{Ïƒ}\;\Varid{i}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;(\Varid{ff[]}\;\Varid{Ïƒ}\;\Varid{i})\;{}\<[18]%
\>[18]{}\mathrel{=}\;\Conid{ğ”¹[]}\;\Varid{Ïƒ}\;\Varid{i}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{elimğ”¹}\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Conid{P}\;\mathbin{:}\;\Conid{Ty}\;(\Conid{Î“}\;\Varid{,}\;\Conid{ğ”¹}))\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;{}\<[17]%
\>[17]{}\highlight{addition}{(\Varid{pt}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{t}\;\mathop\equiv\;\Conid{P}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{tt}\;\Varid{âˆ¶[}\;[\mathsf{idS}]_{\text{T}}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{u}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;{}\<[17]%
\>[17]{}\highlight{addition}{(\Varid{pu}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{u}\;\mathop\equiv\;\Conid{P}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{ff}\;\Varid{âˆ¶[}\;[\mathsf{idS}]_{\text{T}}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{b}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;{}\<[17]%
\>[17]{}\highlight{addition}{(\Varid{pb}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{b}\;\mathop\equiv\;\Conid{ğ”¹}\;[\kern-1.5pt\;\Varid{idS}\;\mskip1.5mu])}\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tyOf}\;(\Varid{elimğ”¹}\;\Conid{P}\;\Varid{u}\;\Varid{t}\;\Varid{pu}\;\Varid{pt}\;\Varid{b}\;\Varid{pb})\;\mathrel{=}\;\Conid{P}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{b}\;\Varid{âˆ¶[}\;\Varid{pb}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The only thing missing from the above definition is the substitution rule for \ensuremath{\Varid{elimğ”¹}}:
applying the substitution \ensuremath{\Varid{Ïƒ}} to `\ensuremath{\Varid{elimğ”¹}\;\Conid{P}\;\Varid{t}\;\Varid{pt}\;\Varid{u}\;\Varid{pu}\;\Varid{b}\;\Varid{pb}}' is equal to applying a lifted substitution  \ensuremath{\Varid{Ïƒ}\;\Varid{â†‘}\;\Conid{ğ”¹}} to \ensuremath{\Conid{P}} and \ensuremath{\Varid{Ïƒ}} to \ensuremath{\Varid{t}}, \ensuremath{\Varid{u}}, and \ensuremath{\Varid{b}}.
However, \ensuremath{\Conid{P}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘}\;\Conid{ğ”¹}\;\kern-1.5pt]_{\text{T}}} gives us a type in the context \ensuremath{\Conid{Î”}\;\Varid{,}\;\Conid{ğ”¹}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} instead of \ensuremath{\Conid{Î”}\;\Varid{,}\;\Conid{ğ”¹}}, so we provide a lifting with a type \ensuremath{\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”}\;\Varid{â†’}\;\Conid{Sub}\;(\Conid{Î“}\;\Varid{,}\;\Conid{ğ”¹})\;(\Conid{Î”}\;\Varid{,}\;\Conid{ğ”¹})} with a proof that \ensuremath{\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\{\mskip1.5mu \Conid{Î“}\;\Varid{,}\;\Conid{ğ”¹}\mskip1.5mu\}\;\Varid{idS})\;\mathop\equiv\;\Conid{ğ”¹}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}}.
The proof, however, requires the transitivity of equalities, and \CA would see this as a strict positivity problem. Instead we introduce a \emph{superfluous} equality constructor \ensuremath{\Conid{ğ”¹[]â‚‚}} to satisfy its proof obligation (highlighted):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ğ”¹[]â‚‚}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\{\mskip1.5mu \Conid{Î“}\;\Varid{,}\;\Conid{ğ”¹}\mskip1.5mu\}\;\Varid{idS})\;\mathop\equiv\;\Conid{ğ”¹}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{\char95 â†‘ğ”¹}\;\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Sub}\;(\Conid{Î“}\;\Varid{,}\;\Conid{ğ”¹})\;(\Conid{Î”}\;\Varid{,}\;\Conid{ğ”¹}){}\<[E]%
\\
\>[B]{}\Varid{\char95 â†‘ğ”¹}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{Î”}\mskip1.5mu\}\;\Varid{Ïƒ}\;\mathrel{=}\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï€â‚}\;\{\mskip1.5mu \Conid{Î“}\;\Varid{,}\;\Conid{ğ”¹}\mskip1.5mu\}\;\Varid{idS}\;\Varid{,}\;\Varid{Ï€â‚‚}\;\Varid{idS}\;\Varid{âˆ¶[}\;\highlight{addition}{\Conid{ğ”¹[]â‚‚}}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Finally, we introduce the equality constructor for the interaction between \ensuremath{\Varid{elimğ”¹}} and substitution:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{elimğ”¹[]}\;\mathbin{:}\;\Varid{...}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{ptâ‚‚}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\mathop\equiv\;\Conid{P}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘ğ”¹}\;\kern-1.5pt]_{\text{T}}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{tt}\;\Varid{âˆ¶[}\;[\mathsf{idS}]_{\text{T}}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{puâ‚‚}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\mathop\equiv\;\Conid{P}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘ğ”¹}\;\kern-1.5pt]_{\text{T}}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{ff}\;\Varid{âˆ¶[}\;[\mathsf{idS}]_{\text{T}}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{pbâ‚‚}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{b}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\mathop\equiv\;\Conid{ğ”¹}\;[\kern-1.5pt\;\Varid{idS}\;\kern-1.5pt]_{\text{T}})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\Varid{q}\;\mathbin{:}\;{}\<[11]%
\>[11]{}\Conid{P}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{b}\;\Varid{âˆ¶[}\;\Varid{pb}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;{}\<[E]%
\\
\>[11]{}\mathop\equiv\;\Conid{P}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{wk}\;\Varid{,}\;\Varid{vz}\;\Varid{âˆ¶[}\;\Conid{ğ”¹[]â‚‚}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}}\;[\kern-1.5pt\;\Varid{idS}\;\Varid{,}\;\Varid{b}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;\Varid{âˆ¶[}\;\Varid{pbâ‚‚}\;\mskip1.5mu]\;\kern-1.5pt]_{\text{T}})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;(\Varid{elimğ”¹}\;{}\<[15]%
\>[15]{}\Conid{P}\;\Varid{t}\;\Varid{pt}\;\Varid{u}\;\Varid{pu}\;\Varid{b}\;\Varid{pb})\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\mathop\equiv\;\Varid{elimğ”¹}\;(\Conid{P}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘ğ”¹}\;\kern-1.5pt]_{\text{T}})\;{}\<[34]%
\>[34]{}(\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\Varid{ptâ‚‚}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\Varid{puâ‚‚}\;{}\<[E]%
\\
\>[34]{}(\Varid{b}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\Varid{pbâ‚‚}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tyOf}\;(\Varid{elimğ”¹[]}\;\Conid{P}\;\Varid{u}\;\Varid{t}\;\Varid{pu}\;\Varid{pt}\;\Varid{b}\;\Varid{pb}\;\Varid{ptâ‚‚}\;\Varid{puâ‚‚}\;\Varid{pbâ‚‚}\;\Varid{q}\;\Varid{i})\;\mathrel{=}\;\Varid{q}\;\Varid{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Note again that we also defer the coherence proof of \ensuremath{\Varid{tyOf}} for \ensuremath{\Varid{elimğ”¹[]}} by introducing another argument \ensuremath{\Varid{q}} in \ensuremath{\Varid{elimğ”¹}} which can be removed when defining its elimination rule.

\subsection{A Tarski universe} \label{sec:tt:univ}
Using the same idiom described previously, a Tarski universe of types is introduced to our type theory in the same vein.
First we need \ensuremath{\Conid{U}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“}} as the type of codes, and a type family \ensuremath{\Conid{El}} of elements for a given code (differences compared to the usual presentation highlighted):
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{U}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{U[]}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{U}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\;\mathop\equiv\;\Conid{U}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{El}\;{}\<[9]%
\>[9]{}\mathbin{:}\;(\Varid{u}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;\highlight{addition}{(\Varid{pu}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{u}\;\mathop\equiv\;\Conid{U})}\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{El[]}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\highlight{addition}{(\Varid{q}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}})\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;(\Conid{El}\;\Varid{u}\;\highlight{addition}{\Varid{pu}})\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{T}}\;\mathop\equiv\;\Conid{El}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ï„}\;\kern-1.5pt]_{\text{t}})\;\highlight{addition}{\Varid{q}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For the type \ensuremath{\Conid{ğ”¹}} of Boolean, its code \ensuremath{\Varid{ğ•“}} is introduced with a type equality \ensuremath{\Conid{Elğ•“}} such that the elements of \ensuremath{\Varid{ğ•“}} are exactly \ensuremath{\Conid{ğ”¹}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ğ•“}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ğ•“[]}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Varid{ğ•“}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;\mathop\equiv\;\Varid{ğ•“}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tyOf}\;\Varid{ğ•“}\;{}\<[17]%
\>[17]{}\mathrel{=}\;\Conid{U}{}\<[E]%
\\
\>[B]{}\Varid{tyOf}\;(\Varid{ğ•“[]}\;\Varid{Ïƒ}\;\Varid{i})\;{}\<[17]%
\>[17]{}\mathrel{=}\;\Conid{U[]}\;\{\mskip1.5mu \Varid{Ïƒ}\;\mathrel{=}\;\Varid{Ïƒ}\mskip1.5mu\}\;\Varid{i}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Elğ•“}\;\mathbin{:}\;\Conid{El}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\Varid{ğ•“}\;\Varid{refl}\;\mathop\equiv\;\Conid{ğ”¹}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For the \ensuremath{\Conid{Î }}-type, we again need a specialised substitution lifting.
This continues the pattern of introducing superfluous constructors to satisfy proof obligations (differences again highlighted).
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{El[]â‚‚}\;\mathbin{:}\;(\Varid{u}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î”})\;(\Varid{pu}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{u}\;\mathop\equiv\;\Conid{U})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\highlight{addition}{(\Varid{puâ‚‚}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\{\mskip1.5mu \Conid{Î“}\;\Varid{,}\;\Conid{El}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\highlight{addition}{\Varid{puâ‚‚}}\mskip1.5mu\}\;\Varid{idS})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathop\equiv\;\Conid{El}\;\Varid{u}\;\Varid{pu}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï€â‚}\;\Varid{idS}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{\char95 â†‘El}\;\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\{\mskip1.5mu \Varid{u}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î”}\mskip1.5mu\}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{pu}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{u}\;\mathop\equiv\;\Conid{U}\mskip1.5mu\}\;\highlight{addition}{\{\mskip1.5mu \Varid{pu'}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\mathop\equiv\;\Conid{U}\mskip1.5mu\}}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{â†’}\;\Conid{Sub}\;(\Conid{Î“}\;\Varid{,}\;\highlight{addition}{\Conid{El}\;(\Varid{u}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\Varid{pu'}})\;(\Conid{Î”}\;\Varid{,}\;\Conid{El}\;\Varid{u}\;\Varid{pu}){}\<[E]%
\\
\>[B]{}(\Varid{Ïƒ}\;\Varid{â†‘El})\;\{\mskip1.5mu \Varid{u}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{pu}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{pu'}\mskip1.5mu\}\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï€â‚}\;\Varid{idS}\;\Varid{,}\;\Varid{Ï€â‚‚}\;\Varid{idS}\;\Varid{âˆ¶[}\;\highlight{addition}{\Conid{El[]â‚‚}\;\Varid{u}\;\Varid{pu}\;\Varid{pu'}}\;\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Finally, we introduce the code \ensuremath{\Varid{Ï€}} for \ensuremath{\Conid{Î }} and the type equality \ensuremath{\Conid{ElÏ€}} to complete our definition of type theory using QIIRT:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ï€}\;{}\<[8]%
\>[8]{}\mathbin{:}\;{}\<[11]%
\>[11]{}(\Varid{a}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;\highlight{addition}{(\Varid{pa}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{a}\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[11]{}(\Varid{b}\;\mathbin{:}\;\Conid{Tm}\;(\Conid{Î“}\;\Varid{,}\;\Conid{El}\;\Varid{a}\;\Varid{pa}))\;\highlight{addition}{(\Varid{pb}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{b}\;\mathop\equiv\;\Conid{U})}\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ï€[]}\;{}\<[8]%
\>[8]{}\mathbin{:}\;{}\<[11]%
\>[11]{}(\Varid{a}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;{}\<[35]%
\>[35]{}\highlight{addition}{(\Varid{pa}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{a}\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[8]{}\Varid{â†’}\;{}\<[11]%
\>[11]{}(\Varid{b}\;\mathbin{:}\;\Conid{Tm}\;(\Conid{Î“}\;\Varid{,}\;\Conid{El}\;\Varid{a}\;\Varid{pa}))\;{}\<[35]%
\>[35]{}\highlight{addition}{(\Varid{pb}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{b}\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[8]{}\Varid{â†’}\;{}\<[11]%
\>[11]{}\highlight{addition}{(\Varid{pa'}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{a}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[8]{}\Varid{â†’}\;{}\<[11]%
\>[11]{}\highlight{addition}{(\Varid{pb'}\;\mathbin{:}\;\Varid{tyOf}\;(\Varid{b}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘El}\;\kern-1.5pt]_{\text{t}})\;{}\<[43]%
\>[43]{}\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[8]{}\Varid{â†’}\;{}\<[11]%
\>[11]{}(\Varid{Ï€}\;\Varid{a}\;\Varid{pa}\;\Varid{b}\;\Varid{pb})\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}\;{}\<[E]%
\\
\>[8]{}\mathop\equiv\;{}\<[11]%
\>[11]{}\Varid{Ï€}\;(\Varid{a}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;\highlight{addition}{\Varid{pa'}}\;(\Varid{b}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{â†‘El}\;\kern-1.5pt]_{\text{t}})\;\highlight{addition}{\Varid{pb'}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tyOf}\;(\Varid{Ï€}\;\anonymous \;\anonymous \;\anonymous \;\anonymous )\;\mathrel{=}\;\Conid{U}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\anonymous \;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ElÏ€}\;\mathbin{:}\;(\Varid{a}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;\highlight{addition}{(\Varid{pa}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{a}\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;(\Varid{b}\;\mathbin{:}\;\Conid{Tm}\;(\Conid{Î“}\;\Varid{,}\;\Conid{El}\;\Varid{a}\;\Varid{pa}))\;\highlight{addition}{(\Varid{pb}\;\mathbin{:}\;\Varid{tyOf}\;\Varid{b}\;\mathop\equiv\;\Conid{U})}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Conid{El}\;(\Varid{Ï€}\;\Varid{a}\;\Varid{pa}\;\Varid{b}\;\Varid{pb})\;\highlight{addition}{\Varid{refl}}\;\mathop\equiv\;\Conid{Î }\;(\Conid{El}\;\Varid{a}\;\Varid{pa})\;(\Conid{El}\;\Varid{b}\;\Varid{pb}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{tyOf}\;(\Varid{Ï€[]}\;\anonymous \;\anonymous \;\anonymous \;\anonymous \;\anonymous \;\anonymous \;\Varid{i})\;\mathrel{=}\;\Conid{U[]}\;\Varid{i}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the end, we emphasise that the introduction of superfluous equality proofs and constructors only makes sense because of set-truncation.
These additional arguments are essentially unique and thus do not add any new laws to type theory, but merely serve as devices to meet the syntactic restriction of strict positivity in the current implementation of \CA.

\subsection{Recursion and elimination principles} \label{sec:tt:elim}
We turn to recursion and elimination principles for our syntax.
Our QIIRT definition yields an \emph{initial model}.
This means that for any other model (algebra) of our theory, there is a unique structure-preserving map from our syntax to that model.
The recursion and elimination principles make this property concrete.
Here, we only discuss the part for substitution calculus, since other type formers are addressed similarly.
For the interested reader, see our formalisation.

The signature for an algebra is packed in a record type~\ensuremath{\Conid{SC}} (short for Substitution Calculus).
Inductive types and the function \ensuremath{\Varid{tyOf}} are interpreted as indexed types and a function between sets.
Constructors of our syntax, except superfluous ones, correspond to function fields in this record, including equality constructors and clauses of \ensuremath{\Varid{tyOf}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{record}\;\Conid{SC}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\Conid{Set}\;{}\<[19]%
\>[19]{}\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Ctx}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Ty}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Conid{Ctx}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Tm}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Conid{Ctx}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Sub}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Conid{Ctx}\;\Varid{â†’}\;\Conid{Ctx}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{tyOf}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Conid{Tm}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{âˆ…}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Conid{Ctx}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\_,^{\mathsf{C}}\_\;{}\<[13]%
\>[13]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Ctx}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\_[\_]_{\text{T}}\;{}\<[13]%
\>[13]{}\mathbin{:}\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î”})\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\_[\_]_{\text{t}}\;{}\<[13]%
\>[13]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î”})\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{idSâˆ˜\char95 }\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Varid{idS}\;\Varid{âˆ˜}\;\Varid{Ïƒ}\;\mathop\equiv\;\Varid{Ïƒ}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{Î²Ï€â‚‚}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Varid{Ï€â‚‚}\;(\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{p}\;\mskip1.5mu])\;\mathop\equiv\;\Varid{t}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{tyOf[]}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Varid{tyOf}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}})\;{}\<[36]%
\>[36]{}\mathop\equiv\;(\Varid{tyOf}\;\Varid{t})\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{tyOfÏ€â‚‚}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\{\mskip1.5mu \Conid{A}\;\mathrel{=}\;\Conid{A}\mskip1.5mu\}\;\Varid{Ïƒ})\;{}\<[36]%
\>[36]{}\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

To distinguish syntactic constructors from the semantic methods in \ensuremath{\Conid{SC}}, we qualify the syntactic constructors with `\ensuremath{\Conid{S.}}' in the following discussion.

Superfluous equality constructors, like \ensuremath{\Conid{S.tyOfÏ€â‚‚idS}}, are not required as fields in the record.
Instead, their semantic counterparts are defined within any given model using the other methods.
For example,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{tyOfÏ€â‚‚idS}\;\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”})\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î”})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\{\mskip1.5mu \Conid{A}\;\mathrel{=}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}\mskip1.5mu\}\;\Varid{idS})\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\Varid{âˆ˜}\;\Varid{Ï€â‚}\;\Varid{idS}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[3]{}\Varid{tyOfÏ€â‚‚idS}\;\Varid{Ïƒ}\;\Conid{A}\;\mathrel{=}\;\Varid{tyOfÏ€â‚‚}\;\Varid{idS}\;\Varid{âˆ™}\;[\circ]_{\text{T}}\;\anonymous \;\anonymous \;\anonymous {}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This simplifies the definition of models, as we only need to provide interpretations for the essential constructors.

The recursion principle consists of a family of functions that map syntax to their semantic counterparts:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{recCtx}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{S.Ctx}\;{}\<[23]%
\>[23]{}\Varid{â†’}\;\Conid{Ctx}{}\<[E]%
\\
\>[B]{}\Varid{recTy}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{S.Ty}\;\Conid{Î“}\;{}\<[23]%
\>[23]{}\Varid{â†’}\;\Conid{Ty}\;(\Varid{recCtx}\;\Conid{Î“}){}\<[E]%
\\
\>[B]{}\Varid{recTm}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{S.Tm}\;\Conid{Î“}\;{}\<[23]%
\>[23]{}\Varid{â†’}\;\Conid{Tm}\;(\Varid{recCtx}\;\Conid{Î“}){}\<[E]%
\\
\>[B]{}\Varid{recSub}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{S.Sub}\;\Conid{Î“}\;\Conid{Î”}\;{}\<[23]%
\>[23]{}\Varid{â†’}\;\Conid{Sub}\;(\Varid{recCtx}\;\Conid{Î“})\;(\Varid{recCtx}\;\Conid{Î”}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We also need a function that translates proofs about syntactic equalities into semantic equalities:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{recTyOf}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{S.tyOf}\;\Varid{t}\;\mathop\equiv\;\Conid{B}\;\Varid{â†’}\;\Varid{tyOf}\;(\Varid{recTm}\;\Varid{t})\;\mathop\equiv\;\Varid{recTy}\;\Conid{B}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The definition of these functions proceeds by pattern matching on the syntactic structure.
Each clause is an application of the corresponding method from the \ensuremath{\Conid{SC}} record:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{recCtx}\;\Conid{S.âˆ…}\;{}\<[27]%
\>[27]{}\mathrel{=}\;\Varid{âˆ…}{}\<[E]%
\\
\>[B]{}\Varid{recCtx}\;(\Conid{Î“}\;\Conid{S.,}\;\Conid{A})\;{}\<[27]%
\>[27]{}\mathrel{=}\;\Varid{recCtx}\;\Conid{Î“}\;\Varid{,}^{\mathsf{C}}\;\Varid{recTy}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\Varid{...}{}\<[E]%
\\
\>[B]{}\Varid{recSub}\;(\Varid{Ïƒ}\;\Conid{S.,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{pt}\;\mskip1.5mu])\;{}\<[27]%
\>[27]{}\mathrel{=}\;\Varid{recSub}\;\Varid{Ïƒ}\;\Varid{,}\;\Varid{recTm}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{recTyOf}\;\Varid{t}\;\Varid{pt}\;\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The most interesting case is perhaps \ensuremath{\Varid{recTyOf}}, which handles the translation of syntactic equations.
For a given syntactic equality proof \ensuremath{\Varid{p}\;\mathbin{:}\;\Conid{S.tyOf}\;\Varid{t}\;\mathop\equiv\;\Conid{B}}, we must construct a semantic equality proof.
This is done by applying \ensuremath{\Varid{recTy}} to both sides of the syntactic equality to get \ensuremath{\Varid{recTy}\;(\Conid{S.tyOf}\;\Varid{t})\;\mathop\equiv\;\Varid{recTy}\;\Conid{B}}, and then using the semantic counterpart of the \ensuremath{\Varid{tyOf}} clause to derive \ensuremath{\Varid{tyOf}\;(\Varid{recTm}\;\Varid{t})\;\mathop\equiv\;\Varid{recTy}\;(\Conid{S.tyOf}\;\Varid{t})}.
Taking \ensuremath{\Conid{S.Ï€â‚‚}} as an example, we have:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{recTyOf}\;\{\mskip1.5mu \Conid{B}\;\mathrel{=}\;\Conid{B}\mskip1.5mu\}\;(\Conid{S.Ï€â‚‚}\;\{\mskip1.5mu \Conid{A}\;\mathrel{=}\;\Conid{A}\mskip1.5mu\}\;\Varid{Ïƒ})\;\Varid{p}\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{tyOf}\;(\Varid{recTm}\;(\Conid{S.Ï€â‚‚}\;\Varid{Ïƒ}))\;{}\<[33]%
\>[33]{}\Varid{â‰¡âŸ¨âŸ©}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;(\Varid{recSub}\;\Varid{Ïƒ}))\;{}\<[33]%
\>[33]{}\Varid{â‰¡âŸ¨}\;\Varid{tyOfÏ€â‚‚}\;(\Varid{recSub}\;\Varid{Ïƒ})\;\Varid{âŸ©}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Varid{recTy}\;\Conid{A})\;[\kern-1.5pt\;\Varid{Ï€â‚}\;(\Varid{recSub}\;\Varid{Ïƒ})\;\kern-1.5pt]_{\text{T}}\;{}\<[33]%
\>[33]{}\Varid{â‰¡âŸ¨âŸ©}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{recTy}\;(\Conid{A}\;\Conid{S.[}\;\Conid{S.Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}})\;{}\<[33]%
\>[33]{}\Varid{â‰¡âŸ¨âŸ©}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{recTy}\;(\Conid{S.tyOf}\;(\Conid{S.Ï€â‚‚}\;\Varid{Ïƒ}))\;{}\<[33]%
\>[33]{}\Varid{â‰¡âŸ¨}\;\Varid{cong}\;\Varid{recTy}\;\Varid{p}\;\Varid{âŸ©}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{recTy}\;\Conid{B}\;{}\<[33]%
\>[33]{}\Varid{âˆ}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The coherence conditions for \ensuremath{\Varid{recTyOf}} over equality constructors are trivial because of set-truncation.

For the elimination principle, we consider the notion of displayed algebras over an \ensuremath{\Conid{SC}}-algebra \ensuremath{\Conid{M}}, as a record type \ensuremath{\mathsf{SC}^{\bullet}} parametric in \ensuremath{\Conid{M}}, and later instantiate \ensuremath{\Conid{M}} to the term algebra, i.e.\ the syntax.
Carriers of a displayed algebra as well as the semantics of \ensuremath{\Varid{tyOf}} are given below.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{record}\;\mathsf{SC}^{\bullet}\;(\Conid{M}\;\mathbin{:}\;\Conid{SC})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{open}\;\Conid{SC}\;\Conid{M}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathsf{Ctx}^{\bullet}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\Conid{Ctx}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathsf{Ty}^{\bullet}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\mathsf{Ctx}^{\bullet}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathsf{Tm}^{\bullet}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\mathsf{Ctx}^{\bullet}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Tm}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathsf{Sub}^{\bullet}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\mathsf{Ctx}^{\bullet}\;\Conid{Î“}\;\Varid{â†’}\;\mathsf{Ctx}^{\bullet}\;\Conid{Î”}\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{Î”}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathsf{tyOf}^{\bullet}\;{}\<[12]%
\>[12]{}\mathbin{:}\;\mathsf{Tm}^{\bullet}\;{}\<[19]%
\>[19]{}\Conid{Î“}^{\bullet}\;\Varid{t}\;\Varid{â†’}\;\mathsf{Ty}^{\bullet}\;\Conid{Î“}^{\bullet}\;(\Varid{tyOf}\;\Varid{t}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
As motives are indexed by their underlying model, we will have equations over equations of the underlying model.
It is convenient to specialise dependent paths for them, e.g.,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{\char95 â‰¡Tm[\char95 ]\char95 }\;\mathbin{:}\;\mathsf{Tm}^{\bullet}\;\Conid{Î“}^{\bullet}\;\Varid{t}\;\Varid{â†’}\;\Varid{t}\;\mathop\equiv\;\Varid{u}\;\Varid{â†’}\;\mathsf{Tm}^{\bullet}\;\Conid{Î“}^{\bullet}\;\Varid{u}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\Varid{\char95 â‰¡Tm[\char95 ]\char95 }\;\{\mskip1.5mu \Conid{Î“}^{\bullet}\;\mathrel{=}\;\Conid{Î“}^{\bullet}\mskip1.5mu\}\;\Varid{t}^{\bullet}\;\Varid{e}\;\Varid{u}^{\bullet}\;\mathrel{=}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{PathP}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\mathsf{Tm}^{\bullet}\;\Conid{Î“}^{\bullet}\;\highlight{addition}{(\Varid{e}\;\Varid{i})})\;\Varid{t}^{\bullet}\;\Varid{u}^{\bullet}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The signature for \ensuremath{\mathsf{SC}^{\bullet}}-algebras is similar to the one for \ensuremath{\Conid{SC}}-algebras.
The difference here is that each displayed operation is indexed by their underlying operation and thus equations become equations over equations.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{53}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{âˆ…}^{\bullet}\;{}\<[14]%
\>[14]{}\mathbin{:}\;\mathsf{Ctx}^{\bullet}\;\Varid{âˆ…}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\_,^{\bullet}\_\;{}\<[14]%
\>[14]{}\mathbin{:}\;\mathsf{Ctx}^{\bullet}\;\Conid{Î“}\;\Varid{â†’}\;\mathsf{Ty}^{\bullet}\;\Conid{Î“}^{\bullet}\;\Conid{A}\;\Varid{â†’}\;\mathsf{Ctx}^{\bullet}\;(\Conid{Î“}\;\Varid{,}^{\mathsf{C}}\;\Conid{A}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\_[\_]^{\bullet}_{\text{T}}\;{}\<[14]%
\>[14]{}\mathbin{:}\;\mathsf{Ty}^{\bullet}\;\Conid{Î”}^{\bullet}\;\Conid{A}\;\Varid{â†’}\;\mathsf{Sub}^{\bullet}\;\Conid{Î“}^{\bullet}\;\Conid{Î”}^{\bullet}\;\Varid{Ïƒ}\;\Varid{â†’}\;\mathsf{Ty}^{\bullet}\;\Conid{Î“}^{\bullet}\;(\Conid{A}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\_[\_]^{\bullet}_{\text{t}}\;{}\<[14]%
\>[14]{}\mathbin{:}\;\mathsf{Tm}^{\bullet}\;\Conid{Î”}^{\bullet}\;\Varid{t}\;\Varid{â†’}\;\mathsf{Sub}^{\bullet}\;\Conid{Î“}^{\bullet}\;\Conid{Î”}^{\bullet}\;\Varid{Ïƒ}\;\Varid{â†’}\;\mathsf{Tm}^{\bullet}\;\Conid{Î“}^{\bullet}\;(\Varid{t}\;[\kern-1.5pt\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{t}}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{tyOf[]}^{\bullet}\;{}\<[14]%
\>[14]{}\mathbin{:}\;\mathsf{tyOf}^{\bullet}\;{}\<[23]%
\>[23]{}(\Varid{t}^{\bullet}\;[\kern-1.5pt\;\Varid{Ïƒ}^{\bullet}\;\kern-1.5pt]^{\bullet}_{\text{t}})\;\Varid{â‰¡Ty[}\;\Varid{tyOf[]}\;\mskip1.5mu]\;(\mathsf{tyOf}^{\bullet}\;\Varid{t}^{\bullet}\;[\kern-1.5pt\;\Varid{Ïƒ}^{\bullet}\;\kern-1.5pt]^{\bullet}_{\text{T}}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}[\mathsf{idS}]_{\text{t}}^{\bullet}\;{}\<[14]%
\>[14]{}\mathbin{:}\;\Varid{t}^{\bullet}\;{}\<[38]%
\>[38]{}\Varid{â‰¡Tm[}\;[\mathsf{idS}]_{\text{t}}\;\mskip1.5mu]\;{}\<[53]%
\>[53]{}\Varid{t}^{\bullet}\;[\kern-1.5pt\;\Varid{idS}^{\bullet}\;\kern-1.5pt]^{\bullet}_{\text{t}}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}[\circ]_{\text{t}}^{\bullet}\;{}\<[14]%
\>[14]{}\mathbin{:}\;\Varid{t}^{\bullet}\;[\kern-1.5pt\;\Varid{Ï„}^{\bullet}\;\kern-1.5pt]^{\bullet}_{\text{t}}\;[\kern-1.5pt\;\Varid{Ïƒ}^{\bullet}\;\kern-1.5pt]^{\bullet}_{\text{t}}\;{}\<[38]%
\>[38]{}\Varid{â‰¡Tm[}\;[\circ]_{\text{t}}\;\mskip1.5mu]\;{}\<[53]%
\>[53]{}\Varid{t}^{\bullet}\;[\kern-1.5pt\;\Varid{Ï„}^{\bullet}\;\Varid{âˆ˜}^{\bullet}\;\Varid{Ïƒ}^{\bullet}\;\kern-1.5pt]^{\bullet}_{\text{t}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Note that if \ensuremath{[\mathsf{idS}]_{\text{t}}} in its QIIT definition is formulated with a dependent path, the equality proof in the middle of \ensuremath{\Varid{\char95 â‰¡Tm[\char95 ]\char95 }} has to be a dependent path.
As a result, we would have to specify two underlying equations as
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{t}^{\bullet}\;\Varid{â‰¡Tm[}\;\highlight{addition}{[\mathsf{idS}]_{\text{T}}}\;\Varid{][}\;\highlight{addition}{[\mathsf{idS}]_{\text{t}}}\;\mskip1.5mu]\;\Varid{t}^{\bullet}\;[\kern-1.5pt\;\Varid{idS}^{\bullet}\;\kern-1.5pt]^{\bullet}_{\text{t}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
and equational reasoning with them would involve three equations altogether.
It is nice that we do not have to deal with this extra proof obligation in our formulation.

The elimination principle is stated similarly to the recursion principle but indexed over the term algebra~(\Cref{sec:meta:term}),
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{elimCtx}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;{}\<[19]%
\>[19]{}\Conid{S.Ctx})\;{}\<[31]%
\>[31]{}\Varid{â†’}\;\mathsf{Ctx}^{\bullet}\;\Conid{Î“}{}\<[E]%
\\
\>[B]{}\Varid{elimTy}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{A}\;\mathbin{:}\;{}\<[19]%
\>[19]{}\Conid{S.Ty}\;\Conid{Î“})\;{}\<[31]%
\>[31]{}\Varid{â†’}\;\mathsf{Ty}^{\bullet}\;(\Varid{elimCtx}\;\Conid{Î“})\;\Conid{A}{}\<[E]%
\\
\>[B]{}\Varid{elimTm}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;{}\<[19]%
\>[19]{}\Conid{S.Tm}\;\Conid{Î“})\;{}\<[31]%
\>[31]{}\Varid{â†’}\;\mathsf{Tm}^{\bullet}\;(\Varid{elimCtx}\;\Conid{Î“})\;\Varid{t}{}\<[E]%
\\
\>[B]{}\Varid{elimSub}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{Ïƒ}\;\mathbin{:}\;{}\<[19]%
\>[19]{}\Conid{S.Sub}\;\Conid{Î“}\;\Conid{Î”})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{â†’}\;\mathsf{Sub}^{\bullet}\;(\Varid{elimCtx}\;\Conid{Î“})\;(\Varid{elimCtx}\;\Conid{Î”})\;\Varid{Ïƒ}{}\<[E]%
\\
\>[B]{}\Varid{elimTyOf}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;{}\<[19]%
\>[19]{}\Conid{S.Tm}\;\Conid{Î“})\;(\Varid{p}\;\mathbin{:}\;\Conid{S.tyOf}\;\Varid{t}\;\mathop\equiv\;\Conid{A})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{â†’}\;{}\<[6]%
\>[6]{}\mathsf{tyOf}^{\bullet}\;(\Varid{elimTm}\;\Varid{t})\;\Varid{â‰¡Ty[}\;\Varid{p}\;\mskip1.5mu]\;\Varid{elimTy}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For the coherence conditions in the definition of the eliminators, we may need additional reasoning steps instead of just using the semantics equation, so we use transitivity of dependent paths:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\_\Varid{âˆ™}_{\mathsf{P}}\_\;\mathbin{:}\;{}\<[9]%
\>[9]{}\{\mskip1.5mu \Varid{x'}\;\mathbin{:}\;\Conid{B}\;\Varid{x}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{y'}\;\mathbin{:}\;\Conid{B}\;\Varid{y}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{z'}\;\mathbin{:}\;\Conid{B}\;\Varid{z}\mskip1.5mu\}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{â†’}\;\{\mskip1.5mu \Varid{p}\;\mathbin{:}\;\Varid{x}\;\mathop\equiv\;\Varid{y}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{q}\;\mathbin{:}\;\Varid{y}\;\mathop\equiv\;\Varid{z}\mskip1.5mu\}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{â†’}\;\Conid{PathP}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\Conid{B}\;(\Varid{p}\;\Varid{i}))\;\Varid{x'}\;\Varid{y'}\;\Varid{â†’}\;\Conid{PathP}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\Conid{B}\;(\Varid{q}\;\Varid{i}))\;\Varid{y'}\;\Varid{z'}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{â†’}\;\Conid{PathP}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\Conid{B}\;(\highlight{addition}{(\Varid{p}\;\Varid{âˆ™}\;\Varid{q})}\;\Varid{i}))\;\Varid{x'}\;\Varid{z'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We also use set-truncation to identify the highlighted \ensuremath{\Varid{p}\;\Varid{âˆ™}\;\Varid{q}} with the desired underlying equation in special-purpose equational reasoning combinators such as the following:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{beginSub[\char95 ]\char95 }\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbin{:}\;(\{\mskip1.5mu \Varid{p}\mskip1.5mu\}\;\Varid{q}\;\mathbin{:}\;\Varid{Ïƒ}\;\mathop\equiv\;\Varid{Ï„})\;\Varid{â†’}\;\Varid{Ïƒ}^{\bullet}\;\Varid{â‰¡Sub[}\;\Varid{p}\;\mskip1.5mu]\;\Varid{Ï„}^{\bullet}\;\Varid{â†’}\;\Varid{Ïƒ}^{\bullet}\;\Varid{â‰¡Sub[}\;\Varid{q}\;\mskip1.5mu]\;\Varid{Ï„}^{\bullet}{}\<[E]%
\\
\>[3]{}\Varid{beginSub[\char95 ]\char95 }\;\{\mskip1.5mu \Varid{Ïƒ}^{\bullet}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{Ï„}^{\bullet}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{p}\mskip1.5mu\}\;\Varid{q}\;\Varid{p}^{\bullet}\;\mathrel{=}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{subst}\;(\Varid{Î»}\;\Varid{r}\;\Varid{â†’}\;\Varid{Ïƒ}^{\bullet}\;\Varid{â‰¡Sub[}\;\Varid{r}\;\mskip1.5mu]\;\Varid{Ï„}^{\bullet})\;(\Conid{Sub-is-set}\;\Varid{p}\;\Varid{q})\;\Varid{p}^{\bullet}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

For example, the coherence proof for \ensuremath{\Varid{Î·Ï€}} is given by
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{71}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{beginSub[}\;\Varid{Î·Ï€}\;\mskip1.5mu]\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{elimSub}\;\Varid{Ïƒ}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â‰¡Sub[}\;\Varid{Î·Ï€}\;\Varid{]âŸ¨}\;\Varid{Î·Ï€âˆ™}\;(\Varid{elimSub}\;\Varid{Ïƒ})\;\Varid{âŸ©}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ï€â‚}^{\bullet}\;(\Varid{elimSub}\;\Varid{Ïƒ})\;\Varid{,}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ï€â‚‚}^{\bullet}\;(\Varid{elimSub}\;\Varid{Ïƒ})\;\Varid{âˆ¶[}\;\Varid{refl}\;\Varid{,}\;\Varid{tyOfÏ€â‚‚}^{\bullet}\;(\Varid{elimSub}\;\Varid{Ïƒ})\;\kern-1.5pt]^{\bullet}_{\text{t}}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â‰¡Sub[}\;\Varid{refl}\;\Varid{]âŸ¨}\;\Varid{cong}\;(\Varid{Î»}\;\Varid{z}\;\Varid{â†’}\;\Varid{...}\;\Varid{,}\;\Varid{...}\;\Varid{âˆ¶[}\;\Varid{refl}\;\Varid{,}\;\Varid{z}\;\kern-1.5pt]^{\bullet}_{\text{t}})\;(\Conid{Tyâˆ™-is-set}\;{}\<[71]%
\>[71]{}\anonymous \;\anonymous )\;\Varid{âŸ©}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{Ï€â‚}^{\bullet}\;(\Varid{elimSub}\;\Varid{Ïƒ})\;\Varid{,}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{elimTm}\;(\Varid{Ï€â‚‚}\;\Varid{Ïƒ})\;\Varid{âˆ¶[}\;\Varid{refl}\;\Varid{,}\;\Varid{elimTyOf}\;(\Varid{Ï€â‚‚}\;\Varid{Ïƒ})\;\Varid{refl}\;\kern-1.5pt]^{\bullet}_{\text{t}}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{âˆ}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
with the steps \ensuremath{\Varid{Ïƒ}^{\bullet}\;\Varid{â‰¡Sub[}\;\Varid{p}\;\Varid{]âŸ¨}\;\Varid{p}^{\bullet}\;\Varid{âŸ©}\;\Varid{Ï„}^{\bullet}} implemented using \ensuremath{\_\Varid{âˆ™}_{\mathsf{P}}\_}.
These steps give us an equation over \ensuremath{\Varid{Î·Ï€}\;\Varid{âˆ™}\;(\Varid{refl}\;\Varid{âˆ™}\;\Varid{refl})}, and \ensuremath{\Varid{beginSub[}\;\Varid{Î·Ï€}\;\Varid{]\char95 }} gives us an easy way to correct this to an equation over \ensuremath{\Varid{Î·Ï€}} as desired instead.

\FNF{Comment on the trick of including extra fields in the record type of models}

\subsection{Practical workarounds for mutual definitions}  \label{sec:tt:mutual}

So far, we have outlined how the recursion and elimination principles should be defined \emph{ideally}.
In practice, however, limitations (and occasional mysterious bugs) of the proof assistant require us to adopt certain workarounds in order to implement the intended definitions.
%This shows that the current design of \CA is not yet fully aligned with the theory of quotient inductive-inductive types~\cite{Kaposi2019}.

\paragraph{Mutually interleaved QIITs}
Constructors of QIITs currently can not be interleaved in \CA~\cite{Agdaissue2021}, even within an \ensuremath{\Keyword{interleaved}\;\Keyword{mutual}} block.
The reason is that such a block is desugared into a collection of forward declarations for the \ensuremath{\Keyword{data}} types, rather than for the constructors.
In principle, all constructors belonging to the same family of QIITs should be declared within the same context~\cite{Kaposi2019}.
However, due to this desugaring, equality constructors may end up depending on other constructors that are not yet in scope.

We work around this issue as follows:
\begin{enumerate*}[label=(\roman*)]
  \item we make forward declarations for the \emph{entire definition} of the QIITs, including the constructors;
  \item we introduce each constructor but only refer to forward declarations when referring to other constructors;
  \item we define the forward declarations by their corresponding constructors;
  \item finally, we expose only the actual constructors, omitting the forward declarations.
\end{enumerate*}
The following snippet illustrates this approach:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{module}\;\Conid{S}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{data}\;\Conid{Ctx}\;{}\<[13]%
\>[13]{}\mathbin{:}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{âˆ…}\;{}\<[8]%
\>[8]{}\mathbin{:}\;\Conid{Ctx}\mbox{\onelinecomment  note indentation, not a constructor!}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ,\char95 }\;{}\<[8]%
\>[8]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Ctx}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{data}\;\Conid{Ctx}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{âˆ…'}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Conid{Ctx}\mbox{\onelinecomment  this is a constructor}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{\char95 ,'\char95 }\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;(\Conid{A}\;\mathbin{:}\;\Conid{Ty}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Ctx}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{âˆ…}\;{}\<[11]%
\>[11]{}\mathrel{=}\;\Varid{âˆ…'}\mbox{\onelinecomment  make definition for forward declarations}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{\char95 ,\char95 }\;{}\<[11]%
\>[11]{}\mathrel{=}\;\Varid{\char95 ,'\char95 }{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{...}{}\<[E]%
\\
\>[B]{}\Keyword{open}\;\Conid{S}\;\Keyword{public}\;\mbox{\onelinecomment  expose actual constructors}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{hiding}\;(\Varid{âˆ…};\Varid{\char95 ,\char95 };\Varid{...}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{renaming}\;(\Varid{âˆ…'}\;\Varid{to}\;\Varid{âˆ…};\Varid{\char95 ,'\char95 }\;\Varid{to}\;\Varid{\char95 ,\char95 };\Varid{...}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This translation from QIITs in theory to their actual definitions in \CA should be sufficient to define mutually interleaved QIITs.
Indeed, pedagogical presentations of type theory typically introduces one type former at a time, together with its formation, introduction, elimination, and equality rules (see, e.g.~\cite{Hofmann1997}), rather than presenting all type formers at once using a few large monolithic sets of rules.

\paragraph{Mutual interleaved QIIRTs}
Interleaving function clauses with inductive types is a different matter, since we cannot forward declare a function clause together with its computational behaviour.\footnote{Custom rewrite rules are not allowed in \CA.}
However, because we have `Forded' the typing constraints into equality proofs, what we actually need at the point of introducing constructors is only the existence of such an equality proof, not its computational content.

Our workaround is therefore as follows:
\begin{enumerate*}[label=(\roman*)]
  \item we declare the existence of the required equality proof before it is used,
  \item we define \ensuremath{\Varid{tyOf}} only after all datatype declarations have been given, and
  \item we provide the actual definition corresponding to the forward declaration.
\end{enumerate*}
For instance, the equality constructor \ensuremath{\Varid{Î·Ï€}} asks for a proof of \ensuremath{\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\Varid{Ïƒ})\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}}.
In this case, we simply forward declare such a proof:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tyOfÏ€â‚‚}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Varid{tyOf}\;(\Varid{Ï€â‚‚}\;\Varid{Ïƒ})\;\mathop\equiv\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[B]{}\Varid{Î·Ï€}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Varid{Ïƒ}\;\mathop\equiv\;(\Varid{Ï€â‚}\;\Varid{Ïƒ}\;\Varid{,}\;\Varid{Ï€â‚‚}\;\Varid{Ïƒ}\;\Varid{âˆ¶[}\;\Varid{tyOfÏ€â‚‚}\;\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Then, once \ensuremath{\Varid{tyOf}} has been defined, we simply set \ensuremath{\Varid{tyOfÏ€â‚‚}} to \ensuremath{\Varid{refl}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tyOf}\;(\Varid{Ï€â‚‚'}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{Î”}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{Ïƒ}\mskip1.5mu\})\;\mathrel{=}\;\Conid{A}\;[\kern-1.5pt\;\Varid{Ï€â‚}\;\{\mskip1.5mu \Conid{A}\;\mathrel{=}\;\Conid{A}\mskip1.5mu\}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}{}\<[E]%
\\
\>[B]{}\Varid{...}{}\<[E]%
\\
\>[B]{}\Varid{tyOfÏ€â‚‚}\;\mathrel{=}\;\Varid{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This translation is valid as long as the computational behaviour of the interleaved function clauses is not needed up to judgemental equality.

\paragraph{Mutually-defined functions}
%\LT[noinline]{(Low) Create an Agda issue?}
Since the constructors of QII(R)Ts can be mutually interleaved, their recursion and elimination principles also need to be given in the same vein.
However, \Agda does not allow us to interleave clauses of different functions directly.
One workaround is to use forward declarations as a lifting of the entire clause and then perform the necessary coercions along the corresponding equality proofs by hand.

Another possibility is to define a single family of functions indexed by tags.
For instance, the recursion principle can be implemented by introducing a datatype \ensuremath{\Conid{Tag}} with one constructor for each motive:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{Tag}\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ctx}\;\Varid{ty}\;\Varid{sub}\;\Varid{tm}\;\Varid{tyof}\;\mathbin{:}\;\Conid{Tag}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Then, we define the recursion principle uniformly as \ensuremath{\Varid{rec}}, with \ensuremath{\Varid{tyOfRec}} computing its type.
Each actual function is introduced as a synonym for \ensuremath{\Varid{rec}} at the appropriate tag:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tyOfRec}\;\mathbin{:}\;\Conid{Tag}\;{}\<[18]%
\>[18]{}\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Varid{rec}\;\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tag})\;{}\<[18]%
\>[18]{}\Varid{â†’}\;\Varid{tyOfRec}\;\Varid{t}{}\<[E]%
\\
\>[B]{}\Varid{tyOfRec}\;\Varid{ctx}\;{}\<[15]%
\>[15]{}\mathrel{=}\;\Conid{S.Ctx}\;\Varid{â†’}\;\Conid{Ctx}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{rec}\;\Varid{ctx}\;\Conid{S.âˆ…}\;{}\<[26]%
\>[26]{}\mathrel{=}\;\Varid{âˆ…}{}\<[E]%
\\
\>[B]{}\Varid{rec}\;\Varid{ctx}\;(\Conid{Î“}\;\Conid{S.,}\;\Conid{A})\;{}\<[26]%
\>[26]{}\mathrel{=}\;\Varid{rec}\;\Varid{ctx}\;\Conid{Î“}\;\Varid{,}^{\mathsf{C}}\;\Varid{rec}\;\Varid{ty}\;\Conid{A}{}\<[E]%
\\
\>[B]{}\Varid{...}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{recCtx}\;{}\<[10]%
\>[10]{}\mathrel{=}\;\Varid{rec}\;\Varid{ctx}{}\<[E]%
\\
\>[B]{}\Varid{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

At the time of writing, however, this encoding cannot be fully carried out in \CA: some terms that should be strictly equal are not recognised as such during type checking.
For example, in the following clause of \ensuremath{\Varid{rec}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rec}\;\Varid{sub}\;(\Conid{S.\char95 ,\char95 âˆ¶[\char95 ]}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{Î”}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mskip1.5mu\}\;\Varid{Ïƒ}\;\Varid{t}\;\Varid{p})\;\mathrel{=}\;\Varid{\char95 ,\char95 âˆ¶[\char95 ]}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{rec}\;\Varid{ctx}\;\Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{rec}\;\Varid{ctx}\;\Conid{Î”}\mskip1.5mu\}\;\{\mskip1.5mu \Varid{rec}\;\Varid{ty}\;\Conid{A}\mskip1.5mu\}\;(\Varid{rec}\;\Varid{sub}\;\Varid{Ïƒ})\;(\Varid{rec}\;\Varid{tm}\;\Varid{t})\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\highlight{addition}{\{\mskip1.5mu \mathbin{!}\;\Varid{rec}\;\Varid{tyof}\;\Varid{t}\;\Varid{p}\;\mathbin{!}\mskip1.5mu\}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
the subterm in the hole is accepted by \Agda, but refining it results an error, as the terms \ensuremath{\Varid{rec}\;\Varid{ty}\;(\Conid{A}\;\Conid{S.[}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}})} and \ensuremath{\Varid{rec}\;\Varid{ty}\;\Conid{A}\;[\kern-1.5pt\;\Varid{rec}\;\Varid{sub}\;\Varid{Ïƒ}\;\kern-1.5pt]_{\text{T}}} are not recognised as equal --- even though the former was already defined to be the latter.

In our formalisation, we fall back on forward declarations alone with coercions.
We are still investigating the root cause of this behaviour, but it may point to a design flaw.

\LT[inline]{TERMINATION checker? (R1, R3)}

\section{Metatheory}\label{sec:meta}
Having defined type theory as QIIRTs, we now turn to models of type theory as well as constructions of new models from existing ones.

%We find that reasoning with this definition \emph{per se} in \CA is hard even with substitution calculus: the lack of strict equalities in type theory is known to cause the transport hell~\cite{Altenkirch2016a} and even worse it cannot be mitigated by using custom rewriting rules~\cite{Cockx2020,Cockx2021} in \CA.
%Nevertheless, programming with type theory seems doable, as normalisation can be

\subsection{Term model} \label{sec:meta:term}
The term model is a self-interpretation of syntax, allowing displayed models to be instantiated over it and ensuring that the elimination rule computes.
The definition is routine: each field is interpreted by the corresponding constructor, except that additional equality constraints (such as the one in \ensuremath{\Varid{Î²Ï€â‚‚}} highlighted below) are replaced by actual proofs:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Term}\;\mathbin{:}\;\Conid{SC}{}\<[E]%
\\
\>[B]{}\Conid{Term}\;\mathrel{=}\;\Keyword{record}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\{\mskip1.5mu \Varid{âˆ…}\;{}\<[13]%
\>[13]{}\mathrel{=}\;\Conid{S.âˆ…}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{};\Varid{tyOf[]}\;{}\<[13]%
\>[13]{}\mathrel{=}\;\Varid{refl}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{...}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{};\Varid{Î²Ï€â‚‚}\;{}\<[13]%
\>[13]{}\mathrel{=}\;\Varid{Î»}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{Î”}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mskip1.5mu\}\;\Varid{Ïƒ}\;\Varid{t}\;\Varid{p}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{â†’}\;\Conid{S.Î²Ï€â‚‚}\;\Varid{Ïƒ}\;\Varid{t}\;\Varid{p}\;\highlight{addition}{(\Varid{cong}\;(\Conid{A}\;\Varid{[\char95 ]T})\;(\Conid{S.Î²Ï€â‚}\;\Varid{Ïƒ}\;\Varid{t}\;\Varid{p})\;\Varid{âˆ™}\;\Varid{sym}\;\Varid{p})}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Other type formers are given similarly.
The recursion and elimination principles justify that the term model is indeed the initial model.

\subsection{Standard model} \label{sec:standard-model}

In the standard model, contexts are interpreted as sets in \CA, types as sets indexed by a context~\ensuremath{\Conid{Î“}}, substitutions as functions between these sets, and terms as \emph{pairs} \ensuremath{(\Conid{A,}\;\Varid{t})} consisting of an interpreted type \ensuremath{\Conid{A}\;\mathbin{:}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Set}} together with a dependent function \ensuremath{\Varid{t}\;\mathbin{:}\;(\Varid{Î³}\;\mathbin{:}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{A}\;\Varid{Î³}}.
The interpretation of \ensuremath{\Varid{tyOf}} is simply the first component \ensuremath{\Conid{A}}.
In other words, terms are interpreted as a type \ensuremath{\Conid{A}}, together with a `section' \ensuremath{\Varid{t}\;\mathbin{:}\;(\Varid{Î³}\;\mathbin{:}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{A}\;\Varid{Î³}} of that type, as usual:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{std}\;\mathbin{:}\;\Conid{SC}{}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.Ctx}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.Ty}\;{}\<[12]%
\>[12]{}\Conid{Î“}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.Sub}\;\Conid{Î“}\;\Conid{Î”}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Î”}{}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.Tm}\;{}\<[12]%
\>[12]{}\Conid{Î“}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{Î£[}\;\Conid{A}\;\Varid{âˆˆ}\;(\Conid{Î“}\;\Varid{â†’}\;\Conid{Set})\;\mskip1.5mu]\;((\Varid{Î³}\;\mathbin{:}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{A}\;\Varid{Î³}){}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.tyOf}\;(\Conid{A}\;\Varid{,}\;\Varid{t})\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{A}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The main construction of the model is the same as in the standard model of type theory using QIITs~\cite[Section~4]{Altenkirch2017}, except that the typing constraint \ensuremath{\Varid{p}} in \ensuremath{\Varid{Ïƒ}\;\Varid{,}\;\Varid{t}\;\Varid{âˆ¶[}\;\Varid{p}\;\mskip1.5mu]} is `Forded'.
As a result, the value \ensuremath{\Varid{t}\;\Varid{Î³}} below must be transported along \ensuremath{\Varid{p}}, as highlighted below:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{std}\;\Varid{.âˆ…}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{Unit}{}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.\char95 ,C\char95 }\;\Conid{Î“}\;\Conid{A}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{Î£}\;\Conid{Î“}\;\Conid{A}{}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.\char95 [\char95 ]T}\;\Conid{A}\;\Varid{Ïƒ}\;\Varid{Î³}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{A}\;(\Varid{Ïƒ}\;\Varid{Î³}){}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.\char95 [\char95 ]t}\;(\Conid{A}\;\Varid{,}\;\Varid{t})\;\Varid{Ïƒ}\;{}\<[25]%
\>[25]{}\mathrel{=}\;(\Varid{Î»}\;\Varid{Î³}\;\Varid{â†’}\;\Conid{A}\;(\Varid{Ïƒ}\;\Varid{Î³}))\;\Varid{,}\;(\Varid{Î»}\;\Varid{Î³}\;\Varid{â†’}\;\Varid{t}\;(\Varid{Ïƒ}\;\Varid{Î³})){}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.tyOf[]}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Varid{refl}{}\<[E]%
\\
\>[3]{}\Varid{...}{}\<[E]%
\\
\>[3]{}\Varid{std}\;\Varid{.\char95 ,\char95 âˆ¶[\char95 ]}\;\Varid{Ïƒ}\;(\Conid{A}\;\Varid{,}\;\Varid{t})\;\Varid{p}\;\Varid{Î³}\;\mathrel{=}\;(\Varid{Ïƒ}\;\Varid{Î³}\;\Varid{,}\;\highlight{addition}{\Varid{transport}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\Varid{p}\;\Varid{i}\;\Varid{Î³})\;(\Varid{t}\;\Varid{Î³})}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

To extend the standard model for the universe \ensuremath{\Conid{U}}, we define a Tarski universe of codes and its interpretation
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{data}\;\Conid{UU}\;\mathbin{:}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{T}\;\mathbin{:}\;\Conid{UU}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Keyword{data}\;\Conid{UU}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{bool}\;\mathbin{:}\;\Conid{UU}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{pi}\;\mathbin{:}\;(\Varid{a}\;\mathbin{:}\;\Conid{UU})\;\Varid{â†’}\;(\Conid{T}\;\Varid{a}\;\Varid{â†’}\;\Conid{UU})\;\Varid{â†’}\;\Conid{UU}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Conid{T}\;\mathbin{:}\;\Conid{UU}\;\Varid{â†’}\;\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{T}\;\Varid{bool}\;{}\<[13]%
\>[13]{}\mathrel{=}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\Conid{T}\;(\Varid{pi}\;\Varid{a}\;\Varid{b})\;{}\<[13]%
\>[13]{}\mathrel{=}\;(\Varid{x}\;\mathbin{:}\;\Conid{T}\;\Varid{a})\;\Varid{â†’}\;\Conid{T}\;(\Varid{b}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Each of the constructs in \Cref{sec:tt:univ} can now be interpreted:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{std}\;{}\<[6]%
\>[6]{}\Varid{.U}\;{}\<[11]%
\>[11]{}\anonymous \;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{UU}{}\<[E]%
\\
\>[B]{}\Varid{std}\;{}\<[6]%
\>[6]{}\Varid{.U[]}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Varid{refl}{}\<[E]%
\\
\>[B]{}\Varid{std}\;{}\<[6]%
\>[6]{}\Varid{.El}\;{}\<[11]%
\>[11]{}(\Conid{A}\;\Varid{,}\;\Varid{u})\;\Varid{pu}\;\Varid{Î³}\;{}\<[25]%
\>[25]{}\mathrel{=}\;\Conid{T}\;(\Varid{subst}\;(\Varid{Î»}\;\Conid{A}\;\Varid{â†’}\;\Conid{A}\;\Varid{Î³})\;\Varid{pu}\;(\Varid{u}\;\Varid{Î³})){}\<[E]%
\\
\>[B]{}\Varid{std}\;{}\<[6]%
\>[6]{}\Varid{.ğ•“}\;{}\<[25]%
\>[25]{}\mathrel{=}\;(\Varid{Î»}\;\anonymous \;\Varid{â†’}\;\Conid{UU})\;\Varid{,}\;\Varid{Î»}\;\anonymous \;\Varid{â†’}\;\Varid{bool}{}\<[E]%
\\
\>[B]{}\Varid{std}\;{}\<[6]%
\>[6]{}\Varid{.Ï€}\;(\Conid{A}\;\Varid{,}\;\Varid{a})\;\Varid{pa}\;(\Conid{B}\;\Varid{,}\;\Varid{b})\;\Varid{pb}\;\mathrel{=}\;(\Varid{Î»}\;\anonymous \;\Varid{â†’}\;\Conid{UU})\;\Varid{,}\;\Varid{Î»}\;\Varid{Î³}\;\Varid{â†’}\;\Varid{pi}\;{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{transport}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\Varid{pa}\;\Varid{i}\;\Varid{Î³})\;(\Varid{a}\;\Varid{Î³}))\;{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{Î»}\;\Varid{a}\;\Varid{â†’}\;\Varid{transport}\;(\Varid{Î»}\;\Varid{i}\;\Varid{â†’}\;\Varid{pb}\;\Varid{i}\;(\Varid{Î³}\;\Varid{,}\;\Varid{a}))\;(\Varid{b}\;(\Varid{Î³}\;\Varid{,}\;\Varid{a}))){}\<[E]%
\\
\>[B]{}\Varid{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Coherence conditions are then verified using standard properties of transport.
We have formalised the standard model for type theory with $\Pi$-types, Booleans, and a Tarski universe, except the case for \ensuremath{\Varid{Ï€[]}}.

The main effort in the formalisation arises from the lack of \emph{regularity}~\cite{Sterling2022}: there is a path \ensuremath{\Varid{transportRefl}} between the transport along reflexivity and the identity but they are not strictly equal.
For instance, the coherence condition for \ensuremath{\Conid{Î []}} is given as
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{stdPi}\;\Varid{.Î []}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{Î”}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mskip1.5mu\}\;\Varid{Ïƒ}\;\Conid{B}\;\Varid{i}\;\Varid{Î³}\;\mathrel{=}\;{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Varid{a}\;\mathbin{:}\;\Conid{A}\;(\Varid{Ïƒ}\;\Varid{Î³}))\;\Varid{â†’}\;\Conid{B}\;(\Varid{Ïƒ}\;\Varid{Î³}\;\Varid{,}\;\Varid{transportReflÂ³}\;\Varid{a})\;(\mathord{\sim}\;\Varid{i})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{transportReflÂ³}} amounts to using \ensuremath{\Varid{transportRefl}} three times.
If regularity were available, this would collapse to the trivial reflexivity proof.
%The case |Ï€[]| above involves an equation over a transport of another transported term.
%\LT[noinline]{try to finish it if we have time.}

\subsection{Normalisation by evaluation, and the logical predicate interpretation} \label{sec:nbe}
We implement normalisation by evaluation (NbE) for the substitution calculus.
Following the approach for type theory~\cite{Altenkirch2017}, we define inductive-recursively both the type of variables (with their embedding into terms) and the type of renamings (with their embedding into substitutions).
The implementation is straightforward, so we omit the details here.
In the end, this yields a normalisation function that produces, for every term, a de Bruijn variable and computes:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{normalise}\;\mathbin{:}\;(\Varid{t}\;\mathbin{:}\;\Conid{Tm}\;\Conid{Î“})\;\Varid{â†’}\;\Conid{Î£[}\;\Varid{tâ¿}\;\Varid{âˆˆ}\;\Conid{NeTm}\;\Conid{Î“}\;\mskip1.5mu]\;\Varid{t}\;\mathop\equiv\;\Varid{âŒœ}\;\Varid{tâ¿}\;\Varid{âŒ}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Compared to NbE for substitution calculus using QIITs, our formalisation is simpler: no transports appear at all, because variables and terms are not indexed by their types.

The picture is very different for the logical predicate interpretation.
Although NbE works cleanly, the logical predicate interpretation --- often considered a benchmark challenge~\cite{Abel2019} for language formalisation --- remains at least as difficult as in the QIIT-based setting, even for substitution calculus.

To see why, recall that the motives for \ensuremath{\Conid{Ctx}} and \ensuremath{\Conid{Ty}} in the logical predicate interpretation are given by
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{record}\;\Conid{Ctxá´¾}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ctxá´¾}\;\mathbin{:}\;\Conid{Ctx}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{wká´¾}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Conid{Sub}\;\Varid{ctxá´¾}\;\Conid{Î“}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Conid{Tyá´¾}\;\mathbin{:}\;\Conid{Ctxá´¾}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Ty}\;\Conid{Î“}\;\Varid{â†’}\;{}\<[24]%
\>[24]{}\Conid{Set}{}\<[E]%
\\
\>[B]{}\Conid{Tyá´¾}\;\Conid{Î“á´¾}\;\Conid{A}\;\mathrel{=}\;\Conid{Ty}\;(\Varid{ctxá´¾}\;\Conid{Î“á´¾}\;\Varid{,}\;\Conid{A}\;[\kern-1.5pt\;\Varid{wká´¾}\;\Conid{Î“á´¾}\;\kern-1.5pt]_{\text{T}}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Here the typing constraint \ensuremath{(\Varid{ctxá´¾}\;\Conid{Î“á´¾}\;\Varid{,}\;\Conid{A}\;[\kern-1.5pt\;\Varid{wká´¾}\;\Conid{Î“á´¾}\;\kern-1.5pt]_{\text{T}})} already shares the familiar shape of \ensuremath{\Conid{Tm}\;\Conid{Î“}\;\Conid{A}}, but with an additional complication: the index explicitly demands a type substitution.
Since the QIIRT representation only provides equality constructors for type substitutions, the development quickly results in repeated and tedious use of transports.

In short, NbE benefits directly from removing typing indices and avoids transports altogether, whereas the logical predicate interpretation still inherits the need for coercions with type substitutions.
We did not bother to finish all cases of the logical predicate interpretation, as Altenkirch and Kaposi~\cite{Altenkirch2016a} have already shown that such tedious use of transports is possible (but impractical) in theory.

\subsection{Strictification} \label{sec:strictify}
\FNF[inline]{Work further on the idea of strictification? (R2)}
Instead, we turn our attention to \emph{strictification}~\cite{Donko2022,Kaposi2025}: given a model of type theory, certain equality constructors can be made strict (i.e., made to hold judgementally) to form a new model.
A familiar analogy is the transition from lists to difference lists, where a list is represented by a list-appending function and list concatenation is function composition, which is associative judgementally.

In the same spirit, we may attempt to `strictify' the category part of substitution calculus using the Yoneda embedding, so that the unit laws and associativity law hold strictly, \emph{modulo} the property of naturality.
Given any \ensuremath{\Conid{SC}}-algebra, we define a presheaf interpretation of \ensuremath{\Conid{Sub}} by
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{record}\;\Conid{SubÊ¸}\;(\Conid{Î“}\;\Conid{Î”}\;\mathbin{:}\;\Conid{Ctx})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{constructor}\;\Varid{\char95 ,\char95 }{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{y}\;{}\<[10]%
\>[10]{}\mathbin{:}\;\Varid{âˆ€}\;\{\mskip1.5mu \Conid{Î˜}\mskip1.5mu\}\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î˜}\;\Conid{Î“}\;\Varid{â†’}\;\Conid{Sub}\;\Conid{Î˜}\;\Conid{Î”}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{nat}\;{}\<[10]%
\>[10]{}\mathbin{:}\;(\Varid{Ï„}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î}\;\Conid{Î˜})\;(\Varid{Î´}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î˜}\;\Conid{Î“})\;\Varid{â†’}\;\Varid{y}\;\Varid{Î´}\;\Varid{âˆ˜}\;\Varid{Ï„}\;\mathop\equiv\;\Varid{y}\;(\Varid{Î´}\;\Varid{âˆ˜}\;\Varid{Ï„}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
By set-truncation, any two morphisms \ensuremath{\Varid{Ïƒ}} and \ensuremath{\Varid{Ïƒ'}} in the presheaf category are equal whenever their functionals agree:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{â‰¡Ê¸â†’â‰¡}\;\mathbin{:}\;\{\mskip1.5mu \Varid{Ïƒ}\;\Varid{Ïƒ'}\;\mathbin{:}\;\Conid{SubÊ¸}\;\Conid{Î“}\;\Conid{Î”}\mskip1.5mu\}\;\Varid{â†’}\;\Varid{Ïƒ}\;\Varid{â‰¡Ê¸}\;\Varid{Ïƒ'}\;\Varid{â†’}\;\Varid{Ïƒ}\;\mathop\equiv\;\Varid{Ïƒ'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\Varid{\char95 â‰¡Ê¸\char95 }} denotes the path type between their functionals.
Completing the Yoneda embedding then gives us strict unit and associativity laws, up to \ensuremath{\Varid{â‰¡Ê¸â†’â‰¡}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Yoneda}\;\Varid{.idSâˆ˜\char95 }\;{}\<[17]%
\>[17]{}\anonymous \;{}\<[24]%
\>[24]{}\mathrel{=}\;\Varid{â‰¡Ê¸â†’â‰¡}\;\Varid{refl}{}\<[E]%
\\
\>[B]{}\Conid{Yoneda}\;\Varid{.\char95 âˆ˜idS}\;{}\<[17]%
\>[17]{}\anonymous \;{}\<[24]%
\>[24]{}\mathrel{=}\;\Varid{â‰¡Ê¸â†’â‰¡}\;\Varid{refl}{}\<[E]%
\\
\>[B]{}\Conid{Yoneda}\;\Varid{.assocS}\;{}\<[17]%
\>[17]{}\anonymous \;\anonymous \;\anonymous \;{}\<[24]%
\>[24]{}\mathrel{=}\;\Varid{â‰¡Ê¸â†’â‰¡}\;\Varid{refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can adapt the local universe construction~\cite{Lumsdaine2015,Donko2022} for \ensuremath{\Conid{M}\;\mathbin{:}\;\Conid{SC}} to further strictify the laws for type substitutions for substitution.
Types under the context $\Gamma$ in the local universe construction are interpreted as a triple consisting of a context $V$ as the local universe, a type under the context $V$, and a substitution from $\Gamma$ to $V$:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Keyword{record}\;\Conid{TyÂ³}\;(\Conid{Î“}\;\mathbin{:}\;\Conid{Ctx})\;\mathbin{:}\;\Conid{Set}\;\Keyword{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{constructor}\;\Varid{tyÂ³}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Keyword{field}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{V}\;\mathbin{:}\;\Conid{Ctx}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{E}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{Ty}\;\Conid{V}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{âŒœ\char95 âŒ}\;\mathbin{:}\;\Conid{Sub}\;\Conid{Î“}\;\Conid{V}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Type substitution is defined by `delaying' the substitution, i.e., by viewing the substitution \ensuremath{\Varid{âŒœ}\;\Conid{A}\;\Varid{âŒ}} as an accumulator parameter.
Then, we can show that the laws about type substitution boil down the right unit and the associativity laws for substitutions:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}(\Conid{M}\;\mathbin{!})\;\Varid{.[idS]T}\;\{\mskip1.5mu \Conid{Î“}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{A}\mskip1.5mu\}\;{}\<[26]%
\>[26]{}\mathrel{=}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{cong}\;(\Varid{tyÂ³}\;(\Conid{A}\;\Varid{.V})\;(\Conid{E}\;\Conid{A}))\;\highlight{addition}{(\Varid{sym}\;(\Varid{âŒœ}\;\Conid{A}\;\Varid{âŒ}\;\Varid{âˆ˜idS}))}{}\<[E]%
\\
\>[3]{}(\Conid{M}\;\mathbin{!})\;\Varid{.[âˆ˜]T}\;\Conid{A}\;\Varid{Ïƒ}\;\Varid{Ï„}\;{}\<[26]%
\>[26]{}\mathrel{=}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{cong}\;(\Varid{tyÂ³}\;(\Conid{A}\;\Varid{.V})\;(\Conid{E}\;\Conid{A}))\;\highlight{addition}{(\Varid{assocS}\;\Varid{Ïƒ}\;\Varid{Ï„}\;\Varid{âŒœ}\;\Conid{A}\;\Varid{âŒ})}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If \ensuremath{\Conid{M}} is strictified by the Yoneda embedding, then the laws for identity substitution and substitution composition in \ensuremath{\Conid{M}\;\mathbin{!}} will be strict up to \ensuremath{\Varid{â‰¡Ê¸â†’â‰¡}}.
Hence, combining both techniques, we can construct models where both the category laws and substitution laws are strict after applying \ensuremath{\Varid{â‰¡Ê¸â†’â‰¡}}.

Nevertheless, strictification does \emph{not} resolve our difficulties with the logical predicate interpretation.
In particular, the lack of strict propositions (or just definitional UIP) in \CA prevents \ensuremath{\Varid{Ïƒ}\;\Varid{â‰¡Ê¸}\;\Varid{Ïƒ'}} from being strictly equal, since the paths between their properties must still be identified manually using set-truncation.
Although \Agda provides a form of strict propositions \ensuremath{\Conid{Prop}}, it is not designed to work with \CA and interacts poorly with cubical primitives for now~\cite{Agda-issue2022}.
As a consequence, coercions along equations identified by set-truncation remain unavoidable.


\section{Discussion and conclusion}
\label{sec:discussion}

%\FNF{Also discuss alternative choices such as basing the formalisation on (split) comprehension categories, see Brunerie and de Boer~\cite{Boer2020,Brunerie2019} (R2)}

It is well known that type theory in type theory is possible in theory, but in practice its formalisation often requires giving up some of the support and safety checks provided by proof assistants.
From one point of view, our work addresses the following question: is there any existing type-theoretic proof assistant that can formalise the intrinsic representation of type theory using QIITs reliably, without compromise?
Based on our experimental formalisation in \CA, our answer is regrettably: not yet.

\paragraph{Comparison with intrinsic approaches}
Previous intrinsic formalisations~\cite{Kaposi2019,Kaposi2017,Altenkirch2016a,Altenkirch2017} based on the CwF semantics of type theory have resorted to using postulated constructors and custom rewrite rules to manually define QIITs and their eliminators.
However, this comes at a cost: the proof assistant no longer performs strict positivity, coverage, or termination checks for functions defined from quotient inductive types, nor does it supports dependent pattern matching, program extraction, and interactive theorem proving.
The loss of coverage check for inductive types is mitigated by using hand-crafted eliminators (see \Cref{sec:tt:elim}), since the coverage check is also in effect for record types.

The Ehrhard's style of presentation~\cite{Coquand2020,Ehrhard1988}, whereas the set of terms remains indexed by types but without any transport in the middle of terms for specifying equations, can be stated by using dependent paths and has been adopted by a recent formalisation~\cite{Altenkirch2026} in \CA.

Our approach leads to no transports appearing in its own syntax and also avoids the use of dependent paths at all.
However, the same transports (and the same equations for them) seem to have a tendency to come back in concrete model constructions, as explained in \cref{sec:meta}.

We remark that the lack of transports is an advantage for avoiding strict positivity issues in the current implementation of \CA.
By using native features such as higher inductive types, rather than postulates in ordinary \Agda, we do get computational interpretations.
For example, our implementation of normalization by evaluation in \cref{sec:nbe} can actually normalise terms and could be potentially extracted as Haskell programs with the cubical information explicitly erased using \Agda's \text{\ttfamily \char45{}\char45{}erased\char45{}cubical} feature.

It is not yet clear if other initial models of type theory, such as (split) comprehension categories~\cite{Jacobs1993} and contextual categories~\cite{Cartmell1986}, can be defined as QIITs or QIIRTs.

\paragraph{Strictification}
Kaposi and Pujet~\cite{Kaposi2025} have shown how strictification techniques can simplify proofs, but this is an orthogonal issue.
Even though strictification turns most of the equality constructors about substitution to strict equalities, this does not help with transports appearing in the QIIT definition of terms and the resulting strict positivity issues, as strictification can only be applied \emph{after} the inductive types are defined.
In \cref{sec:strictify}, we have sketched how also our notion of models can be strictified using a simpler idea.
However, a proper strictification may require a different metatheory than `just' the support of QII(R)Ts (see below).

% Untyped version might still be easiest to work with, with current proof assistant technology

\paragraph{A proper syntax for HII(R)Ts}
The syntax for declaring higher inductive-inductive types and QIITs in \CA falls short of their theoretical capabilities~\cite{Kaposi2020b,Kaposi2019}.
As shown in \Cref{sec:tt:cwf}, the legitimate definition of type theory based on CwF with transports violates the syntactic restriction of strict positivity in \CA.
Even though transport hell is better avoided in practice, this is not a justification for excluding otherwise valid definitions.
The alternative definition, based on natural models, does not violate strict positivity but still requires forward declarations (\Cref{sec:tt:mutual}) to overcome the inconvenience of syntax.

\paragraph{A theory of QIIRTs}
We work around the problem by defining type theory using QIIRTs, but this raises another question: what is the theory of QIIRTs, anyway?

Different forms of QIITs and inductive-recursive types (IRTs) have been used to develop type theory in type theory.
Large and infinitary IRTs are used for the standard model of universe; small inductive-recursive types~\cite{Hancock2013} for implementing normalisation by evaluation~\cite{Altenkirch2017}; QIITs and QIIRTs for the intrinsic representations of type theory.
Note further that the target of \ensuremath{\Varid{tyOf}} is the inductive type \ensuremath{\Conid{Ty}} being defined simultaneously, so the QIIRTs used to define our representation is neither large nor small.
Nevertheless, we expect that the encoding of small inductive-recursive types as indexed inductive types still applies to this `self-referring' induction-recursion, as we have derived our representation by `undoing' the encoding.

A framework to encompass all variants will be convenient for proof assistant implementation.
Such a scheme may be developed by extending the type theory of QIITs~\cite{Kaposi2019,Kovacs2020a} with an additional construct to distinguish strict and weak equalities and a coverage condition for function clauses.

\paragraph{The support of interleaved mutual definitions}
Another challenge concerns interleaved mutual definitions.
Since constructors of QIITs may be mutually interleaved, the elaboration from dependent pattern matching to eliminators need to take this into account.
Our workaround, using forward declarations to lift function clauses to fix the dependency, sacrifices their computational behaviour.
Furthermore, our definitions appear to reach the limits of the termination checker: even seemingly harmless functions when defining the recursion principle fail to pass termination checking.

% \paragraph{The need for strict propositions}
\paragraph{Strict propositions, and observational type theory}
The recent work on strictified syntax~\cite{Kaposi2025} addresses transport hell using observational type theory (OTT)~\cite{Pujet2022,Pujet2023,Pujet2024}, with strict propositions in the metatheory playing a central role.
While \Agda does support strict propositions~\cite{Gilbert2019}, this feature was not designed to work with \CA~\cite{Agda-issue2022}.
%
%\paragraph{The implementation of OTT or XTT}
To formalise the metatheory of type theory using QIITs with as few transports as possible, it seems inevitable to use a different metatheory rather than the off-the-shelf metatheory offered by \CA.
In particular, regularity and definitional UIP, supported by OTT (see \cite{Altenkirch2019,Pujet2024} for the discussion on regularity) and by its cubical variant XTT~\cite{Sterling2022}, would immediately simplify our standard model~(\Cref{sec:standard-model}) and make formalising metatheory more feasible using Kaposi and Pujet's strictification.

The use of QIITs in OTT~\cite{Kaposi2025} in \Agda requires the user themselves to implement the coercion rules for inductive types~\cite{Pujet2024} as well as their elimination principles.
Quotient inductive types are not supported in the implementation of OTT in Rocq~\cite{Pujet2024a} and its theory is still being developed~\cite{Felicissimo2025a}.

The option \text{\ttfamily \char45{}\char45{}cubical\char61{}no\char45{}glue} in the forthcoming \Agda 2.9.0~\cite{Agda-issue2025} disables the \ensuremath{\Conid{Glue}} type in cubical mode and, in principle, yields a cubical type theory compatible with UIP~\cite{Agda-issue2019}.
Since Cubical Agda already provides support for HIITs (with the earlier caveats), realising a type theory with QIITs, strict propositions, and computational UIP, as a variant of Cubical Agda may now be within reach~\cite{Tan2025,Tan2025a}.

\paragraph{The Ford transformation and definitional UIP}
The Ford transformation is known to work well with definitional UIP~\cite{Altenkirch2006}.
So far, we have only `Forded' the \text{\ttfamily Tm} constructors, but what if every constructor were Forded, with indices removed entirely?
The resulting representation of type theory would remain intrinsic, but all typing constraints would appear as equality proofs, which are definitionally proof-irrelevant in XTT or OTT.
This could provide a way to escape transport hell without relying on strictification.

Of course, explicitly transforming these typing constraints to equality proofs would still be tedious and error-prone, so an elaboration from QIITs to their Forded presentation using QIIRTs would be useful.
The connection between QIITs and its Forded definition with the index eliminated echoes the notion of reornament~\cite{Dagand2014,Ko2016,Dagand2017}, so this translation itself may be of interest in general.

\paragraph{Conclusion}
There are still gaps between a pen-and-paper type theory and a fully formalised type theory in a proof assistant, on both the theoretical and practical sides.
Without further advances in the technology of proof assistants, formalising type theory intrinsically within a proof assistant remains a difficult task.
We hope that the lessons learned here can help the design of future proof assistants, so that one day we may implement a proof assistant within a proof assistant without (too much) sweat and tears.

\begin{acks}
  We appreciate the constructive comments from the anonymous reviewers.
  Our syntax for displayed equations in \cref{sec:tt:elim} is inspired by the syntax of equational reasoning for displayed categories on 1Lab.\footnote{\url{https://1lab.dev/Cat.Displayed.Base.html}}
  We are also grateful to Shu-Hung You for his comments on the early draft.
  The work is supported by the National Science and Technology Council of Taiwan under grant NSTC 114-2222-E-001-001-MY3.
\end{acks}

%\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}
\bibliography{ref}

\end{document}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main.tex"
%%% eval: (add-hook 'after-save-hook (lambda () (shell-command "make tex")) t)
%%% End:
