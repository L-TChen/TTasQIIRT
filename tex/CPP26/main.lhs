\documentclass[sigplan,10pt,anonymous,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}

%%% Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{mathtools}
\let\Bbbk\relax
\usepackage{amsmath,amssymb,mathbbol}
\usepackage{bbold}
\usepackage[inline]{enumitem}

%% Remove the following if there are no todo items.
\setlength {\marginparwidth }{2cm}
\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage[capitalise]{cleveref}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},color={pink},#1]{#2}}
\newcommand{\FNF}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}

\usepackage{microtype}
\usepackage{newunicodechar}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Macros %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\CA}{\textsc{Cubical Agda}\xspace}
\newcommand{\Agda}{\textsc{Agda}\xspace}
\newcommand{\Set}{\mathbf{Set}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% lhs2tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cons}[1]{\mathbf{#1}}
\newcommand{\iden}{\mathit}

\newcommand{\awa}[2]{\mathrlap{#2}\phantom{#1}} % as wide as

\definecolor{addition}{RGB}{204,255,216}
\newcommand{\highlight}[2]{\smash{\text{\colorbox{#1}{\kern-.1em\vphantom{\vrule height 1.2ex depth 0.1ex}\smash{\ensuremath{#2}}\kern-.1em}}}}

\let\Bbbk\relax
%include agda.fmt
%format (HL(t)) = "\highlight{addition}{" t "}"
%format â‰¡ = "\mathop\equiv"
%format [ = "[\kern-1.5pt"
%format ] = "\kern-1.5pt]"

%% end of the preamble, start of the body of the document source.


\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title[Can Natural Model Simplify the Metatheory of Type Theory?]{Can Inspiration From Natural Models Simplify the Metatheory of Type Theory in Cubical Agda?}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Liang-Ting Chen}
\affiliation{%
  \institution{Institute of Information Science, Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
\email{liangtingchen@@as.edu.tw}

\author{Fredrik Nordvall Forsberg}
\affiliation{%
  \institution{Department of Computer and Information Sciences, University of Strathclyde}
  \city{Glasgow}
  \country{United Kingdom}}

\author{Tzu-Chun Tsai}
\affiliation{%
  \institution{Institute of Information Science, Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
%\affiliation{%
%  \institution{Institute for Logic, Language and Computation, University of Amsterdam}
%  \city{Amsterdam}
%  \country{Netherlands}}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  We report on an approach to formalising type theory in type theory, inspired by Awodeyâ€™s \emph{natural models} of type theory.
  The initial natural model is represented as quotient inductive-inductive-recursive types in the proof assistant \CA, leading us to a syntax without any `transport hell'.
We formalise some meta-properties such as the standard % and logical predicate
interpretation, normalisation by evaluation for typed terms, and strictification constructions.
Since our formalisation is carried out using \CA's native support for quotient inductive types, all our constructions compute at a reasonable speed.

However, the `transport hell' problem reappears when we try to develop more sophisticated metatheory.
Ultimately, it remains a considerable struggle to develop the metatheory of type theory using an intrinsic representation that lacks strict equations.
The effort required is about the same whether or not the notion of natural model is used.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}

\keywords{Proof Assistants, Formalisation, Cubical Agda, Quotient Inductive-Inductive-Recursive Type}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\maketitle
\bibliographystyle{ACM-Reference-Format}

\section{Introduction}
% FNF (Fri 5 Sep)

Internalising the syntax and semantics of type theory in type theory is a longstanding problem which stretches the limits of the theory~\cite{Dybjer1996,Danielsson2006,Chapman2009,McBride2010,Altenkirch2016a}.
%
There are both practical and theoretical reasons to pursue this problem.
%
On the practical side, such an internal representation of type theory is needed for metaprogramming and mechanised metatheory.
%
More philosophically, if type theory is supposed to be a general constructive foundation of mathematics, then it should in particular be able to reason about its own syntax and semantics (up to inherent limitations due to G\"odel's Incompleteness Theorems, of course).
%
In dependent type theory, types can depend on terms, which means that all of contexts, types and terms need to be defined simultaneously.
%
This is one reason why formalising type theory in type theory is hard.
%

%\LT[noinline]{Is this just Pollack or McKinna \& Pollack?}
%\FNF[noinline]{It was meant to be Pollack's thesis, but McKinna \& Pollack might be better.}
Early approaches to formalising type theory, e.g.\ McKinna and Pollack~\cite{McKinna1999}, dealt with untyped terms that were later refined by a typing relation, or used setoid equality, and hence had to prove a lot of congruence lemmas by hand~\cite{Danielsson2006,Chapman2009}.
%
A breakthough was achieved by Altenkirch and Kaposi~\cite{Altenkirch2016a}, who showed that quotient inductive-inductive types (QIITs)~\cite{Altenkirch2018} can be employed to significantly simplify the internal representation of well typed terms, since equality constructors can be used to represent equations such as $\beta$- and $\eta$-equality.
%
Altenkirch and Kaposi took Dybjer's notion of a model of type theory in the form of a Category with Families~\cite{Dybjer1996}, and translated it into a QIIT definition.
%
In effect, this gives rise to the \emph{initial} Category with Families, with the elimination principles of the QIIT giving a unique morphism of Categories with Families to any other model.
%
This thus gives a both principled and practical way to formalise the syntax and dynamic semantics of type theory in type theory; the feasibility of the approach was demonstrated by e.g.\ implementing normalisation by evaluation using this representation~\cite{Altenkirch2017}.

However, QIIT definitions are still cumbersome to work with, since the type of later constructors or even equations often only make sense because of earlier equations.
%
In an intensional type theory, such as those implemented in proof assistants, this manifests itself in transport terms across equality proofs inside other terms, and leads to so-called ``transport hell'' --- rather than just reasoning about the terms you actually want to study, you now also have to do a lot of reasoning about transports themselves and their algebraic properties.
%
We are interested in ways of reducing transport hell, in order to make formalisations of type theory in type theory more lightweight and feasible.

In this paper, we report on an attempt to simplify such formalisations.
%
Our starting point is the idea of viewing Altenkirch and Kaposi's QIIT definition as the initial Category with Families.
%
The framework of Categories with Families is only one of several (more or less) equivalent notions of models of type theory~\cite{Hofmann1997}, and we were wondering if any of the other notions might offer any advantages.
%
Bense~\cite{Bense2024} suggested that Awodey's notion of \emph{natural model}~\cite{Awodey2018} might be a good candidate.
%
Indeed, in a natural model, the indexing of terms over their types $\mathsf{Tm} : \mathsf{Ty}(\Gamma) \to \mathsf{Set}$ (as in a Category with Families) is replaced by a ``fibred'' perspective where each term instead \emph{has} a type, as picked out by a function $\mathsf{tyOf} : \mathsf{Tm}(\Gamma) \to \mathsf{Ty}(\Gamma)$.
%
Terms and types are still indexed by contexts $\Gamma$, but since most ``type mismatches'' arise from equations between types, not equations between contexts (indeed many formulations of type theory does not even have a notion of context equality), this should mean that many uses of transports can be avoided.

We test this hypothesis by formalising type theory in a form inspired by natural models in the proof assistant Cubical Agda~\cite{Vezzosi2021}.
%
Cubical Agda is a good fit for such a project, because not only does it support QIITs, it also supports inductive-recursive types~\cite{Dybjer1999}, which are needed to simultaneously define the recursive $\mathsf{tyOf}$ function together with the inductively defined types $\mathsf{Tm}(\Gamma)$ and $\mathsf{Ty}(\Gamma)$.
%
Indeed, it could be the lack of support for inductive-recursive definitions in many proof assistants which has held back formalisation attempts based on natural models so far.

While we manage to avoid many transports occurring in terms, the experiment is not an outright success.
%
Indeed, we found that when developing more sophisticated metatheory, such as when defining a logical predicates model, the use of transports along equations often reappeared.
%
Furthermore, we found that the use of natural models is less well supported in the Cubical Agda of today, compared to approaches based purely on QIITs.
%
This is because we are more reliant on the computational behaviour of the recursively defined $\mathsf{tyOf}$ function, and this behaviour is only available in ``later'' clauses, which leads to the need for hacks and tricks to work around this limitation.
%
We discuss proof assistant features and their helpfulness further towards the end of the paper, after presenting our formalisation.

\paragraph{Contributions} We make the following contributions:
\begin{itemize}
\item We present an intrinsically well typed representation of the syntax of type theory, inspired by Awodey's natural models (\cref{sec:tt}).
\item We derive elimination and recursion principles for the syntax (\cref{sec:tt:elim}), and show how it can be used to construct the standard model and the term model (\cref{sec:standard-model}).
\item We discuss strictification constructions on models, and show that they also apply to our notion of natural models (\cref{sec:strictify}).
\item We develop normalisation by evaluation for the substitution calculus phrased as a natural model (\cref{sec:nbe}); because our development is carried out in Cubical Agda, which has a computational implementation of QIITs and principles such as function extensionality, the resulting normaliser computes, and can be used to normalise terms.
\item We discuss pros and cons of our approach compared to other approaches, and which proof assistant features would be helpful to make future formalisations easier (\cref{sec:compare}).
\end{itemize}

%\LT{the idea of using natural model appears at least in 2024 \cite{Bense2024}, and it is a natural idea to formalise type theory in this way.}
\section{Setting and metatheory}
% FNF (Sun 7 Sep)

Our formalisation is carried out in Cubical Agda with a global assumption of Uniqueness of Identity Proofs.
%
We believe it should be possible to discharge this global assumption in favour of explicitly set-truncating the types we define.
%
Of course, since Univalence is provable in Cubical Agda, such a global assumption of Uniqueness of Identity Proofs is, in fact, inconsistent.
%
However, we make sure to not make use of Univalence in our development (more generally, we do not make use of the |Glue| type, which is used to prove Univalence), and so we have high confidence that our formalisation is actually consistent.
\LT{Shouldn't it be justified by XTT~\cite{Sterling2022}?}
%
We note that a variant of Cubical Agda which is consistent with Uniqueness of Identity Proofs have also been requested by other users.\footnote{``A variant of Cubical Agda that is consistent with UIP'', \url{https://github.com/agda/agda/issues/3750}.}

\FNF{Explain path types}
\FNF{Explain QITs}

QIIRTs

\LT{For brevity we have made arguments implicit for equality constructors, whereas some of them are actually explicit in our formalisation.}
\LT{Universe levels are ignored in the paper.}
\LT{Should we give a simple example of QIRT here?}

\section{Type theory as quotient inductive types} \label{sec:tt}
This section's aim is to exhibit that Altenkirch and Kaposi's representation, which contains the transport hells and violates the syntactic restriction imposed by \CA, can be transformed to a representation based on Awodey's natural model, which is free from transports and accepted by \CA.
Then, we will show how other type formers can be represented in this way.
In the reminder of this section, we will give its elimination principle and explain how these definitions are formalised in \CA.

\subsection{Type theory as the initial CwF model}
\LT{CwF or cwf?}
In the QIIT representation~\cite{Altenkirch2016a}, each judgement is defined as an inductive type, each typing rule as a constructor, and each equality between types, terms, and substitutions as an \emph{equality constructor}.
The inhabitants of these types are valid derivations in type theory, because their validity is enforced by typing constraints.
Previously, \Agda did not natively allow equality constructors, so a workaround known as `Licata's trick'~\cite{Licata2011} was used, which meant giving up many features of the proof assistant.
With \CA now equipped with the support for QIITs, it is natural to ask if we can use this support to define type theory.

We briefly recall the representation given by Altenkirch and Kaposi.
Those four types of judgements in type theory are represented inductive-inductively and indexed by their context and by their types for terms as
\begin{code}
data Ctx : Set
data Sub : (Î“ Î”  : Ctx)  â†’ Set
data Ty  : (Î“    : Ctx)  â†’ Set
data Tm  : (Î“    : Ctx)  â†’ Ty Î“ â†’ Set
\end{code}
For example, an inhabitant of |Tm Î“ A| represents a derivation for a term of type $A$ under the context |Î“|.
Rules are represented by constructors of these inductive types:
\begin{code}
data _ where
  âˆ…     : Ctx
  _,_   : (Î“ : Ctx)(A : Ty Î“) â†’ Ctx
  _[_]  : (A : Ty Î”)(Ïƒ : Sub Î“ Î”) â†’ Ty Î“
  _[_]  : (t : Tm Î” A)(Ïƒ : Sub Î“ Î”) â†’ Tm Î“ (A [ Ïƒ ]T)
  _âˆ˜_   : Sub Î” Î˜ â†’ Sub Î“ Î” â†’ Sub Î“ Î˜
  _,_   : (Ïƒ : Sub Î“ Î”)(t : Tm Î“ (A [ Ïƒ ]T))
        â†’ Sub Î“ (Î” , A)
  [âˆ˜]   : A [ Ï„ ] [ Ïƒ ] â‰¡ A [ Ï„ âˆ˜ Ïƒ ]
  ...
\end{code}
Here, |_âˆ˜_| is the constructor for substitution composition, and the second |_,_| is the constructor for extending a substitution |Ïƒ| with a term |t| of type |A [ Ïƒ ]|.
The equality constructor~|[âˆ˜]| represents the rule that the type substitution for a composition |Ï„ âˆ˜ Ïƒ| is equal to a type substitution |Ï„| followed by another |Ïƒ|.
When formulating the corresponding rule for the interaction between |_âˆ˜_| and |_,_|, we encounter a type mismatch that needs to be resolved by a transport, leading to the transport hell when reasoning with this equality:
\begin{code}
,âˆ˜   : (Ïƒ : Sub Î” Î˜) (t : Tm Î” (A [ Ïƒ ]T)) (Ï„ : Sub Î“ Î”)
  â†’ (Ïƒ , t) âˆ˜ Ï„ â‰¡ Ïƒ âˆ˜ Ï„ , (HL(subst (Tm Î“) ([âˆ˜] A Ï„ Ïƒ))) (t [ Ï„ ]t)
\end{code}
The reason is that the type of |t [ Ï„ ]| is |A [ Ïƒ ] [ Ï„ ]| rather than the required |A [ Ïƒ âˆ˜ Ï„ ]|.
However, since |Tm| appears as an argument to |subst|, the use of transport violates the syntactic restriction: strict positivity check.
In theory, transports are allowed in QIITs~\cite{Kaposi2019}, but it is not clear to us how this syntactic restriction should be relaxed for higher inductive types supported by \CA to tack account of other cubical primitives (such as |hcomp|).

In other words, the transport hell is not only an obstacle for reasoning but also breaks strict positivity when arising in inductive definitions themselves.
The situation becomes worse once additional type formers are introduced---such as $\Pi$-types and the type |El| of elements~\cite{Altenkirch2016a}---since each brings further instances of this problem.  

On the other hand, another source of transports arises from equations over equations, but this can be avoided by using dependent paths.
For example, the fact that the identity term substitution really acts as an identity is introduced as an equality constructor |[idS]t|, defined over the equality constructor |[idS]| for the identity type substitution:  
\begin{code}
[idS]T : A â‰¡ A [ idS ]
[idS]t : PathP (Î» i â†’ Tm Î“ ((HL([idS]T i)))) t (t [ idS ])
\end{code}
Although equations over equations are in principle more manageable, it quickly leads us to \emph{equations over equations over yet another equations} in their elimination rules.  
Therefore, it is still preferable to avoid them if possible.

Of course, one could bypass the strict positivity check, but doing so would undermine the trustworthiness of the formalisation in general.
Another possibility is to fix the syntactic restriction for HIITs, but it is unclear what conditions should be.
Therefore, we seek for an equivalent definition without transport hells instead. 

\subsection{Fordism and the index elimination} \label{sec:tt:terms-without-indices}
To avoid the transport hell in the definition itself, we note that the index |A| of |Tm Î“ A| is rigid under operations on types, such as substitutions.
Since we often need to provide an explicit proof for the typing constraints that, for example, the term |t| in the substitution |(Ïƒ , t)| has type |A [ Ïƒ ]| if this does not hold strictly, enforcing this constraint in the index of |Tm| just shoots ourselves in the foot.
Hence, we apply `Fordism' transformation~\cite{McBride1999} to move the constraint on its index to its argument as an equality proof:
\begin{code}
_,_âˆ¶[_] : (Ïƒ : Sub Î“ Î”) (t : Tm Î“ B) (HL((t : B â‰¡ A [ Ïƒ ])))
  â†’ Sub Î“ (Î” , A)
\end{code}
Then, the constructor |,âˆ˜| becomes accordingly
\begin{code}
,âˆ˜ : (Ïƒ , t âˆ¶[ p ]) âˆ˜ Ï„ â‰¡ (Ïƒ âˆ˜ Ï„ , t [ Ï„ ]
        âˆ¶[ (HL(cong _[ Ï„ ] p âˆ™ ([âˆ˜]T A Ï„ Ïƒ))) ])
\end{code}
where |_âˆ™_| is the transitivity of equality.
Although transport is not needed this time, the use of |cong| and |_âˆ™_|
still prevent the definition from being strictly positive.
Similar to the Fordism transformation, this problem can be overcome by asking for another equality proof as an argument:
\begin{code}
,âˆ˜ : (Ïƒ : Sub Î” Î˜) (t : Tm Î” B) (Ï„ : Sub Î“ Î”)
   â†’ (p : B â‰¡ A [ Ïƒ ]) (HL((q : B [ Ï„ ] â‰¡ A [ Ïƒ âˆ˜ Ï„ ])))
   â†’ (Ïƒ , t âˆ¶[ p ]) âˆ˜ Ï„ â‰¡ (Ïƒ âˆ˜ Ï„) , t [ Ï„ ] âˆ¶[ (HL(q)) ]
\end{code}
As we assume UIP, the additional argument is essentially unique, so this updated constructor does not require any information but only defers the proof obligation.
%This redundant argument can be removed later when defining its eliminator (\Cref{sec:tt:elim}).

Once the Fordism transformation has been applied, the index |B| in |Tm Î“ B| no longer plays the role of enforcing constraints.
This opens the door to a simpler design: instead of carrying the index around, we can `Ford' all |Tm| constructors uniformly and remove the index entirely.
To preserve the necessary typing information, we simultaneously introduce an auxiliary function |tyOf : Tm Î“ â†’ Ty Î“| that records it explicitly.
In the end, the constructor |,âˆ˜| becomes
\begin{code}
,âˆ˜ : (Ïƒ : Sub Î” Î˜) (t : Tm Î”) (Ï„ : Sub Î“ Î”)
   â†’ (p : tyOf t â‰¡ A [ Ïƒ ]) (q : tyOf t [ Ï„ ] â‰¡ A [ Ïƒ âˆ˜ Ï„ ])
   â†’ (Ïƒ , t âˆ¶[ p ]) âˆ˜ Ï„ â‰¡ (Ïƒ âˆ˜ Ï„) , t [ Ï„ ] âˆ¶[ q ]
\end{code}

As a side effect, this approach also removes the need for dependent paths in the definition.
Two terms can now be compared even when it is not known in advance whether their types are equal.
For instance, the equality constructor for the identity substitution becomes
\begin{code}
  [idS]t  : t â‰¡ t [ idS ]
\end{code}
where the fact that |t| and |t [ idS ]| share the same type follows from their term equality, rather than being imposed as a \emph{requirement}.

\subsection{Substitution calculus using QIIRT}
Building on the changes described in \Cref{sec:tt:terms-without-indices}, we now spell out our version of substitution calculus: the following types are defined simultaneously with a recursive function:
\begin{code}
data Ctx  : Set
data Sub  : (Î“ Î”  : Ctx) â†’ Set
data Ty   : (Î“ : Ctx) â†’ Set
data Tm   : (HL((Î“ : Ctx) â†’ Set))
(HL(tyOf : Tm Î“ â†’ Ty Î“))
\end{code}
Similar to the QIIT representation, constructors are introduced for rules and equalities as follows, where we highlight constructors that are different from their QIIT counterpart:
\begin{code}
data _ where
  âˆ…              : Ctx
  _,_            : (Î“ : Ctx)(A : Ty Î“) â†’ Ctx
  _[_]           : (A : Ty Î”)(Ïƒ : Sub Î“ Î”) â†’ Ty Î“
  _[_]           : (A : Tm Î”)(Ïƒ : Sub Î“ Î”) â†’ Tm Î“
  âˆ…              : Sub Î“ âˆ…
  (HL(_,_âˆ¶[_]))  : (Ïƒ : Sub Î“ Î”) (t : Tm Î“) (pt : tyOf t â‰¡ A [ Ïƒ ])
    â†’ Sub Î“ (Î” , A)
  idS            : Sub Î“ Î“
  _âˆ˜_            : Sub Î” Î˜ â†’ Sub Î“ Î” â†’ Sub Î“ Î˜
  Ï€â‚             : Sub Î“ (Î” , A) â†’ Sub Î“ Î”
  Ï€â‚‚             : Sub Î“ (Î” , A) â†’ Tm Î“
  idSâˆ˜_          : idS âˆ˜ Ïƒ â‰¡ Ïƒ
  _âˆ˜idS          : Ïƒ âˆ˜ idS â‰¡ Ïƒ
  assocS         : (Î³ âˆ˜ Ï„) âˆ˜ Ïƒ â‰¡ Î³ âˆ˜ (Ï„ âˆ˜ Ïƒ)
  [idS]T         : A  â‰¡  A  [ idS ]
  (HL([idS]t))   : t  â‰¡  t  [ idS ]
  [âˆ˜]T           : A  [ Ï„ ]  [ Ïƒ ]  â‰¡ A  [ Ï„ âˆ˜ Ïƒ ]
  (HL([âˆ˜]t))     : t  [ Ï„ ]  [ Ïƒ ]  â‰¡ t  [ Ï„ âˆ˜ Ïƒ ]
  (HL(,âˆ˜))       : (q : tyOf (t [ Ï„ ]) â‰¡ A [ Ïƒ âˆ˜ Ï„ ])
    â†’ (Ïƒ , t âˆ¶[ pt ]) âˆ˜ Ï„ â‰¡ (Ïƒ âˆ˜ Ï„ , t [ Ï„ ] âˆ¶[ q ])
\end{code}
... except that we have to interleave the function clauses of |tyOf| with constructors.
We need define the function clause for |Ï€â‚‚ Ïƒ| before the $\eta$-law for substitution:
\begin{code}
tyOf (Ï€â‚‚ {Î“} {Î”} {A} Ïƒ)   = A [ Ï€â‚ Ïƒ ]
data _ where
  Î·Ï€ : Ïƒ â‰¡ (Ï€â‚ Ïƒ , Ï€â‚‚ Ïƒ âˆ¶[ (HL(refl)) ])
\end{code}
Otherwise, the proof obligation |tyOf (Ï€â‚‚ Ïƒ) â‰¡ A [ Ï€â‚ Ïƒ ]| on the right hand side of |Î·Ï€| cannot be fulfilled by |refl|.
We proceed with other equality constructors:
\begin{code}
data _ where
  Î·âˆ…         : Ïƒ â‰¡ âˆ…S
  Î²Ï€â‚        : Ï€â‚ (Ïƒ , t âˆ¶[ p ]) â‰¡ Ïƒ
  (HL(Î²Ï€â‚‚))  : (HL((q : A [ Ï€â‚ (Ïƒ , t âˆ¶[ p ]) ]T â‰¡ tyOf t)))
    â†’ Ï€â‚‚ (Ïƒ , t âˆ¶[ p ]) â‰¡ t
\end{code}
Note that |Î²Ï€â‚‚| has an additional derivable equality proof.
This argument is needed as the coherence condition for
\begin{code}
tyOf (Î²Ï€â‚‚ Ïƒ t p q i)  = q i
\end{code}
since again using any other function while defining inductive types breaks the strict positivity check. 
The remaining clauses are given as
\begin{code}
tyOf (t [ Ïƒ ])        = (tyOf t) [ Ïƒ ]
tyOf ([idS]t t i)     = [idS]T i
tyOf ([âˆ˜]t t Ïƒ Ï„ i)   = [âˆ˜]T i
\end{code}
This definition is accepted by \CA\footnote{At the time of writing, \CA does not support interleaved mutual definitions, but it can be equivalently defined using forward declarations.
We will discuss this idiom in \Cref{sec:tt:mutual}.}
without any warnings or errors. 
Although |Tm| is only indexed by |Î“ : Ctx|, the function |tyOf| ensures that every |t : Tm Î“| has a type.
Hence, |Tm| only consists of valid derivations and is still an intrinsic representation of type theory.

Replacing the index |A : Ty| of |Tm| by a function |tyOf : Tm Î“ â†’ Ty Î“| aligns with Awodey's notion of \emph{natural model}~\cite{Awodey2018} where the collections of terms and types are represented as presheaves $\mathsf{Tm}, \mathsf{Ty} \colon \mathbb{C} \to \Set$ over the category of contexts $\mathbb{C}$ and connected by a natural transformation $\mathsf{Tm} \to \mathsf{Ty}$ stable under pullbacks, i.e.\ substitution.
That is, we have just derived the initial natural model using QIIRT in \CA.
This situates our family of inductive types and their algebras within a well-studied categorical models for type theory.

\subsection{Type theory with the $\Pi$-type}

We proceed with the $\Pi$-type.
First we define the lifting of a substitution by a type:
\begin{code}
_â†‘_ : (Ïƒ : Sub Î“ Î”) (A : Ty Î”) â†’ Sub (Î“ , A [ Ïƒ ]) (Î” , A)
_â†‘_ {Î“} Ïƒ A = Ïƒ âˆ˜ Ï€â‚ {Î“ , A [ Ïƒ ]} idS
  , Ï€â‚‚ (idS {Î“ , A [ Ïƒ ]}) âˆ¶[ (HL(p)) ]
\end{code}
where |p : tyOf (Ï€â‚‚ idS) â‰¡ A (HL([ Ïƒ âˆ˜ Ï€â‚ idS ]))|.
We may be tempted to use |[âˆ˜]T| to define |p|, as |tyOf (Ï€â‚‚ (idS {Î“ , A [ Ïƒ ]}))| is equal to |A (HL([ Ïƒ ] [ Ï€â‚ idS ]))| by definition.
Yet, again, we must refrain ourself from doing so during defining inductive types, so we introduce a \emph{superfluous} equality constructor
\begin{code}
data _ where
  tyOfÏ€â‚‚idS : tyOf (Ï€â‚‚ {A = A [ Ïƒ ]T} idS)
    â‰¡ A [ Ïƒ âˆ˜ Ï€â‚ idS ]T
\end{code}
which can be identified with the proof derivable from |[âˆ˜]T| using the UIP afterwards.
The required equality proof |p| above is then given by this constructor.

Other constructors are introduced following the Fordism:
\begin{code} 
data _ where
  Î             : (A : Ty Î“) (B : Ty (Î“ , A)) â†’ Ty Î“
  (HL(app))    : (t : Tm Î“) (B : Ty (Î“ , A)) (HL((pt : tyOf t â‰¡ Î  A B)))
    â†’ Tm (Î“ , A)
  abs          : (t : Tm (Î“ , A)) â†’ Tm Î“
  Î []          : (Î  A B) [ Ïƒ ] â‰¡ Î  (A [ Ïƒ ]) (B [ Ïƒ â†‘ A ])
  (HL(abs[]))  : abs t [ Ïƒ ] â‰¡ abs (t [ Ïƒ â†‘ A ])
  Î Î²           : app (abs t) (tyOf t) (HL(pt))  â‰¡ t
  Î Î·           : abs (app t B pt)               â‰¡ t

tyOf (app t B p)      = B
tyOf (abs {A = A} t)  = Î  A (tyOf t)
tyOf (abs[] Ïƒ t i)    = Î [] Ïƒ (tyOf t) i
tyOf (Î Î² t pt i)      = tyOf t
tyOf (Î Î· t pt i)      = pt (~ i)
\end{code}

Apart from the extra clauses of |tyOf|, the main change happens in the constructor |app|.
The constraint that |t| is of type |Î  A B| is enforced there, but every other constructor remains as almost the same as their QIIT definition.
\LT{any example?}
\subsection{Type theory with the type of Booleans}

The introduction of an inductive type of Booleans needs to specialise the substitution lifting.
Let us look at its constructors and explain why a specialisation is needed.
\begin{code}
data _ where
  ğ”¹      : Ty Î“
  ğ”¹[]    : ğ”¹ [ Ïƒ ] â‰¡ ğ”¹
  tt ff  : Tm Î“
  tt[]   : tt [ Ïƒ ] â‰¡ tt
  ff[]   : ff [ Ïƒ ] â‰¡ ff

tyOf tt  = ğ”¹
tyOf ff  = ğ”¹
tyOf (tt[] Ïƒ i)  = ğ”¹[] Ïƒ i
tyOf (ff[] Ïƒ i)  = ğ”¹[] Ïƒ i

data _ where
  elimğ”¹  : (P : Ty (Î“ , ğ”¹))
    (t : Tm Î“)  (HL((pt : tyOf t â‰¡ P [ idS , tt âˆ¶[ [idS]T ] ])))
    (u : Tm Î“)  (HL((pu : tyOf u â‰¡ P [ idS , ff âˆ¶[ [idS]T ] ])))
    (b : Tm Î“)  (HL((pb : tyOf b â‰¡ ğ”¹ [ idS ]))) â†’ Tm Î“

tyOf (elimğ”¹ P u t pu pt b pb) = P [ idS , b âˆ¶[ pb ] ]T
\end{code}
The only thing missing from the above definition is the substitution rule for |elimğ”¹|:
applying the substitution |Ïƒ| to `|elimğ”¹ P t pt u pu b pb|' is equal to applying a lifted substitution  |Ïƒ â†‘ ğ”¹| to |P| and |Ïƒ| to |t|, |u|, and |b|.
However, |P [ Ïƒ â†‘ ğ”¹ ]| gives us a type in the context |Î” , ğ”¹ [ Ïƒ ]| instead of |Î” , ğ”¹|, so we provide a lifting with a type |Sub Î“ Î” â†’ Sub (Î“ , ğ”¹) (Î” , ğ”¹)| and also a superfluous equality constructor |ğ”¹[]â‚‚| to satisfy its proof obligation:
\begin{code}
data _ where
  ğ”¹[]â‚‚   : tyOf (Ï€â‚‚ {Î“ , ğ”¹} idS) â‰¡ ğ”¹ [ Ï„ ]

_â†‘ğ”¹ : (Ïƒ : Sub Î“ Î”) â†’ Sub (Î“ , ğ”¹) (Î” , ğ”¹)
_â†‘ğ”¹ {Î“} {Î”} Ïƒ = Ïƒ âˆ˜ Ï€â‚ {Î“ , ğ”¹} idS , Ï€â‚‚ idS âˆ¶[ (HL(ğ”¹[]â‚‚)) ] 
\end{code}

Finally, we introduce the equality constructor for the interaction between |elimğ”¹| and substitution:
\begin{code}
data _ where
  elimğ”¹[] : ...
    (HL((ptâ‚‚ : tyOf (t  [ Ïƒ ]) â‰¡ P [ Ïƒ â†‘ğ”¹ ] [ idS , tt âˆ¶[ [idS]T ] ])))
    (HL((puâ‚‚ : tyOf (u  [ Ïƒ ]) â‰¡ P [ Ïƒ â†‘ğ”¹ ] [ idS , ff âˆ¶[ [idS]T ] ])))
    (HL((pbâ‚‚ : tyOf (b  [ Ïƒ ]) â‰¡ ğ”¹ [ idS ])))
    â†’ (HL((q : P [ idS , b âˆ¶[ pb ] ] [ Ïƒ ])))
    (HL(â‰¡ P [ Ïƒ âˆ˜ wk , vz âˆ¶[ ğ”¹[]â‚‚ ] ] [ idS , b [ Ïƒ ]t âˆ¶[ pbâ‚‚ ] ]))
    â†’ (elimğ”¹ P t pt u pu b pb) [ Ïƒ ]
    â‰¡ elimğ”¹ (P [ Ïƒ â†‘ğ”¹ ]) (t [ Ïƒ ]) (HL(ptâ‚‚)) (u [ Ïƒ ]) (HL(puâ‚‚)) (b [ Ïƒ ]) (HL(pbâ‚‚))

tyOf (elimğ”¹[] P u t pu pt b pb ptâ‚‚ puâ‚‚ pbâ‚‚ (HL(q)) i) = (HL(q i))
\end{code}
Note again that we also defer the coherence proof of |tyOf| for |elimğ”¹[]| by introducing another argument |q| in |elimğ”¹| which can be removed when defining its elimination rule.

\subsection{Type theory with a Tarski universe}
Using the same idiom described previously, a Tarski universe of types is introduced to our type theory in the same vein.
First we need |U : Ty Î“| as the type of code and a type former |El| as the type of elements:
\begin{code}
data _ where
  U     : Ty Î“
  U[]   : U [ Ïƒ ]T â‰¡ U
  El    : (u : Tm Î“) (HL((pu : tyOf u â‰¡ U))) â†’ Ty Î“
  El[]  : (HL((q : tyOf (u [ Ï„ ]t) â‰¡ U)))
    â†’ (El u (HL(pu))) [ Ï„ ]T â‰¡ El (u [ Ï„ ]t) (HL(q))
\end{code}

For the type |ğ”¹| of Boolean, its code |ğ•“| is introduced with a type equality |Elğ•“| such that the elements of |ğ•“| is exactly |ğ”¹|:
\begin{code}
data _ where
  ğ•“     : Tm Î“
  ğ•“[]   : ğ•“ [ Ïƒ ]t â‰¡ ğ•“

tyOf ğ•“          = U
tyOf (ğ•“[] Ïƒ i)  = U[] {Ïƒ = Ïƒ} i

data _ where
  Elğ•“ : El {Î“} ğ•“ refl â‰¡ ğ”¹
\end{code}

For the |Î |-type, we again require a specialised substitution lifting.
This continues the pattern of introducing superfluous constructors to satisfy proof obligations strictly.
\begin{code}
data _ where
  El[]â‚‚ : (u : Tm Î”) (pu : tyOf u â‰¡ U)
    â†’ (HL((puâ‚‚ : tyOf (u [ Ïƒ ]) â‰¡ U)))
    â†’ tyOf (Ï€â‚‚ {Î“ , El (u [ Ïƒ ]) (HL(puâ‚‚))} idS)
    â‰¡ El u pu [ Ïƒ âˆ˜ Ï€â‚ idS ]

_â†‘El : (Ïƒ : Sub Î“ Î”) {u : Tm Î”}
  {pu : tyOf u â‰¡ U} (HL({pu' : tyOf (u [ Ïƒ ]) â‰¡ U}))
  â†’ Sub (Î“ , (HL(El (u [ Ïƒ ]) pu'))) (Î” , El u pu)
(Ïƒ â†‘El) {u} {pu} {pu'} =
  Ïƒ âˆ˜ Ï€â‚ idS , Ï€â‚‚ idS âˆ¶[ (HL(El[]â‚‚ u pu pu')) ]
\end{code}

Finally, we introduce the code |Ï€| for |Î | and the type equality |ElÏ€| to complete our definition of type theory using QIIRT:
\begin{code}
data _ where
  Ï€    :  (a : Tm Î“) (HL((pa : tyOf a â‰¡ U)))
          (b : Tm (Î“ , El a pa)) (HL((pb : tyOf b â‰¡ U))) â†’ Tm Î“
  Ï€[]  :  (a : Tm Î“)              (HL((pa : tyOf a â‰¡ U)))
       â†’  (b : Tm (Î“ , El a pa))  (HL((pb : tyOf b â‰¡ U)))
       â†’  (HL((pa' : tyOf (a [ Ïƒ ]t) â‰¡ U)))
       â†’  (HL((pb' : tyOf (b [ Ïƒ â†‘El ]t)  â‰¡ U)))
       â†’  (Ï€ a pa b pb) [ Ïƒ ]t
       â‰¡  Ï€ (a [ Ïƒ ]t) (HL(pa')) (b [ Ïƒ â†‘El ]t) (HL(pb'))

tyOf (Ï€ _ _ _ _) = U

data _ where
  ElÏ€ : (a : Tm Î“) (HL((pa : tyOf a â‰¡ U)))
    â†’ (b : Tm (Î“ , El a pa)) (HL((pb : tyOf b â‰¡ U)))
    â†’ El (Ï€ a pa b pb) (HL(refl)) â‰¡ Î  (El a pa) (El b pb)

tyOf (Ï€[] _ _ _ _ _ _ i) = U[] i
\end{code}

In the end, we emphasise that the introduction of additional equality proofs and constructors only makes sense under the assumption of UIP. 
With UIP, these additional arguments are essentially unique and thus do not add any new information to the subject of study, but merely serve as devices to meet the syntactic restriction of strict positivity.

\subsection{Recursion and elimination principles} \label{sec:tt:elim}
We turn to the recursion and elimination principles.
Our QIIRT definition of type theory syntax yields an \emph{initial model}.
This means that for any other model (algebra) of our theory, there is a unique structure-preserving map from our syntax to that model.
The recursion and elimination principles make this property concrete.
Here, we only discuss the part for substitution calculus, since other type formers are addressed similarly.
For the interested reader, see our formalisation.

The signature for an algebra is packed in a record type~|SC|.
Inductive types and the function |tyOf| are interpreted as indexed types and a function between sets. 
Constructor of our syntax, except superfluous ones, correspond to function fields in this record, including equality constructors and clauses of |tyOf|.
\begin{code}
record SC  : Set  where
  field
    Ctx     : Set
    Ty      : Ctx â†’ Set
    Tm      : Ctx â†’ Set
    Sub     : Ctx â†’ Ctx â†’ Set
    tyOf    : {Î“ : Ctx} â†’ Tm Î“ â†’ Ty Î“

    âˆ…       : Ctx
    _,C_    : (Î“ : Ctx)(A : Ty Î“) â†’ Ctx
    _[_]T   : (A : Ty Î”)(Ïƒ : Sub Î“ Î”) â†’ Ty Î“
    _[_]t   : (t : Tm Î”)(Ïƒ : Sub Î“ Î”) â†’ Tm Î“
    idSâˆ˜_   : idS âˆ˜ Ïƒ â‰¡ Ïƒ
    ...
    Î²Ï€â‚‚     : â†’ Ï€â‚‚ (Ïƒ , t âˆ¶[ p ]) â‰¡ t
    ...
    tyOf[]  : tyOf (t [ Ïƒ ]t)      â‰¡ (tyOf t) [ Ïƒ ]T
    tyOfÏ€â‚‚  : tyOf (Ï€â‚‚ {A = A} Ïƒ)  â‰¡ A [ Ï€â‚ Ïƒ ]T
\end{code}

To distinguish syntactic constructors from the semantic methods in |SC|, we qualify the syntactic constructors with |S.| in the following discussion.

Those superfluous equality constructors, like |S.tyOfÏ€â‚‚idS|, are not required as fields in the record.
Instead, their semantic counterparts are defined within any given model using the other methods.
For example,
\begin{code}
  tyOfÏ€â‚‚idS : (Ïƒ : Sub Î“ Î”) (A : Ty Î”)
    â†’ tyOf (Ï€â‚‚ {A = A [ Ïƒ ]T} idS) â‰¡ A [ Ïƒ âˆ˜ Ï€â‚ idS ]T
  tyOfÏ€â‚‚idS Ïƒ A = tyOfÏ€â‚‚ idS âˆ™ [âˆ˜]T _ _ _
\end{code}
This simplifies the definition of models, as we only need to provide interpretations for the essential constructors.

The recursion principle itself consists of a family of functions that map syntax to their semantic counterparts in a given |SC|-algebra:
\begin{code}
recCtx   : S.Ctx â†’ Ctx
recTy    : S.Ty Î“ â†’ Ty (recCtx Î“)
recTm    : S.Tm Î“ â†’ Tm (recCtx Î“)
recSub   : S.Sub Î“ Î” â†’ Sub (recCtx Î“) (recCtx Î”)
\end{code}
We also need a function that translates proofs about syntactic types into proofs about semantic types:
\begin{code}
recTyOf  : S.tyOf t â‰¡ B â†’ tyOf (recTm t) â‰¡ recTy B
\end{code}
The definition of these functions proceeds by pattern matching on the syntactic structure.
Each clause is an application of the corresponding method from the |SC| record:
\begin{code}
recCtx S.âˆ…                = âˆ…
recCtx (Î“ S., A)          = recCtx Î“ ,C recTy A
...
recSub (Ïƒ S., t âˆ¶[ pt ])  = recSub Ïƒ , recTm t âˆ¶[ recTyOf t pt ]
...
\end{code}
The most interesting case is perhaps |recTyOf|, which handles the translation of syntactic equations.
For a given syntactic equality proof |p : S.tyOf t â‰¡ B|, we must construct a semantic equality proof.
This is done by applying |recTy| to both sides of the syntactic equality to get |recTy (S.tyOf t) â‰¡ recTy B|, and then using the semantic counterpart of the |tyOf| clause to derive |tyOf (recTm t) â‰¡ recTy (S.tyOf t)|.
Taking |S.Ï€â‚‚| as an example, we have:
\begin{code}
recTyOf {B = B} (S.Ï€â‚‚ {A = A} Ïƒ) p =
  tyOf (recTm (S.Ï€â‚‚ Ïƒ))         â‰¡âŸ¨âŸ©
  tyOf (Ï€â‚‚ (recSub Ïƒ))          â‰¡âŸ¨ tyOfÏ€â‚‚ (recSub Ïƒ) âŸ©
  (recTy A) [ Ï€â‚ (recSub Ïƒ) ]T  â‰¡âŸ¨âŸ©
  recTy (A S.[ S.Ï€â‚ Ïƒ ])        â‰¡âŸ¨âŸ©
  recTy (S.tyOf (S.Ï€â‚‚ Ïƒ))       â‰¡âŸ¨ cong recTy p âŸ©
  recTy B                       âˆ
\end{code}
The coherence conditions for |recTyOf| over equality constructors are trivial because of the UIP.

To introduce the elimination principle, we consider the notion of displayed algebras over |SC|-algebras |M|, as a parametric record |SCâˆ™|, and instantiate it to displayed algebras over the term algebra, i.e.\ the syntax.
Carriers of a displayed algebra as well as the semantics of |tyOf| are given below.
\begin{code}
record SCâˆ™ (M : SC) : Set where
  open SC M

  field
    Ctxâˆ™   : Ctx â†’ Set
    Tyâˆ™    : Ctxâˆ™ Î“ â†’ (HL(Ty Î“)) â†’ Set
    Tmâˆ™    : Ctxâˆ™ Î“ â†’ (HL(Tm Î“)) â†’ Set
    Subâˆ™   : Ctxâˆ™ Î“ â†’ Ctxâˆ™ Î” â†’ (HL(Sub Î“ Î”)) â†’ Set
    tyOfâˆ™  : Tmâˆ™  Î“âˆ™ t â†’ Tyâˆ™ Î“âˆ™ (HL((tyOf t)))
\end{code}
As motives are indexed by their underlying model, we will have equations over equations of the underlying model.
It is convenient to specialise dependent paths for them, e.g.,
\begin{code}
  _â‰¡Tm[_]_ : Tmâˆ™ Î“âˆ™ t â†’ t â‰¡ u â†’ Tmâˆ™ Î“âˆ™ u â†’ Type
  _â‰¡Tm[_]_ {Î“âˆ™ = Î“âˆ™} tâˆ™ e uâˆ™ =
    PathP (Î» i â†’ Tmâˆ™ Î“âˆ™ (HL((e i)))) tâˆ™ uâˆ™
\end{code}
The signature for |SCâˆ™|-algebras is similar to |SC|-algebras
The difference here is that each displayed operation is indexed by their underlying operation and thus equations become equations over equations.
\begin{code}
  field
    âˆ…âˆ™       : Ctxâˆ™ âˆ…
    _,âˆ™_     : Ctxâˆ™ Î“ â†’ Tyâˆ™ Î“âˆ™ A â†’ Ctxâˆ™ (Î“ ,C A)
    _[_]Tâˆ™   : Tyâˆ™ Î”âˆ™ A â†’ Subâˆ™ Î“âˆ™ Î”âˆ™ Ïƒ â†’ Tyâˆ™ Î“âˆ™ (A [ Ïƒ ]T)
    _[_]tâˆ™   : Tmâˆ™ Î”âˆ™ t â†’ Subâˆ™ Î“âˆ™ Î”âˆ™ Ïƒ â†’ Tmâˆ™ Î“âˆ™ (t [ Ïƒ ]t)
    tyOf[]âˆ™  : tyOfâˆ™ (tâˆ™ [ Ïƒâˆ™ ]tâˆ™)
      â‰¡Ty[ (HL(tyOf[])) ] (tyOfâˆ™ tâˆ™ [ Ïƒâˆ™ ]Tâˆ™)
    ...
    [idS]tâˆ™  : tâˆ™                    â‰¡Tm[ (HL([idS]t)) ]  tâˆ™ [ idSâˆ™ ]tâˆ™
    [âˆ˜]tâˆ™    : tâˆ™ [ Ï„âˆ™ ]tâˆ™ [ Ïƒâˆ™ ]tâˆ™  â‰¡Tm[ (HL([âˆ˜]t)) ]    tâˆ™ [ Ï„âˆ™ âˆ˜âˆ™ Ïƒâˆ™ ]tâˆ™
\end{code}
Note that if |[idS]t| in its QIIT definition is formulated with a dependent path, the equality proof in the middle of |_â‰¡Tm[_]_| has to be a dependent path.
As a result, we would have to specify two underlying equations as
\begin{code}
  tâˆ™ â‰¡Tm[ (HL([idS]T)) ][ (HL([idS]t)) ] tâˆ™ [ idSâˆ™ ]tâˆ™
\end{code}
and equational reasoning with them would involve three equations altogether.
It is nice that we do not have deal with this extra proof obligation in our formulation.

The term |SC|-algebra is defined rather routinely as each field is given by the corresponding constructor, except that the additional equality proof in, say, |Î²Ï€â‚‚| is replaced by an actual proof:
\begin{code}
Term : SC
Term = record
  { âˆ…       = S.âˆ…
  ; tyOf[]  = refl
  ...
  ; Î²Ï€â‚‚     = Î» {Î“} {Î”} {A} Ïƒ t p
    â†’ S.Î²Ï€â‚‚ Ïƒ t p (HL((cong (A [_]) (S.Î²Ï€â‚ Ïƒ t p) âˆ™ sym p))) }
\end{code}

By instantiating displayed algebras over the term algebra, the elimination principle is stated similarly to the recursion principle but indexed by the term algebra:
\begin{code}
elimCtx   : (Î“ :  S.Ctx)      â†’ Ctxâˆ™ Î“
elimTy    : (A :  S.Ty Î“)     â†’ Tyâˆ™ (elimCtx Î“) A
elimTm    : (t :  S.Tm Î“)     â†’ Tmâˆ™ (elimCtx Î“) t
elimSub   : (Ïƒ :  S.Sub Î“ Î”)  â†’ Subâˆ™ (elimCtx Î“) (elimCtx Î”) Ïƒ
elimTyOf  : (t :  S.Tm Î“) (p : S.tyOf t â‰¡ A)
  â†’  tyOfâˆ™ (elimTm t) â‰¡Ty[ (HL(p)) ] elimTy A
\end{code}

For the coherence conditions of elimination, it sometimes extra steps to reason about instead of using the corresponding displayed equation, so we need the transitivity for dependent paths:
\begin{code}
_âˆ™P_
  : {x' : B x}{y' : B y}{z' : B z}{p : x â‰¡ y}{q : y â‰¡ z}
  â†’ PathP (Î» i â†’ B (p i)) x' y' â†’ PathP (Î» i â†’ B (q i)) y' z'
  â†’ PathP (Î» i â†’ B ((HL((p âˆ™ q) i)))) x' z'
\end{code}
and also use UIP to identify the |p âˆ™ q| with the desired underlying equation. 
We extend the conventional syntax for equational reasoning with another equation for the index.
\LT[noinline]{Inspired by 1Lab}
For example, the coherence proof for |Î·Ï€| is given by
\begin{code}
elimSub (Î·Ï€ {Î“} {Î”} {A} Ïƒ i) = ((HL(beginSub[ Î·Ï€ ]))
  (elimSub Ïƒ
    â‰¡Sub[ (HL(Î·Ï€)) ]âŸ¨ (HL(Î·Ï€âˆ™ (elimSub Ïƒ))) âŸ©
  Ï€â‚âˆ™ (elimSub Ïƒ) , Ï€â‚‚âˆ™ (elimSub Ïƒ)
    âˆ¶[ refl , (HL(tyOfÏ€â‚‚âˆ™ (elimSub Ïƒ))) ]âˆ™
    â‰¡Sub[ (HL(refl)) ]âŸ¨ cong (Ï€â‚âˆ™ (elimSub Ïƒ) , Ï€â‚‚âˆ™ (elimSub Ïƒ)
      âˆ¶[ refl ,_]âˆ™) (HL(UIP)) âŸ©
  Ï€â‚âˆ™ (elimSub Ïƒ) , elimTm (Ï€â‚‚ Ïƒ)
    âˆ¶[ refl , (HL(elimTyOf (Ï€â‚‚ Ïƒ) refl)) ]âˆ™
    âˆ)) i
\end{code}
The transitivity of dependent paths gives us an equation over |Î·Ï€ âˆ™ refl | instead of |Î·Ï€|, so we use |beginSub[ Î·Ï€ ]_| to identify the underlying path |Î·Ï€ âˆ™ refl | with |Î·Ï€| by the UIP.


\subsection{Practical workarounds for mutual definitions}  \label{sec:tt:mutual}
So far, we have sketched how the recursion and elimination principles are defined \emph{ideally}.
Due the syntactic limitations of \Agda (and mysterious bugs), we employ some workarounds to implement the desired definitions.

\paragraph{Mutually interleaved QIITs} Constructors of QIITS cannot be interleaved~\cite{Agdaissue2021} even within an |interleaved mutual| block, since such a block is desugared to a set of forward declarations merely for the |data| types, not constructors.
Although in theory constructors declared within the same family of QIITs should be placed in the same context~\cite{Kaposi2019}, the desugaring results a definition that equality constructors may depend on other constructors which are not currently in the scope.

We resolve this issue by 
\begin{enumerate*}[label=(\roman*)]
  \item using forward declarations for \emph{the whole definition} of QIITs including constructors;
  \item introducing constructors of QIITs using these declarations if previously introduced constructors are referred;
  \item defining forward declarations by their corresponding constructors;
  \item finally, exposing only actual constructors without those forward declarations.
\end{enumerate*}
The following is a snippet of our actual formalisation in \CA:

\begin{code}
module S where
  data Ctx  : Set
  data Sub  : (Î“ Î” : Ctx) â†’ Set
  data Ty   : Ctx â†’ Set
  data Tm   : (Î“ : Ctx) â†’ Set
  tyOf      : âˆ€ {Î“} â†’ Tm Î“ â†’ Ty Î“

  âˆ…    : Ctx
  _,_  : (Î“ : Ctx)(A : Ty Î“) â†’ Ctx
  ...
  data Ctx where
    âˆ…'    : Ctx 
    _,'_  : (Î“ : Ctx) (A : Ty Î“) â†’ Ctx

  âˆ…       = âˆ…'
  _,_     = _,'_
  ...
open S public
  hiding ( âˆ… ; _,_; ...)
  renaming ( âˆ…' to âˆ… ; _,'_ to _,_; ...)
\end{code}
We suspect this syntactic translation from QIITs in theory to actual definitions in \CA should suffice to allow mutually interleaved QIITs.

\paragraph{Mutual interleaved QIIRTs}
Interleaving function clauses with inductive types is different, since we cannot declare a function clause with their computational behaviour.
However, as we have `Forded' the typing constraints as equality proofs, we only need to know there is an equality proof when introducing constructors without knowing its computational behaviour.
So, we declare that there is such an equality proof before its usage, define |tyOf| after the end of datatype declarations, and later give the actual definition of the forward declaration.
For example, the equality constructor |Î·Ï€| requires a proof |tyOf (Ï€â‚‚ Ïƒ) â‰¡ A [ Ï€â‚ Ïƒ ]|, so we simply declare one without a definition:
\begin{code}
tyOfÏ€â‚‚  : tyOf (Ï€â‚‚ Ïƒ) â‰¡ A [ Ï€â‚ Ïƒ ]
Î·Ï€      : Ïƒ â‰¡ (Ï€â‚ Ïƒ , Ï€â‚‚ Ïƒ âˆ¶[ tyOfÏ€â‚‚ ])
\end{code}
Then, define |tyOf| after the datatype declaration and |tyOfÏ€â‚‚| after the function |tyOf| is defined: 
\begin{code}
tyOf (Ï€â‚‚' {Î“} {Î”} {A} {Ïƒ}) = A [ Ï€â‚ {A = A} Ïƒ ]
...
tyOfÏ€â‚‚ = refl
\end{code}
This translation works if the computational behaviour of interleaved function clauses is not required.\footnote{We suspect that a general scheme of QIIRTs may allow mutually interleaving inductive types with function clauses, by extending the type theory of QIITs~\cite{Kaposi2019} with another identity type for function clauses.}

\paragraph{Mutually-defined functions}
\LT[noinline]{Agda issue?}
Constructors of our QIITs and QIIRTs need to be (truly) mutually interleaved, so are their recursion and elimination principles in general.
Yet, \Agda does not allow us to interleave clauses of different functions directly.
We can use forward declarations and carry out the coercion along the equality proof.

Another approach is to define a family of functions indexed by a set of tags.
For example, the recursion principle can be implemented with |Tag| for the recursion on each inductive type with the forward declarations
\begin{code}
data Tag : Set where
  ctx ty sub tm tyof : Tag

recCtx   : S.Ctx â†’ Ctx
recTy    : S.Ty Î“ â†’ Ty (recCtx Î“)
recTm    : S.Tm Î“ â†’ Tm (recCtx Î“)
recSub   : S.Sub Î“ Î” â†’ Sub (recCtx Î“) (recCtx Î”)
recTyOf  : (t : S.Tm Î“) â†’ S.tyOf t â‰¡ A
  â†’ tyOf (recTm t) â‰¡ recTy A
\end{code}
and define their definitions uniformly as |rec| with |tyOfRec| computing the corresponding type:
\begin{code}
tyOfRec : Tag â†’ Set â„“
rec : (t : Tag) â†’ tyOfRec t

tyOfRec ctx   = S.Ctx â†’ Ctx
tyOfRec ty    = âˆ€ {Î“ : S.Ctx} â†’ S.Ty Î“ â†’ Ty (recCtx Î“)
tyOfRec tm    = {Î“ : S.Ctx} â†’ S.Tm Î“ â†’ Tm (recCtx Î“)
tyOfRec sub   = {Î“ Î” : S.Ctx} â†’ S.Sub Î“ Î”
  â†’ Sub (recCtx Î“) (recCtx Î”)
tyOfRec tyof  = {Î“ : S.Ctx} â†’ {A : S.Ty Î“} â†’ (t : S.Tm Î“)
  â†’ S.tyOf t â‰¡ A â†’ tyOf (recTm t) â‰¡ recTy A
\end{code}
Then, define each recursion on an inductive type as a synonym of |rec| for each tag:
\begin{code}
recCtx   = rec ctx
recSub   = rec sub
recTy    = rec ty
recTm    = rec tm
recTyOf  = rec tyof 
\end{code}
followed by their actual definitions.
At the time of writing, some terms in the development of the recursion principle that are supposed to be strictly equal by definition are not in \CA , even though its function clause appears before the point of type checking.
We resort to forward declarations and carry out the computation manually using the path type.
We are still investigating the root cause of this mysterious behaviour.

\section{Metatheory}
\label{sec:strictify}
\subsection{Strictification}

% LTC (Tue 9 Sep)
% \input{meta.agda.tex}

\label{sec:standard-model}
\label{sec:nbe}


\section{Comparison with other approaches}
\label{sec:compare}
% FNF (Tue 9 Sep)

Compared to QIIT:

\begin{itemize}
\item Fewer transports in the syntax, but they tend to come back in concrete models
\item Strictification orthogonal

Even the strictification technique~\cite{Kaposi2025}, which turn most of equality constructors about substitution to strict equalities, cannot help, as it can only be applied \emph{after} the inductive types are defined.

Moreover, strictification only address substitution rules and does not help us other issues such as equations over equations over equations for the universe of types.

\end{itemize}

Compared to untyped version:
\begin{itemize}
\item Untyped version might still be easiest to work with, with current proof assistant technology
\end{itemize}

\section{Discussion}
% LTC (at first)

\begin{itemize}
  \item General translation from QIIT to QIIRT: Fordism translation and the index elimination
(theory of ornaments~\cite{Ko2016,Dagand2017})

  \item Practical considerations (eg NBE computes, support for interleaved mutual definitions)
  \item Eliminating indices entirely in a metatheory with definitional UIP (e.g., XTT~\cite{Sterling2022}) should work fine without a strict prop.

  \item Safety guarantees from proof assistant (e.g. strict positivity check, termination check, coverage check)
  \item Easier in OTT-based proof assistant
\end{itemize}

\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}
%\bibliography{ref}

\end{document}


%\begin{acks}
%To Robert, for the bagels and explaining CMYK and color spaces.
%\end{acks}

%%% Local Variables:
%%% mode: latex
%%% End:
