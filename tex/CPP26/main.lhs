\documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}

%%% Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{mathtools}
\let\Bbbk\relax
\usepackage{amsmath,amssymb,mathbbol}
\let\Bbbk\relax
\usepackage{bbold}

%% Remove the following if there are no todo items.
\setlength {\marginparwidth }{2cm}
\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage{cleveref}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},color={pink},#1]{#2}}
\newcommand{\Fredrik}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}

\usepackage{microtype}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Macros %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\CA}{\textsc{Cubical Agda}\xspace}
\newcommand{\Agda}{\textsc{Agda}\xspace}
\newcommand{\Set}{\mathbf{Set}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{newunicodechar}

%%% lhs2tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cons}[1]{\mathbf{#1}}
\newcommand{\iden}{\mathit}

\newcommand{\awa}[2]{\mathrlap{#2}\phantom{#1}} % as wide as

\definecolor{addition}{RGB}{204,255,216}
\newcommand{\highlight}[2]{\smash{\text{\colorbox{#1}{\kern-.1em\vphantom{\vrule height 1.2ex depth 0.1ex}\smash{\ensuremath{#2}}\kern-.1em}}}}

%include agda.fmt

%% end of the preamble, start of the body of the document source.

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Can natural models simplify the metatheory of type theory in Cubical Agda?}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Liang-Ting Chen}
\affiliation{%
  \institution{Institute of Information Science, Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
\email{liangtingchen@@as.edu.tw}

\author{Fredrik Nordvall Forsberg}
\affiliation{%
  \institution{Department of Computer and Information Sciences, University of Strathclyde}
  \city{Glasgow}
  \country{United Kingdom}}

\author{Tzu-Chun Tsai}
\affiliation{%
  \institution{Institute of Information Science, Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
%\affiliation{%
%  \institution{Institute for Logic, Language and Computation, University of Amsterdam}
%  \city{Amsterdam}
%  \country{Netherlands}}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}

  We report a folklore approach to formalising type theory in type theory, using Awodey's \emph{natural model} of type theory.
  The initial natural model is represented as strictly positive quotient inductive-inductive-recursive types in the proof assistant \CA, leading us to a syntax without any `transport hell'.
We formalise some meta-properties such as the standard % and logical predicate
interpretation, normalisation by evaluation for typed terms, and strictification constructions.
Since our formalisation is carried out using \CA's built-in support for quotient inductive types, all our constructions compute.
However, the transport hell reappears when developing more sophisticated metatheory.
Hence it is still a considerable struggle to develop the metatheory of type theory using intrinsic representation in a metatheory without strict proposition and strictification (or custom rewrite rules), and the effort is about the same using natural models or not.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}

\keywords{Proof Assistants, Formalisation, Cubical Agda, Quotient Inductive-Inductive-Recursive Type}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\maketitle
\bibliographystyle{ACM-Reference-Format}

\section{Introduction}
% FNF (Fri 5 Sep)

Transport hell = transports appear inside terms that you actually want to study, hence you need to do a lot of reasoning about transport rather than the actual objects of interest.

\LT{I think the main contribution of our work is an attempt to formalise type theory as a strictly positive QIT and in a metatheory without strict prop; this definition could be used in conjunction with stratification in other setting (such as OTT) with a proper QIT support.}
\LT{the idea of using natural model appears at least in 2024 \cite{Bense2024}, and it is a natural idea to formalise type theory in this way.}
\section{Setting and metatheory}
% FNF (Sun 7 Sep)

Cubical Agda with UIP

QIIRTs

\LT{We give mutual definition modulo forward declarations and we will explain the trick in \Cref{sec:tt:workaround}.}

\section{Type theory as a natural model} \label{sec:tt}
It is well-known that type theory can be represented intrinsically as quotient inductive-inductive types~\cite{Altenkirch2016a}, whereas each judgement in type theory is defined as an inductive type, each typing rule a constructor, and each computational rule an equality constructor, simultaneously.
Therefore, inhabitants consist of only valid derivations in type theory.
However quotient inductive types were not supported by \Agda at that time, so Licata's trick~\cite{Licata2011} was used, giving up lots of supports from the proof assistant.

Now, as \CA is equipped with the support of quotient inductive-inductive(-recursive) types, it is natural to ask if we can finally define type theory as QIITs in a proof assistant backed by its support for inductive types.
Hence, we start with their definition~\cite{Altenkirch2016a} as follows.
\begin{code}
data Ctx : Set
data Sub : (Γ Δ  : Ctx)  → Set
data Ty  : (Γ    : Ctx)  → Set
data Tm  : (Γ    : Ctx)  → Ty Γ → Set
data _ where
  ∅     : Ctx
  _,_   : (Γ : Ctx)(A : Ty Γ) → Ctx
  _[_]  : (A : Ty Δ)(σ : Sub Γ Δ) → Ty Γ
  _[_]  : (t : Tm Δ A)(σ : Sub Γ Δ) → Tm Γ (A [ σ ]T)
  _∘_   : Sub Δ Θ → Sub Γ Δ → Sub Γ Θ
  _,_   : (σ : Sub Γ Δ)(t : Tm Γ (A [ σ ]T))
        → Sub Γ (Δ , A)
        
  [∘]   : (A : Ty Θ)(σ : Sub Γ Δ)(τ : Sub Δ Θ)
        → A [ τ ] [ σ ] ≡ A [ τ ∘ σ ]
\end{code}
Note that |_∘_| is a constructor for substitution composition and the second |_,_| a constructor for extending a substitution |σ| with a term |t| of type |A [ σ ]|.
When we introduce the corresponding rule for the interaction between |_∘_| and |_,_| we will need a transport to fix a type mismatch and thus a transport hell inevitably:
\begin{code}
  ,∘   : (σ : Sub Δ Θ) (t : Tm Δ (A [ σ ]T)) (τ : Sub Γ Δ)
       → (σ , t) ∘ τ ≡ (σ ∘ τ , 
            subst (Tm Γ) ([∘] A τ σ) (t [ τ ]t))
\end{code}
since the type of |t [ τ ]| is |(A [ σ ]) [ τ ]| instead of |A [ σ ∘ τ ]| as required.
However, as |Tm| appears as an argument of |subst|, the use of transport breaks the strict positivity check!
Moreover, there are more such instances, once we introduce other type formers such as $\Pi$-types and the type |El| of elements.
That is, the transport hell, which is bad for reasoning, can also appears in the definition of inductive types and breaks strict positivity.
Of course, one could give up the safety guarantee provided by a proof assistant but that would make the formalisation less trustable.

Another use of transports for equations over equations formulated in \cite{Altenkirch2016a} can be avoided by using dependent path.
For example, that fact that the identity term substitution is an identity can be introduced as an equality constructor |[idS]t| over the equality constructor |[idS]| for the identity type substitution:
\begin{code}
[idS]   : A ≡ A [ idS ]
[idS]t  : PathP (λ i → Tm Γ ([idS] i)) t (t [ idS ])
\end{code}
While equations over equations are more manageable, they will become `equations over equations that are yet over another equations' in its elimination rule, so it is still nice to avoid them if it does not make formalisation harder.
We will return to this point in \Cref{sec:tt:elim}.

\subsection{Terms without types as indices} \label{sec:tt:terms-without-indices}
To avoid the transport hell in the definition of type theory itself, we observe that the problem is the mismatch of indices |A| of |Tm Γ A| and the fact that many equality constructors for types that will be soon used later in the definition itself.
As we expect to often give an explicit proof for the typing constrain that term |t| in the substitution |(σ , t)| is of type |A [ σ ]T| when it cannot be checked definitionally, enforcing this constrain in the index of |Tm| just shoots ourselves in the foot. 
Therefore, we apply `Fordism' transformation: \LT{citation?}
\begin{code}
_,_∶[_] : (σ : Sub Γ Δ) (t : Tm Γ B) (t : B ≡ A [ σ ])
\end{code}
to move the typing constrain from the index to its argument as an equality proof.
Then, the equality constructor |,∘| becomes accordingly
\begin{code}
,∘ : (σ , t ∶[ p ]) ∘ τ ≡ (σ ∘ τ , t [ τ ]
        ∶[ cong _[ τ ] p ∙ ([∘]T A τ σ) ])
\end{code}
where |_∙_| is the transitivity of equality proofs.
Although no transport is needed in this definition, the use of |cong| and |_∙_|
still prevent the definition from being strictly positive.
This problem can be overcome by asking for another equality proof as an argument, so we derive the following definition
\begin{code}
,∘ : (σ : Sub Δ Θ) (t : Tm Δ B) (τ : Sub Γ Δ)
   → (p : B ≡ A [ σ ]) (q : B [ τ ] ≡ A [ σ ∘ τ ])
   → (σ , t ∶[ p ]) ∘ τ ≡ ((σ ∘ τ) , t [ τ ] ∶[ q ])
\end{code}

As we have applied the Fordism transformation, the index |A| in |Tm Γ A| alone do not enforce the typing constrain on terms, so we may radically remove this index completely and only ask for it when necessary.
That is, we introduce an additional function defined simultaneously:
\begin{code}
tyOf : Tm Γ → Ty Γ
\end{code}
so the constructor |,∘| becomes
\begin{code}
,∘ : (σ : Sub Δ Θ) (t : Tm Δ) (τ : Sub Γ Δ)
   → (p : tyOf t ≡ A [ σ ]) (q : tyOf t [ τ ] ≡ A [ σ ∘ τ ])
   → (σ , t ∶[ p ]) ∘ τ ≡ ((σ ∘ τ) , t [ τ ] ∶[ q ])
\end{code}

As a by-product, we also eliminate the use of dependent paths in its definition, since equations are only over equations between types.
For example, the equality constructor for the identity term substitution becomes
\begin{code}
  [idS]t  : t ≡ t [ idS ]
\end{code}
as we need not know \emph{a prior} if their types are equal or not. 

\subsection{Syntax of substitution calculus as an initial natural model using QIIRT}
Adapting those changes described in \Cref{sec:tt:terms-without-indices}, we spell out the substitution calculus part of type theory. 
Similar to the definition in \cite{Altenkirch2016a}, we define following types and a function:
\begin{code}
data Ctx  :  Set
data Sub  :  (Γ Δ : Ctx) → Set
data Ty   :  Ctx → Set
data Tm   :  (Γ : Ctx) → Set
tyOf : Tm Γ → Ty Γ
\end{code}
simultaneously, as quotient inductive-inductive-recursive types.
Constructors for typing rules are mostly the same:
\begin{code}
∅        : Ctx
_,_      : (Γ : Ctx)(A : Ty Γ) → Ctx
_[_]T    : (A : Ty Δ)(σ : Sub Γ Δ) → Ty Γ
_[_]t    : (A : Tm Δ)(σ : Sub Γ Δ) → Tm Γ
∅        : Sub Γ ∅
idS      : Sub Γ Γ
_∘_      : Sub Δ Θ → Sub Γ Δ → Sub Γ Θ
π₁       : Sub Γ (Δ , A) → Sub Γ Δ
π₂       : Sub Γ (Δ , A) → Tm Γ
_,_∶[_]  : (σ : Sub Γ Δ) (t : Tm Γ)
  → tyOf t ≡ A [ σ ]T → Sub Γ (Δ , A)

idS∘_   : (σ : Sub Γ Δ) → idS ∘ σ ≡ σ
_∘idS   : (σ : Sub Γ Δ) → σ ∘ idS ≡ σ
assocS  : (σ : Sub Γ Δ) (τ : Sub Δ Θ) (γ : Sub Θ Ξ)
       → (γ ∘ τ) ∘ σ ≡ γ ∘ (τ ∘ σ)
,∘ : (σ : Sub Δ Θ) (t : Tm Δ) (τ : Sub Γ Δ)
    (p : tyOf t ≡ A [ σ ]T)
    (q : tyOf (t [ τ ]t) ≡ A [ σ ∘ τ ]T)
  → (σ , t ∶[ p ]) ∘ τ ≡ (σ ∘ τ , t [ τ ]t ∶[ q ])
ηπ   : (σ : Sub Γ (Δ , A)) → σ ≡ (π₁ σ , π₂ σ ∶[ refl ])
η∅   : (σ : Sub Γ ∅) → σ ≡ ∅S
βπ₁  : (σ : Sub Γ Δ) (t : Tm Γ) (p : tyOf t ≡ A [ σ ]T)
     → π₁ (σ , t ∶[ p ]) ≡ σ
βπ₂  : (σ : Sub Γ Δ) (t : Tm Γ) (p : tyOf t ≡ A [ σ ]T)
     → (q : A [ π₁ (σ , t ∶[ p ]) ]T ≡ tyOf t)
     → π₂ (σ , t ∶[ p ]) ≡ t
[idS]T  : A ≡ A [ idS ]
[∘]T    : (A : Ty Θ) (σ : Sub Γ Δ) (τ : Sub Δ Θ)
  → A [ τ ] [ σ ] ≡ A [ τ ∘ σ ]
[idS]t  : (t : Tm Γ) → t ≡ t [ idS ]
[∘]t    : (t : Tm Θ) (σ : Sub Γ Δ) (τ : Sub Δ Θ)
  → t [ τ ] [ σ ] ≡ t [ τ ∘ σ ]

tyOf (t [ σ ])        = (tyOf t) [ σ ]
tyOf (π₂ {A = A} σ)   = A [ π₁ σ ]
tyOf (βπ₂ σ t p q i)  = q i
tyOf ([idS]t t i)     = [idS]T {A = tyOf t} i
tyOf ([∘]t t σ τ i)   = [∘]T (tyOf t) σ τ i
\end{code}

Changing the type |A : Ty| as an index of |Tm| to a function |tyOf : Tm Γ → Ty Γ| is similar to Awody's notion of \emph{natural model}~\cite{Awodey2018} where the sets of terms and of types are represented as presheaves $\mathsf{Tm}, \mathsf{Ty} \colon \mathbb{C} \to \Set$ over the category of contexts $\mathbb{C}$ and connected by a natural transformation $\mathsf{Tm} \to \mathsf{Ty}$ stable under pullbacks (i.e.\ substitution).

\subsection{Syntax of type theory as an initial model using QIIRT}


\subsection{Recursion and elimination principles} \label{sec:tt:elim}

\subsection{Strictification}

\subsection{Some workarounds}  \label{sec:tt:workaround}
\section{Metatheory}
% LTC (Tue 9 Sep)
% \input{meta.agda.tex}



\section{Comparison with other approaches}
% FNF (Tue 9 Sep)

Compared to QIIT:

\begin{itemize}
\item Fewer transports in the syntax, but they tend to come back in concrete models
\item Strictification orthogonal

Even the strictification technique~\cite{Kaposi2025}, which turn most of equality constructors about substitution to strict equalities, cannot help, as it can only be applied \emph{after} the inductive types are defined.
\end{itemize}

Compared to untyped version:
\begin{itemize}
\item Untyped version might still be easiest to work with, with current proof assistant technology
\end{itemize}

\section{Discussion}
% LTC (at first)

Practical considerations (eg NBE computes, support for interleaved mutual definitions)

Safety guarantees from proof assistant (e.g. strict positivity check, termination check, coverage check)

Easier in OTT-based proof assistant

\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}
%\bibliography{ref}

\end{document}


%\begin{acks}
%To Robert, for the bagels and explaining CMYK and color spaces.
%\end{acks}
