\documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\setcopyright{acmlicensed}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation email}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/2018/06}

%%% Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{mathtools}
\let\Bbbk\relax
\usepackage{amsmath,amssymb,mathbbol}
\let\Bbbk\relax
\usepackage{bbold}

%% Remove the following if there are no todo items.
\setlength {\marginparwidth }{2cm}
\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage{cleveref}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},color={pink},#1]{#2}}
\newcommand{\Fredrik}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}

\usepackage{microtype}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Macros %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\CA}{\textsc{Cubical Agda}\xspace}
\newcommand{\Agda}{\textsc{Agda}\xspace}
\newcommand{\Set}{\mathbf{Set}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{newunicodechar}

%%% lhs2tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cons}[1]{\mathbf{#1}}
\newcommand{\iden}{\mathit}

\newcommand{\awa}[2]{\mathrlap{#2}\phantom{#1}} % as wide as

\definecolor{addition}{RGB}{204,255,216}
\newcommand{\highlight}[2]{\smash{\text{\colorbox{#1}{\kern-.1em\vphantom{\vrule height 1.2ex depth 0.1ex}\smash{\ensuremath{#2}}\kern-.1em}}}}

%include agda.fmt

%% end of the preamble, start of the body of the document source.

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Can natural models simplify the metatheory of type theory in Cubical Agda?}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Liang-Ting Chen}
\affiliation{%
  \institution{Institute of Information Science, Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
\email{liangtingchen@@as.edu.tw}

\author{Fredrik Nordvall Forsberg}
\affiliation{%
  \institution{Department of Computer and Information Sciences, University of Strathclyde}
  \city{Glasgow}
  \country{United Kingdom}}

\author{Tzu-Chun Tsai}
\affiliation{%
  \institution{Institute of Information Science, Academia Sinica}
  \city{Taipei}
  \country{Taiwan}}
%\affiliation{%
%  \institution{Institute for Logic, Language and Computation, University of Amsterdam}
%  \city{Amsterdam}
%  \country{Netherlands}}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
%\renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}

  We report the folklore approach to formalising type theory in type theory, using Awodey's \emph{natural model} of type theory.
  The initial natural model is represented as strictly positive quotient inductive-inductive-recursive types in the proof assistant \CA, leading us to a syntax without any `transport hell'.
We formalise some meta-properties such as the standard % and logical predicate
interpretation, normalisation by evaluation for typed terms, and strictification constructions.
Since our formalisation is carried out using \CA's native support for quotient inductive types, all our constructions compute at a reasonable speed.

However, the `transport hell' problem reappears when we try to develop more sophisticated metatheory.
Ultimately, it remains a considerable struggle to develop the metatheory of type theory using an intrinsic representation that lacks strict equations.
The effort required is about the same whether or not the notion of natural model is used.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}

\keywords{Proof Assistants, Formalisation, Cubical Agda, Quotient Inductive-Inductive-Recursive Type}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\maketitle
\bibliographystyle{ACM-Reference-Format}

\section{Introduction}
% FNF (Fri 5 Sep)

Transport hell = transports appear inside terms that you actually want to study, hence you need to do a lot of reasoning about transport rather than the actual objects of interest.

\LT{I think the main contribution of our work is an attempt to apply the Fordism transformation and the index elimination to the QIIT of type theory and derive a strictly positive QIIRT; this definition could be used in conjunction with stratification in other setting (such as OTT) with a proper QIT support.}
\LT{the idea of using natural model appears at least in 2024 \cite{Bense2024}, and it is a natural idea to formalise type theory in this way.}
\section{Setting and metatheory}
% FNF (Sun 7 Sep)

Cubical Agda with UIP

QIIRTs

\LT{We give mutual definition modulo forward declarations and we will explain the trick in \Cref{sec:tt:mutual}.}
\LT{We should give a simple example of QIRT here}

\section{Type theory as a natural model} \label{sec:tt}
It is well-known that type theory can be represented intrinsically as quotient inductive-inductive types~\cite{Altenkirch2016a}.
In this representation, each judgement in type theory is defined as an inductive type, each typing rule as a constructor, and each term/type equality as an equality constructor.
This means that the inhabitants of these types are only valid derivations in type theory.
Previously, \Agda did not support quotient inductive types, so a workaround known as `Licata's trick'~\cite{Licata2011} was used, which meant giving up many features of the proof assistant.

With \CA now equipped with support for quotient inductive-inductive types, it's a natural question to ask if we can use this built-in support to define type theory.
We begin with the CwF-based definition~\cite{Altenkirch2016a} as follows.
(For brevity we have made arguments implicit for equality constructors, whereas they are actually explicit in our formalisation.)
\begin{code}
data Ctx : Set
data Sub : (Γ Δ  : Ctx)  → Set
data Ty  : (Γ    : Ctx)  → Set
data Tm  : (Γ    : Ctx)  → Ty Γ → Set
data _ where
  ∅     : Ctx
  _,_   : (Γ : Ctx)(A : Ty Γ) → Ctx
  _[_]  : (A : Ty Δ)(σ : Sub Γ Δ) → Ty Γ
  _[_]  : (t : Tm Δ A)(σ : Sub Γ Δ) → Tm Γ (A [ σ ]T)
  _∘_   : Sub Δ Θ → Sub Γ Δ → Sub Γ Θ
  _,_   : (σ : Sub Γ Δ)(t : Tm Γ (A [ σ ]T))
        → Sub Γ (Δ , A)
  [∘]   : A [ τ ] [ σ ] ≡ A [ τ ∘ σ ]
  ...
\end{code}
Here, |_∘_| is the constructor for substitution composition, and the second |_,_| is the constructor for extending a substitution |σ| with a term |t| of type |A [ σ ]|.
When formulating the corresponding rule for the interaction between |_∘_| and |_,_|, we encounter a type mismatch that must be resolved by transport, leading to the well-known \emph{transport hell}:  
\begin{code}
  ,∘   : (σ : Sub Δ Θ) (t : Tm Δ (A [ σ ]T)) (τ : Sub Γ Δ)
       → (σ , t) ∘ τ ≡ (σ ∘ τ , 
            subst (Tm Γ) ([∘] A τ σ) (t [ τ ]t))
\end{code}
The issue is that the type of |t [ τ ]| is |(A [ σ ]) [ τ ]| rather than the required |A [ σ ∘ τ ]|.
Moreover, since |Tm| appears as an argument to |subst|, the use of transport violates the strict positivity check.  
In other words, the transport hell is not only an obstacle for reasoning but also arises within inductive definitions themselves, breaking strict positivity.  
The situation worsens once additional type formers are introduced---such as $\Pi$-types and the type |El| of elements~\cite{Altenkirch2016a}---since each brings further instances of this problem.  

On the other hand, another source of transports arises from equations over equations.
This can be avoided by using dependent paths.
For example, the fact that the identity term substitution really acts as an identity is introduced as an equality constructor |[idS]t|, defined over the equality constructor |[idS]| for the identity type substitution:  
\begin{code}
[idS]T : A ≡ A [ idS ]
[idS]t : PathP (λ i → Tm Γ ([idS]T i)) t (t [ idS ])
\end{code}
Although equations over equations are in principle more manageable, it quickly leads us to \emph{equations over equations over yet more equations} in their elimination rules.  
Thus, it is preferable to avoid them if possible, provided that doing so does not make the formalisation more difficult.  
We will return to this point in \Cref{sec:tt:elim}.

Of course, one could bypass these difficulties by turning off the strict positivity checker enforced by the proof assistant, but doing so would undermine the trustworthiness of the formalisation.

\subsection{Fordism and the index elimination} \label{sec:tt:terms-without-indices}
To avoid the transport hell in the definition of type theory itself, we note that the index |A| of |Tm Γ A| is rigid under operations on types, such as substitutions.
Since we often need to provide an explicit proof of the typing constraint that the term |t| in the substitution |(σ
, t)| has type |A [ σ ]| whenever this cannot be checked definitionally, enforcing this constraint in the index of |Tm| just shoots ourselves in the foot. 
Therefore, we apply `Fordism' transformation~\cite{McBride1999}:
\begin{code}
_,_∶[_] : (σ : Sub Γ Δ) (t : Tm Γ B) (t : B ≡ A [ σ ])
\end{code}
changing the constraint on the index to its argument as an equality proof.
Then, the constructor |,∘| becomes accordingly
\begin{code}
,∘ : (σ , t ∶[ p ]) ∘ τ ≡ (σ ∘ τ , t [ τ ]
        ∶[ cong _[ τ ] p ∙ ([∘]T A τ σ) ])
\end{code}
where |_∙_| is the transitivity of equality.
Although no transport is needed in this definition, the use of |cong| and |_∙_|
still prevent the definition from being strictly positive.
Similar to Fordism transformation, this problem can be overcome by asking for another equality proof as an argument:
\begin{code}
,∘ : (σ : Sub Δ Θ) (t : Tm Δ B) (τ : Sub Γ Δ)
   → (p : B ≡ A [ σ ]) (q : B [ τ ] ≡ A [ σ ∘ τ ])
   → (σ , t ∶[ p ]) ∘ τ ≡ ((σ ∘ τ) , t [ τ ] ∶[ q ])
\end{code}
As we assume UIP, the additional argument is essentially unique, so this updated constructor does not require any information but only defers the proof obligation.
This redundant argument can be removed later when defining its eliminator (\Cref{sec:tt:elim}).

Once the Fordism transformation has been applied, the index |B| of |t : Tm Γ B| no longer plays the role of enforcing typing constraints.
This opens the door to a simpler design: instead of carrying the index around, we can apply the transformation uniformly to all term constructors and remove the index entirely.
To preserve the necessary typing information, we simultaneously introduce an auxiliary function |tyOf : Tm Γ → Ty Γ| that records it explicitly.
In the end, the constructor |,∘| becomes
\begin{code}
,∘ : (σ : Sub Δ Θ) (t : Tm Δ) (τ : Sub Γ Δ)
   → (p : tyOf t ≡ A [ σ ]) (q : tyOf t [ τ ] ≡ A [ σ ∘ τ ])
   → (σ , t ∶[ p ]) ∘ τ ≡ ((σ ∘ τ) , t [ τ ] ∶[ q ])
\end{code}

As a side effect, this approach also removes the need for dependent paths in the definition.
Two terms can now be compared even when it is not known in advance whether their types are equal.
For instance, the equality constructor for the identity substitution becomes
\begin{code}
  [idS]t  : t ≡ t [ idS ]
\end{code}
where the fact that |t| and |t [ idS ]| share the same type follows from their term equality, rather than being imposed as a \emph{requirement}.

\subsection{Substitution calculus using QIIRT}
Building on the changes described in \Cref{sec:tt:terms-without-indices}, we now spell out the substitution calculus of type theory.
We define the following types together with a recursive function, simultaneously:
\begin{code}
data Ctx  :  Set
data Sub  :  (Γ Δ  : Ctx) → Set
data Ty   :  (Γ    : Ctx) → Set
data Tm   :  (Γ    : Ctx) → Set
tyOf : Tm Γ → Ty Γ
\end{code}
as quotient inductive-inductive-recursive types.
We similarly introduce constructors for typing rules and type/term equalities as follows.
\begin{code}
data _ where
  ∅        : Ctx
  _,_      : (Γ : Ctx)(A : Ty Γ) → Ctx
  _[_]     : (A : Ty Δ)(σ : Sub Γ Δ) → Ty Γ
  _[_]     : (A : Tm Δ)(σ : Sub Γ Δ) → Tm Γ
  ∅        : Sub Γ ∅
  _,_∶[_]  : (σ : Sub Γ Δ) (t : Tm Γ) (pt : tyOf t ≡ A [ σ ])
    → Sub Γ (Δ , A)
  idS      : Sub Γ Γ
  _∘_      : Sub Δ Θ → Sub Γ Δ → Sub Γ Θ
  π₁       : Sub Γ (Δ , A) → Sub Γ Δ
  π₂       : Sub Γ (Δ , A) → Tm Γ
  idS∘_    : idS ∘ σ ≡ σ
  _∘idS    : σ ∘ idS ≡ σ
  assocS   : (γ ∘ τ) ∘ σ ≡ γ ∘ (τ ∘ σ)
  [idS]T   : A  ≡  A  [ idS ]
  [idS]t   : t  ≡  t  [ idS ]
  [∘]T     : A  [ τ ]  [ σ ]  ≡ A  [ τ ∘ σ ]
  [∘]t     : t  [ τ ]  [ σ ]  ≡ t  [ τ ∘ σ ]
  ,∘ : (p : tyOf t ≡ A [ σ ])(q : tyOf (t [ τ ]) ≡ A [ σ ∘ τ ])
    → (σ , t ∶[ p ]) ∘ τ ≡ (σ ∘ τ , t [ τ ] ∶[ q ])
\end{code}
... except that we have to interleave the function clauses of |tyOf| with constructors.
For example, we have to give the function clause for |π₂ σ| before the $\eta$-law for substitution:
\begin{code}
tyOf (π₂ {A = A} σ)   = A [ π₁ σ ]
data _ where
  ηπ : σ ≡ (π₁ σ , π₂ σ ∶[ refl ])
\end{code}
Otherwise, the proof obligation |tyOf (π₂ σ) ≡ A [ π₁ σ ]| on the right hand side of |ηπ| cannot be fulfilled definitionally by |refl|.
We proceed with other equality constructors:
\begin{code}
data _ where
  η∅       : σ ≡ ∅S
  βπ₁      : π₁ (σ , t ∶[ p ]) ≡ σ
  βπ₂      : (q : A [ π₁ (σ , t ∶[ p ]) ]T ≡ tyOf t)
           → π₂ (σ , t ∶[ p ]) ≡ t
\end{code}
Note that |βπ₂| has an additional derivable equality proof.
This argument is needed as the coherence condition for
\begin{code}
tyOf (βπ₂ σ t p q i)  = q i
\end{code}
since again using any other function in the definition breaks the strict positivity check. 
The rest of clauses of |tyOf| can be given rather trivially
\begin{code}
tyOf (t [ σ ])        = (tyOf t) [ σ ]
tyOf ([idS]t t i)     = [idS]T i
tyOf ([∘]t t σ τ i)   = [∘]T i
\end{code}
This definition of type theory is accepted by \CA\footnote{At the time of writing, \CA does not support interleaved mutual definitions, but it can be equivalently defined using forward declarations.
We will discuss this idiom briefly in \Cref{sec:tt:mutual}.}
without any complains. 
Although |Tm| is only indexed by |Γ : Ctx|, the function |tyOf| ensures that every term has a type.
Hence, |Tm Γ| consists of only valid derivations and is still an intrinsic representation of type theory.

Replacing the index |A : Ty| of |Tm| with a function |tyOf : Tm Γ → Ty Γ| aligns with Awody's notion of \emph{natural model}~\cite{Awodey2018} where the collections of terms and types are represented as presheaves $\mathsf{Tm}, \mathsf{Ty} \colon \mathbb{C} \to \Set$ over the category of contexts $\mathbb{C}$ and connected by a natural transformation $\mathsf{Tm} \to \mathsf{Ty}$ stable under pullbacks (i.e.\ substitution).
That is, we have just defined the initial natural model using QIIRT in \CA.
This coincidence situates our family of inductive types and their algebras within a well-studied categorical models for type theory.

\subsection{Type theory with the $\Pi$-type}

We proceed with the introduction of the $\Pi$-type, but first we have to define the lifting of a substitution by a type:
\begin{code}
_↑_ : (σ : Sub Γ Δ) (A : Ty Δ)
  → Sub (Γ , A [ σ ]T) (Δ , A)
σ ↑ A = σ ∘ wk , vz ∶[ refl ]
\end{code}
where |wk = π₁ idS| and |vz = π₂ idS|.
Then, we introduce other constructors following the principle of Fordism:
\begin{code} 
data _ where
  Π      : (A : Ty Γ) (B : Ty (Γ , A)) → Ty Γ
  app    : (t : Tm Γ) (B : Ty (Γ , A)) (pt : tyOf t ≡ Π A B)
    → Tm (Γ , A)
  abs    : (t : Tm (Γ , A)) → Tm Γ
  Π[]    : (Π A B) [ σ ] ≡ Π (A [ σ ]) (B [ σ ↑ A ])
  abs[]  : abs t [ σ ] ≡ abs (t [ σ ↑ A ])
  Πβ     : app (abs t) (tyOf t) pt ≡ t
  Πη     : abs (app t B pt) ≡ t

tyOf (app t B p)      = B
tyOf (abs {A = A} t)  = Π A (tyOf t)
tyOf (abs[] σ t i)    = Π[] σ (tyOf t) i
tyOf (Πβ t pt i)      = tyOf t
tyOf (Πη t pt i)      = p (~ i)
\end{code}

Apart from the extra clauses of |tyOf|, the only change happens in the constructor |app|.
The constraint that |t| is of type |Π A B| is enforced there, but every other constructor remains as the same as their original QIIT definition.
\LT{any usage?}


\subsection{Type theory with the type of Booleans}

The introduction of an inductive type of Booleans is slightly involved, but let us look at the easy part first.
\begin{code}
data _ where
  𝔹      : Ty Γ
  𝔹[]    : 𝔹 [ σ ] ≡ 𝔹
  tt ff  : Tm Γ
  tt[]   : tt [ σ ] ≡ tt
  ff[]   : ff [ σ ] ≡ ff
  elim𝔹  : (P : Ty (Γ , 𝔹))
    (t : Tm Γ)  (pt  : tyOf t  ≡ P  [ idS , tt ∶[ [idS]T ] ])
    (u : Tm Γ)  (pu  : tyOf u  ≡ P  [ idS , ff ∶[ [idS]T ] ])
    (b : Tm Γ)  (pb  : tyOf b  ≡ 𝔹  [ idS ]) → Tm Γ

tyOf tt  = 𝔹
tyOf ff  = 𝔹
tyOf (tt[] σ i)  = 𝔹[] σ i
tyOf (ff[] σ i)  = 𝔹[] σ i
tyOf (elim𝔹 P u t pu pt b pb) = P [ idS , b ∶[ pb ] ]T
\end{code}
The only thing missing from the above definition is the substitution rule for |elim𝔹|, that is, 
applying the substitution |σ| to `|elim𝔹 P t pt u pu b pb|' is equal to applying a lifted substitution  |σ ↑ 𝔹| to |P| and |σ| to |t|, |u|, and |b|.
However, |P [ σ ↑ 𝔹 ]| gives us a type in the context |Δ , 𝔹 [ σ ]T|, which is equal to |Δ , 𝔹|, but we need to refrain ourself from proving any non-trivial facts while defining inductive types.

The solution is to provide a lifting |_↑𝔹| with the type |Sub Γ Δ → Sub (Γ , 𝔹) (Δ , 𝔹)| specialised for |𝔹|.
Therefore, we will need to show that the type of |vz| is |𝔹 [ σ ∘ wk ]| where  
\LT{finish this}

Therefore, we introduce an additional constructor and a lifting |_↑𝔹| substitution for |𝔹|:
\begin{code}
data _ where
  𝔹[]₂   : tyOf (π₂ {Γ , 𝔹} idS) ≡ 𝔹 [ τ ]

_↑𝔹 : (σ : Sub Γ Δ) → Sub (Γ , 𝔹) (Δ , 𝔹)
σ ↑𝔹 = σ ∘ wk , vz ∶[ 𝔹[]₂ {τ = σ ∘ π₁ idS} ]
\end{code}
Finally, we can introduce the desired equality constructor for |elim𝔹| as follows.
\begin{code}
data _ where
  elim𝔹[] : (P : Ty (Γ , 𝔹))
    ...
    (pt₂  : tyOf (t  [ σ ])  ≡ P  [ σ ↑𝔹 ]  [ idS , tt ∶[ [idS]T ] ])
    (pu₂  : tyOf (u  [ σ ])  ≡ P  [ σ ↑𝔹 ]  [ idS , ff ∶[ [idS]T ] ])
    (pb₂  : tyOf (b  [ σ ])  ≡ 𝔹  [ idS ])
    → (q : P [ idS , b ∶[ pb ] ] [ σ ]
    ≡  P [ σ ∘ wk , vz ∶[ 𝔹[]₂ ] ] [ idS , b [ σ ]t ∶[ pb₂ ] ])
    → (elim𝔹 P t pt u pu b pb) [ σ ]
    ≡ elim𝔹 (P [ σ ↑𝔹 ]) (t [ σ ]) pt₂ (u [ σ ]) pu₂
        (b [ σ ]) pb₂

tyOf (elim𝔹[] P u t pu pt b pb pt₂ pu₂ pb₂ q i) = q i
\end{code}
Note again that we also defer the coherence proof of |tyOf| for |elim𝔹[]| by introducing another argument |q| in |elim𝔹| which can be removed when defining its elimination rule.
\LT{Remember to explain how the argument |q| is addressed.}
\subsection{Type theory with a Tarski universe}
Using the same idiom described previously, a Tarski universe of types can be introduced to our type theory routinely.
First we need |U : Ty Γ| for the type of code and a type former |El| for the type of elements:
\begin{code}
data _ where
  U     : Ty Γ
  U[]   : U [ σ ]T ≡ U
  El    : (u : Tm Γ) (pu : tyOf u ≡ U) → Ty Γ
  El[]  : (q : tyOf (u [ τ ]t) ≡ U)
    → (El u pu) [ τ ]T ≡ El (u [ τ ]t) q
\end{code}

For the type |𝔹| of Boolean, its code |𝕓| is introduced with a type equality |El𝕓| such that the elements of |𝕓| is exactly |𝔹|:
\begin{code}
data _ where
  𝕓     : Tm Γ
  𝕓[]   : 𝕓 [ σ ]t ≡ 𝕓

tyOf 𝕓 = U
tyOf (𝕓[] σ i) = U[] {σ = σ} i

data _ where
  El𝕓 : El {Γ} 𝕓 refl ≡ 𝔹
\end{code}

For the |Π|-type, the situation is similar to |elim𝔹[]| where we need to specialise the substitution lifting with an additional equality constructor |El[]₂|:
\begin{code}
data _ where
  El[]₂ : (u : Tm Δ) (pu : tyOf u ≡ U)
    → (pu₂ : tyOf (u [ σ ]) ≡ U)
    → tyOf (π₂ {Γ , El (u [ σ ]) pu₂} idS)
    ≡ El u pu [ σ ∘ π₁ idS ]

_↑El : (σ : Sub Γ Δ) {u : Tm Δ}
  {pu : tyOf u ≡ U} {pu' : tyOf (u [ σ ]) ≡ U}
  → Sub (Γ , El (u [ σ ]) pu') (Δ , El u pu)
(σ ↑El) {u} {pu} {pu'} =
  σ ∘ π₁ idS , π₂ idS ∶[ El[]₂ u pu pu' ]
\end{code}

Finally, we introduce the code |π| for |Π| and the type equality |Elπ| and complete our definition of type theory using QIIRT:
\begin{code}
data _ where
  π    :  (a : Tm Γ) (pa : tyOf a ≡ U)
          (b : Tm (Γ , El a pa)) (pb : tyOf b ≡ U) → Tm Γ
  π[]  :  (a : Tm Γ)              (pa : tyOf a ≡ U)
       →  (b : Tm (Γ , El a pa))  (pb : tyOf b ≡ U)
       →  (pa' : tyOf (a [ σ ]t)      ≡ U)
       →  (pb' : tyOf (b [ σ ↑El ]t)  ≡ U)
       →  (π a pa b pb) [ σ ]t
       ≡  π (a [ σ ]t) pa' (b [ σ ↑El ]t) pb'

tyOf (π _ _ _ _) = U

data _ where
  Elπ : (a : Tm Γ) (pa : tyOf a ≡ U)
    → (b : Tm (Γ , El a pa)) (pb : tyOf b ≡ U)
    → El (π a pa b pb) refl ≡ Π (El a pa) (El b pb)

tyOf (π[] _ _ _ _ _ _ i) = U[] i
\end{code}

In the end, we remark that the introduction of additional equality proofs and constructors only makes sense under the assumption of UIP, so they do not actually add the type theory with new laws.

\subsection{Recursion and elimination principles} \label{sec:tt:elim}
We turn to its elimination rule of type theory we just defined.

\subsection{Strictification}

\subsection{Interleaved mutual definition}  \label{sec:tt:mutual}
\section{Metatheory}
% LTC (Tue 9 Sep)
% \input{meta.agda.tex}



\section{Comparison with other approaches}
% FNF (Tue 9 Sep)

Compared to QIIT:

\begin{itemize}
\item Fewer transports in the syntax, but they tend to come back in concrete models
\item Strictification orthogonal

Even the strictification technique~\cite{Kaposi2025}, which turn most of equality constructors about substitution to strict equalities, cannot help, as it can only be applied \emph{after} the inductive types are defined.
\end{itemize}

Compared to untyped version:
\begin{itemize}
\item Untyped version might still be easiest to work with, with current proof assistant technology
\end{itemize}

\section{Discussion}
% LTC (at first)

\begin{itemize}
  \item General translation from QIIT to QIIRT: Fordism translation and the index elimination
(theory of ornaments~\cite{Ko2016,Dagand2017})

  \item Practical considerations (eg NBE computes, support for interleaved mutual definitions)
  \item Eliminating indices entirely in a metatheory with definitional UIP (e.g., XTT~\cite{Sterling2022}) should work fine without a strict prop.

  \item Safety guarantees from proof assistant (e.g. strict positivity check, termination check, coverage check)
  \item Easier in OTT-based proof assistant
\end{itemize}

\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}
%\bibliography{ref}

\end{document}


%\begin{acks}
%To Robert, for the bagels and explaining CMYK and color spaces.
%\end{acks}
