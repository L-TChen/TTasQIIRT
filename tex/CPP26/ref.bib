

@incollection{Dybjer1996,
  author =        {Dybjer, Peter},
  booktitle =     {Types for Proofs and Programs. TYPES 1995},
  editor =        {Berardi, Stefano and Coppo, Mario},
  pages =         {120--134},
  publisher =     {Springer, Berlin, Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Internal type theory},
  volume =        {1158},
  year =          {1996},
  doi =           {10.1007/3-540-61780-9_66},
}

@inproceedings{Danielsson2006,
  author =        {Danielsson, Nils Anders},
  booktitle =     {Types for Proofs and Programs (TYPES 2006)},
  editor =        {Altenkirch, Thorsten and McBride, Conor},
  publisher =     {Springer, Berlin, Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {A formalisation of a dependently typed language as an
                   inductive-recursive family},
  volume =        {4502},
  year =          {2007},
  doi =           {10.1007/978-3-540-74464-1_7},
}

@article{Chapman2009,
  author =        {Chapman, James},
  journal =       {Electronic Notes in Theoretical Computer Science},
  pages =         {21--36},
  publisher =     {Elsevier Science Publishers B. V.},
  title =         {Type theory should eat itself},
  volume =        {228},
  year =          {2009},
  abstract =      {In this paper I present a partial formalisation of a
                   normaliser for type theory in Agda [Ulf Norell. Agda
                   2, 2007. http://www.cs.chalmers.se/~ulfn/]; extending
                   previous work on big-step normalisation [Thorsten
                   Altenkirch and James Chapman. Big-Step Normalisation.
                   Journal of Functional Programming, 2008. Special
                   Issue on Mathematically Structured Functional
                   Programming. To appear, Thorsten Altenkirch and James
                   Chapman. Tait in one big step. In Workshop on
                   Mathematically Structured Functional Programming,
                   MSFP 2006, Kuressaare, Estonia, July 2, 2006,
                   electronic Workshop in Computing (eWiC), Kuressaare,
                   Estonia, 2006. The British Computer Society (BCS)].
                   The normaliser in written as an environment machine.
                   Only the computational behaviour of the normaliser is
                   presented omitting details of termination.},
  doi =           {10.1016/j.entcs.2008.12.114},
  issn =          {1571-0661},
}

@inproceedings{McBride2010,
  address =       {Baltimore, Maryland, USA},
  author =        {McBride, Conor},
  booktitle =     {Proceedings of the ACM SIGPLAN Workshop on Generic
                   Programming},
  editor =        {d. S. Oliveira, Bruno C. and Zalewski, Marcin},
  number =        {12},
  pages =         {1--12},
  series =        {WGP' 10},
  title =         {Outrageous but meaningful coincidences: dependent
                   type-safe syntax and evaluation},
  year =          {2010},
  doi =           {10.1145/1863495.1863497},
}

@inproceedings{Altenkirch2016a,
  address =       {New York, NY, USA},
  author =        {Altenkirch, Thorsten and Kaposi, Ambrus},
  booktitle =     {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT
                   Symposium on Principles of Programming Languages},
  pages =         {18--29},
  publisher =     {Association for Computing Machinery},
  series =        {POPL '16},
  title =         {Type theory in type theory using quotient inductive
                   types},
  year =          {2016},
  abstract =      {We present an internal formalisation of a type heory
                   with dependent types in Type Theory using a special
                   case of higher inductive types from Homotopy Type
                   Theory which we call quotient inductive types (QITs).
                   Our formalisation of type theory avoids referring to
                   preterms or a typability relation but defines
                   directly well typed objects by an inductive
                   definition. We use the elimination principle to
                   define the set-theoretic and logical predicate
                   interpretation. The work has been formalized using
                   the Agda system extended with QITs using postulates.},
  doi =           {10.1145/2837614.2837638},
  isbn =          {9781450335492},
}

@article{McKinna1999,
  author =        {McKinna, James and Pollack, Robert},
  journal =       {Journal of Automated Reasoning},
  pages =         {373--409},
  title =         {Some lambda calculus and type theory formalized},
  volume =        {23},
  year =          {1999},
  doi =           {10.1023/A:1006294005493},
}

@inproceedings{Altenkirch2018,
  author =        {Altenkirch, Thorsten and Capriotti, Paolo and
                   Dijkstra, Gabe and Kraus, Nicolai and
                   Nordvall Forsberg, Fredrik},
  booktitle =     {Foundations of Software Science and Computation
                   Structures (FoSSaCS)},
  editor =        {Baier, Christel and Dal Lago, Ugo},
  pages =         {293--310},
  publisher =     {Springer, Cham},
  series =        {Lecture Notes in Computer Science},
  title =         {Quotient inductive-inductive types},
  volume =        {10803},
  year =          {2018},
  abstract =      {Higher inductive types (HITs) in Homotopy Type Theory
                   allow the definition of datatypes which have
                   constructors for equalities over the defined type.
                   HITs generalise quotient types, and allow to define
                   types with non-trivial higher equality types, such as
                   spheres, suspensions and the torus. However, there
                   are also interesting uses of HITs to define types
                   satisfying uniqueness of equality proofs, such as the
                   Cauchy reals, the partiality monad, and the
                   well-typed syntax of type theory. In each of these
                   examples we define several types that depend on each
                   other mutually, i.e. they are inductive-inductive
                   definitions. We call those HITs quotient
                   inductive-inductive types (QIITs). Although there has
                   been recent progress on a general theory of HITs,
                   there is not yet a theoretical foundation for the
                   combination of equality constructors and
                   induction-induction, despite many interesting
                   applications. In the present paper we present a first
                   step towards a semantic definition of QIITs. In
                   particular, we give an initial-algebra semantics. We
                   further derive a section induction principle, stating
                   that every algebra morphism into the algebra in
                   question has a section, which is close to the
                   intuitively expected elimination rules.},
  doi =           {10.1007/978-3-319-89366-2_16},
}

@article{Altenkirch2017,
  author =        {Altenkirch, Thorsten and Kaposi, Ambrus},
  journal =       {Logical Methods in Computer Science},
  month =         oct,
  number =        {4},
  title =         {Normalisation by evaluation for type theory, in type
                   theory},
  volume =        {13},
  year =          {2017},
  doi =           {10.23638/LMCS-13(4:1)2017},
}

@misc{Licata2011,
  author =        {Licata, Dan},
  month =         {April},
  title =         {Running circles around (in) your proof assistant; or,
                   quotients that compute},
  year =          {2011},
  url =           {https://homotopytypetheory.org/2011/04/23/running-circles-
                  around-in-your-proof-assistant/},
}

@article{Vezzosi2021,
  author =        {Vezzosi, Andrea and M{\"{o}}rtberg, Anders and
                   Abel, Andreas},
  journal =       {Journal of Functional Programming},
  number =        {e8},
  title =         {{Cubical Agda}: A dependently typed programming
                   language with univalence and higher inductive types},
  volume =        {31},
  year =          {2021},
  doi =           {10.1017/S0956796821000034},
}

@book{Hofmann1997,
  author =        {Hofmann, Martin},
  publisher =     {Springer London},
  series =        {Distinguished Dissertations},
  title =         {Extensional Constructs in Intensional Type Theory},
  year =          {1997},
  doi =           {10.1007/978-1-4471-0963-1},
}

@unpublished{Bense2024,
  author =        {Bense, Viktor and Kaposi, Ambrus and Xie, Szumi},
  note =          {Presented at TYPES'24},
  title =         {Strict syntax of type theory via alpha-normalisation},
  year =          {2024},
}

@article{Awodey2018,
  author =        {Awodey, Steve},
  journal =       {Mathematical Structures in Computer Science},
  number =        {2},
  pages =         {241--286},
  publisher =     {Cambridge University Press},
  title =         {Natural models of homotopy type theory},
  volume =        {28},
  year =          {2018},
  doi =           {10.1017/S0960129516000268},
}

@inproceedings{Dybjer1999,
  address =       {Berlin, Heidelberg},
  author =        {Dybjer, Peter and Setzer, Anton},
  booktitle =     {Typed Lambda Calculi and Applications},
  editor =        {Girard, Jean-Yves},
  pages =         {129--146},
  publisher =     {Springer Berlin Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {A finite axiomatization of inductive-recursive
                   definitions},
  volume =        {1581},
  year =          {1999},
  abstract =      {Induction-recursion is a schema which formalizes the
                   principles for introducing new sets in Martin-L{\"o}f
                   's type theory. It states that we may inductively
                   define a set while simultaneously defining a function
                   from this set into an arbitrary type by structural
                   recursion. This extends the notion of an inductively
                   defined set substantially and allows us to introduce
                   universes and higher order universes (but not a Mahlo
                   universe). In this article we give a finite
                   axiomatization of inductive-recursive definitions. We
                   prove consistency by constructing a set-theoretic
                   model which makes use of one Mahlo cardinal.},
  doi =           {10.1007/3-540-48959-2_11},
  isbn =          {978-3-540-48959-7},
}

@inproceedings{Donko2022,
  address =       {Dagstuhl, Germany},
  author =        {Donk{\'{o}}, Istv{\'{a}}n and Kaposi, Ambrus},
  booktitle =     {27th International Conference on Types for Proofs and
                   Programs (TYPES 2021)},
  editor =        {Basold, Henning and Cockx, Jesper and
                   Ghilezan, Silvia},
  pages =         {6:1--6:21},
  publisher =     {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r
                   Informatik},
  series =        {Leibniz International Proceedings in Informatics
                   (LIPIcs)},
  title =         {Internal strict propositions using point-free
                   equations},
  volume =        {239},
  year =          {2022},
  doi =           {10.4230/LIPIcs.TYPES.2021.6},
  isbn =          {978-3-95977-254-9},
  issn =          {1868-8969},
  urn =           {urn:nbn:de:0030-drops-167759},
}

@article{Kaposi2025,
  address =       {New York, NY, USA},
  author =        {Kaposi, Ambrus and Pujet, Lo{\"{\i}}c},
  journal =       {Proceedings of the ACM on Programming Languages},
  number =        {ICFP},
  publisher =     {Association for Computing Machinery},
  title =         {Type theory in type theory using a strictified
                   syntax},
  volume =        {9},
  year =          {2025},
  abstract =      {The metatheory of dependent types has seen a lot of
                   progress in recent years. In particular, the
                   development of categorical gluing finally lets us
                   work with semantic presentations of type theory (such
                   as categories with families) to establish fundamental
                   properties of type theory such as canonicity and
                   normalisation. However, proofs by gluing have yet to
                   reach the stage of computer formalisation: formal
                   proofs for the metatheory of dependent types are
                   still stuck in the age of tedious syntactic proofs.
                   The main reason for this is that semantic
                   presentations of type theory are defined using
                   sophisticated indexed inductive types, which are
                   especially prone to ``transport hell''. In this
                   paper, we introduce a new technique to work with CwFs
                   in intensional type theory without getting stuck in
                   transport hell. More specifically, we construct an
                   alternative presentation of the initial CwF which
                   encodes the substitutions as metatheoretical
                   functions. This has the effect of strictifying all
                   the equations that are involved in the substitution
                   calculus, which greatly reduces the need for
                   transports. As an application, we use our strictified
                   initial CwF to give a short and elegant proof of
                   canonicity for a type theory with dependent products
                   and booleans with large elimination. The resulting
                   proof is fully formalised in Agda.},
  doi =           {10.1145/3747535},
}

@article{Sterling2022,
  author =        {Sterling, Jonathan and Angiuli, Carlo and
                   Gratzer, Daniel},
  journal =       {Logical Methods in Computer Science},
  number =        {1},
  title =         {A cubical language for {Bishop} sets},
  volume =        {18},
  year =          {2022},
  doi =           {10.46298/lmcs-18(1:43)2022},
}

@article{Lumsdaine2020,
  author =        {Lumsdaine, Peter LeFanu and Shulman, Michael},
  journal =       {Mathematical Proceedings of the Cambridge
                   Philosophical Society},
  number =        {1},
  pages =         {159--208},
  title =         {Semantics of higher inductive types},
  volume =        {169},
  year =          {2020},
  doi =           {10.1017/S030500411900015X},
}

@article{Kaposi2019,
  address =       {New York, NY, USA},
  author =        {Kaposi, Ambrus and Kov{\'a}cs, Andr{\'a}s and
                   Altenkirch, Thorsten},
  journal =       {Proceedings of the ACM on Programming Languages},
  number =        {POPL},
  pages =         {2:1--2:24},
  publisher =     {Association for Computing Machinery},
  title =         {Constructing quotient inductive-inductive types},
  volume =        {3},
  year =          {2019},
  abstract =      {Quotient inductive-inductive types (QIITs) generalise
                   inductive types in two ways: a QIIT can have more
                   than one sort and the later sorts can be indexed over
                   the previous ones. In addition, equality constructors
                   are also allowed. We work in a setting with
                   uniqueness of identity proofs, hence we use the term
                   QIIT instead of higher inductive-inductive type. An
                   example of a QIIT is the well-typed (intrinsic)
                   syntax of type theory quotiented by conversion. In
                   this paper first we specify finitary QIITs using a
                   domain-specific type theory which we call the theory
                   of signatures. The syntax of the theory of signatures
                   is given by a QIIT as well. Then, using this syntax
                   we show that all specified QIITs exist and they have
                   a dependent elimination principle. We also show that
                   algebras of a signature form a category with families
                   (CwF) and use the internal language of this CwF to
                   show that dependent elimination is equivalent to
                   initiality.},
  doi =           {10.1145/3290315},
}

@phdthesis{McBride1999,
  author =        {McBride, Conor},
  school =        {University of Edinburgh},
  title =         {Dependently Typed Functional Programs and their
                   Proofs},
  year =          {1999},
  url =           {https://era.ed.ac.uk/bitstream/id/600/ECS-LFCS-00-419.pdf},
}

@misc{Agdaissue2021,
  author =        {{Agda issue}},
  month =         {May},
  title =         {Interleaved mutual and equality constructors},
  year =          {2021},
  url =           {https://github.com/agda/agda/issues/5362},
}

@article{Abel2019,
  author =        {Abel, Andreas and Allais, Guillaume and Hameer, Aliya and
                   Pientka, Brigitte and Momigliano, Alberto and
                   Sch{\"a}fer, Steven},
  journal =       {Journal of Functional Programming},
  pages =         {e19},
  title =         {\textsc{POPLMark} reloaded: Mechanizing proofs by
                   logical relations},
  volume =        {29},
  year =          {2019},
  doi =           {10.1017/S0956796819000170},
}

@article{Lumsdaine2015,
  address =       {New York, NY, USA},
  author =        {Lumsdaine, Peter LeFanu and Warren, Michael A.},
  journal =       {ACM Transactions on Computational Logic},
  number =        {3},
  publisher =     {Association for Computing Machinery},
  title =         {The local universes model: An overlooked coherence
                   construction for dependent type theories},
  volume =        {16},
  year =          {2015},
  abstract =      {We present a new coherence theorem for comprehension
                   categories, providing strict models of dependent type
                   theory with all standard constructors, including
                   dependent products, dependent sums, identity types,
                   and other inductive types.Precisely, we take as input
                   a ``weak model'': a comprehension category, equipped
                   with structure corresponding to the desired logical
                   constructions. We assume throughout that the base
                   category is close to locally Cartesian closed:
                   specifically, that products and certain exponentials
                   exist. Beyond this, we require only that the logical
                   structure should be weakly stable---a pure existence
                   statement, not involving any specific choice of
                   structure, weaker than standard categorical
                   Beck--Chevalley conditions, and holding in the now
                   standard homotopy-theoretic models of type
                   theory.Given such a comprehension category, we
                   construct an equivalent split one whose logical
                   structure is strictly stable under reindexing. This
                   yields an interpretation of type theory with the
                   chosen constructors.The model is adapted from
                   Voevodsky's use of universes for coherence, and at
                   the level of fibrations is a classical construction
                   of Giraud. It may be viewed in terms of local
                   universes or delayed substitutions.},
  doi =           {10.1145/2754931},
  issn =          {1529-3785},
}

@misc{Agda-issue2022,
  author =        {{Agda issue}},
  title =         {Fix {\#5816}: skip generating cubical clauses for
                   Prop stuff},
  year =          {2022},
  url =           {https://github.com/agda/agda/pull/5897},
}

@mastersthesis{Boer2020,
  author =        {de Boer, Menno},
  school =        {Department of Mathematics, Stockholm University},
  type =          {Licentiate thesis},
  title =         {A Proof and Formalization of the Initiality
                   Conjecture of Dependent Type Theory},
  year =          {2020},
  url =           {https://urn.kb.se/resolve?urn=urn%3Anbn%3Ase%3Asu%3Adiva-
                  181640},
}

@phdthesis{Kaposi2017,
  author =        {Kaposi, Ambrus},
  school =        {University of Nottingham},
  title =         {Type theory in a type theory with quotient inductive
                   types},
  year =          {2017},
  url =           {https://eprints.nottingham.ac.uk/41385/},
}

@unpublished{Coquand2020,
  author =        {Coquand, Thierry},
  title =         {Generalised algebraic presentation of type theory},
  year =          {2020},
  url =           {https://www.cse.chalmers.se/~coquand/cwf2.pdf},
}

@phdthesis{Ehrhard1988,
  author =        {Ehrhard, Thomas},
  school =        {Universit{\'e} Paris VII},
  title =         {Une s{\'e}mantique cat{\'e}gorique des types
                   d{\'e}pendents},
  year =          {1988},
}

@inproceedings{Altenkirch2026,
  author =        {Altenkirch, Thorsten and Kaposi, Ambrus and
                   Xie, Szumi},
  booktitle =     {Computer Science Logic (CSL'26)},
  note =          {To appear},
  title =         {The groupoid-syntax of type theory is a set},
  year =          {2026},
  url =           {https://arxiv.org/abs/2509.14988},
}

@article{Kaposi2020b,
  author =        {Kaposi, Ambrus and Kov{\'a}cs, Andr{\'a}s},
  journal =       {Logical Methods in Computer Science},
  number =        {1},
  pages =         {10:1--10:30},
  title =         {Signatures and induction principles for higher
                   inductive-inductive types},
  volume =        {16},
  year =          {2020},
  abstract =      {Higher inductive-inductive types (HIITs) generalize
                   inductive types of dependent type theories in two
                   ways. On the one hand they allow the simultaneous
                   definition of multiple sorts that can be indexed over
                   each other. On the other hand they support equality
                   constructors, thus generalizing higher inductive
                   types of homotopy type theory. Examples that make use
                   of both features are the Cauchy real numbers and the
                   well-typed syntax of type theory where conversion
                   rules are given as equality constructors. In this
                   paper we propose a general definition of HIITs using
                   a small type theory, named the theory of signatures.
                   A context in this theory encodes a HIIT by listing
                   the constructors. We also compute notions of
                   induction and recursion for HIITs by using variants
                   of syntactic logical relation translations. Building
                   full categorical semantics and constructing initial
                   algebras is left for future work. The theory of HIIT
                   signatures was formalised in Agda together with the
                   syntactic translations. We also provide a Haskell
                   implementation, which takes signatures as input and
                   outputs translation results as valid Agda code.},
  doi =           {10.23638/LMCS-16(1:10)2020},
  issn =          {18605974},
}

@inproceedings{Hancock2013,
  address =       {Berlin, Heidelberg},
  author =        {Hancock, Peter and McBride, Conor and Ghani, Neil and
                   Malatesta, Lorenzo and Altenkirch, Thorsten},
  booktitle =     {Typed Lambda Calculi and Applications},
  editor =        {Hasegawa, Masahito},
  pages =         {156--172},
  publisher =     {Springer Berlin Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Small induction recursion},
  volume =        {7941},
  year =          {2013},
  abstract =      {There are several different approaches to the theory
                   of data types. At the simplest level, polynomials and
                   containers give a theory of data types as free
                   standing entities. At a second level of complexity,
                   dependent polynomials and indexed containers handle
                   more sophisticated data types in which the data have
                   an associated indices which can be used to store
                   important computational information. The crucial and
                   salient feature of dependent polynomials and indexed
                   containers is that the index types are defined in
                   advance of the data. At the most sophisticated level,
                   induction-recursion allows us to define data and
                   indices simultaneously.},
  doi =           {10.1007/978-3-642-38946-7_13},
  isbn =          {978-3-642-38946-7},
}

@inproceedings{Kovacs2020a,
  address =       {New York, NY, USA},
  author =        {Kov{\'a}cs, Andr{\'a}s and Kaposi, Ambrus},
  booktitle =     {Proceedings of the 35th Annual ACM/IEEE Symposium on
                   Logic in Computer Science},
  pages =         {648--661},
  publisher =     {Association for Computing Machinery},
  series =        {LICS '20},
  title =         {Large and infinitary quotient inductive-inductive
                   types},
  year =          {2020},
  abstract =      {Quotient inductive-inductive types (QIITs) are
                   generalized inductive types which allow sorts to be
                   indexed over previously declared sorts, and allow
                   usage of equality constructors. QIITs are especially
                   useful for algebraic descriptions of type theories
                   and constructive definitions of real, ordinal and
                   surreal numbers. We develop new metatheory for large
                   QIITs, large elimination, recursive equations and
                   infinitary constructors. As in prior work, we
                   describe QIITs using a type theory where each context
                   represents a QIIT signature. However, in our case the
                   theory of signatures can also describe its own
                   signature, modulo universe sizes. We bootstrap the
                   model theory of signatures using self-description and
                   a Church-coded notion of signature, without using
                   complicated raw syntax or assuming an existing
                   internal QIIT of signatures. We give semantics to
                   described QIITs by modeling each signature as a
                   finitely complete CwF (category with families) of
                   algebras. Compared to the case of finitary QIITs, we
                   additionally need to show invariance under algebra
                   isomorphisms in the semantics. We do this by modeling
                   signature types as isofibrations. Finally, we show by
                   a term model construction that every QIIT is
                   constructible from the syntax of the theory of
                   signatures.},
  doi =           {10.1145/3373718.3394770},
  isbn =          {9781450371049},
}

@article{Pujet2022,
  address =       {New York, NY, USA},
  author =        {Pujet, Lo{\"{\i}c} and Tabareau, Nicolas},
  journal =       {Proceedings of the ACM on Programming Languages},
  number =        {POPL},
  publisher =     {Association for Computing Machinery},
  title =         {Observational equality: now for good},
  volume =        {6},
  year =          {2022},
  abstract =      {Building on the recent extension of dependent type
                   theory with a universe of definitionally
                   proof-irrelevant types, we introduce TTobs, a new
                   type theory based on the setoidal interpretation of
                   dependent type theory. TTobs equips every type with
                   an identity relation that satisfies function
                   extensionality, propositional extensionality, and
                   definitional uniqueness of identity proofs (UIP).
                   Compared to other existing proposals to enrich
                   dependent type theory with these principles, our
                   theory features a notion of reduction that is
                   normalizing and provides an algorithmic canonicity
                   result, which we formally prove in Agda using the
                   logical relation framework of Abel et al. Our paper
                   thoroughly develops the meta-theoretical properties
                   of TTobs, such as the decidability of the conversion
                   and of the type checking, as well as consistency. We
                   also explain how to extend our theory with quotient
                   types, and we introduce a setoidal version of Swan's
                   Id types that turn it into a proper extension of MLTT
                   with inductive equality.},
  doi =           {10.1145/3498693},
}

@article{Pujet2023,
  address =       {New York, NY, USA},
  author =        {Pujet, Lo{\"\i}c and Tabareau, Nicolas},
  journal =       {Proceedings of the ACM on Programming Languages},
  number =        {POPL},
  publisher =     {Association for Computing Machinery},
  title =         {Impredicative observational equality},
  volume =        {7},
  year =          {2023},
  abstract =      {In dependent type theory, impredicativity is a
                   powerful logical principle that allows the definition
                   of propositions that quantify over arbitrarily large
                   types, potentially resulting in self-referential
                   propositions. Impredicativity can provide a system
                   with increased logical strength and flexibility, but
                   in counterpart it comes with multiple incompatibility
                   results. In particular, Abel and Coquand showed that
                   adding definitional uniqueness of identity proofs
                   (UIP) to the main proof assistants that support
                   impredicative propositions (Coq and Lean) breaks the
                   normalization procedure, and thus the type-checking
                   algorithm. However, it was not known whether this
                   stems from a fundamental incompatibility between UIP
                   and impredicativity or if a more suitable algorithm
                   could decide type-checking for a type theory that
                   supports both. In this paper, we design a theory that
                   handles both UIP and impredicativity by extending the
                   recently introduced observational type theory TTobs
                   with an impredicative universe of definitionally
                   proof-irrelevant types, as initially proposed in the
                   seminal work on observational equality of Altenkirch
                   et al. We prove decidability of conversion for the
                   resulting system, that we call CCobs, by harnessing
                   proof-irrelevance to avoid computing with
                   impredicative proof terms. Additionally, we prove
                   normalization for CCobs in plain Martin-L{\"o}f type
                   theory, thereby showing that adding proof-irrelevant
                   impredicativity does not increase the computational
                   content of the theory.},
  doi =           {10.1145/3571739},
  url =           {https://doi.org/10.1145/3571739},
}

@inproceedings{Pujet2024,
  author =        {Pujet, Lo{\"\i}c and Tabareau, Nicolas},
  booktitle =     {Programming Languages and Systems (ESOP)},
  editor =        {Weirich, Stephanie},
  pages =         {275--301},
  publisher =     {Springer, Cham},
  series =        {Lecture Notes in Computer Science},
  title =         {Observational equality meets {CIC}},
  volume =        {14576},
  year =          {2024},
  doi =           {10.1007/978-3-031-57262-3_12},
}

@article{Gilbert2019,
  address =       {New York, NY, USA},
  author =        {Gilbert, Ga{\"e}tan and Cockx, Jesper and
                   Sozeau, Matthieu and Tabareau, Nicolas},
  journal =       {Proceedings of the ACM on Programming Languages},
  number =        {POPL},
  publisher =     {Association for Computing Machinery},
  title =         {Definitional proof-irrelevance without {K}},
  volume =        {3},
  year =          {2019},
  abstract =      {Definitional equality---or conversion---for a type
                   theory with a decidable type checking is the simplest
                   tool to prove that two objects are the same, letting
                   the system decide just using computation. Therefore,
                   the more things are equal by conversion, the simpler
                   it is to use a language based on type theory.
                   Proof-irrelevance, stating that any two proofs of the
                   same proposition are equal, is a possible way to
                   extend conversion to make a type theory more
                   powerful. However, this new power comes at a price if
                   we integrate it naively, either by making type
                   checking undecidable or by realizing new
                   axioms---such as uniqueness of identity proofs
                   (UIP)---that are incompatible with other extensions,
                   such as univalence. In this paper, taking inspiration
                   from homotopy type theory, we propose a general way
                   to extend a type theory with definitional proof
                   irrelevance, in a way that keeps type checking
                   decidable and is compatible with univalence. We
                   provide a new criterion to decide whether a
                   proposition can be eliminated over a type (correcting
                   and improving the so-called singleton elimination of
                   Coq) by using techniques coming from recent
                   development on dependent pattern matching without
                   UIP. We show the generality of our approach by
                   providing implementations for both Coq and Agda, both
                   of which are planned to be integrated in future
                   versions of those proof assistants.},
  doi =           {10.1145/3290316},
}

@inproceedings{Altenkirch2019,
  author =        {Altenkirch, Thorsten and Boulier, Simon and
                   Kaposi, Ambrus and Tabareau, Nicolas},
  booktitle =     {Mathematics of Program Construction (MPC)},
  editor =        {Hutton, Graham},
  pages =         {155--196},
  publisher =     {Springer, Cham},
  series =        {Lecture Notes in Computer Science},
  title =         {Setoid type theory---A syntactic translation},
  volume =        {11825},
  year =          {2019},
  doi =           {10.1007/978-3-030-33636-3_7},
}

@misc{Pujet2024a,
  author =        {Pujet, Lo{\"{\i}}c},
  howpublished =  {GitHub repository},
  title =         {Observational Coq},
  year =          {2024},
  url =           {https://github.com/loic-p/observational-coq},
}

@unpublished{Felicissimo2025a,
  author =        {Felicissimo, Thiago and Tabareau, Nicolas},
  note =          {Presented at TYPES'25},
  title =         {Towards quotient inductive types in observational
                   type theory},
  year =          {2025},
  url =           {https://msp.cis.strath.ac.uk/types2025/abstracts/
                  TYPES2025_paper85.pdf},
}

@misc{Agda-issue2025,
  author =        {{Agda issue}},
  title =         {Implement a {\texttt{--cubical=no-glue}} option},
  year =          {2025},
  url =           {https://github.com/agda/agda/pull/7861},
}

@misc{Agda-issue2019,
  author =        {{Agda issue}},
  title =         {A variant of Cubical Agda that is consistent with
                   UIP},
  year =          {2019},
  url =           {https://github.com/agda/agda/issues/3750},
}

@mastersthesis{Tan2025,
  author =        {Tan, Yee-Jian},
  school =        {Ecole polytechnique; Inria - Paris},
  title =         {Towards Computational {UIP} in {Cubical Agda}},
  year =          {2025},
}

@unpublished{Altenkirch2006,
  author =        {Altenkirch, Thorsten and McBride, Conor},
  title =         {Towards observational type theory},
  year =          {2006},
  url =           {http://www.strictlypositive.org/ott.pdf},
}

@article{Dagand2014,
  author =        {Dagand, Pierre-{\'E}variste and McBride, Conor},
  journal =       {Journal of Functional Programming},
  number =        {2--3},
  pages =         {316--383},
  title =         {Transporting functions across ornaments},
  volume =        {24},
  year =          {2014},
  doi =           {10.1017/S0956796814000069},
}

@article{Ko2016,
  author =        {Ko, Hsiang-Shang and Gibbons, Jeremy},
  journal =       {Journal of Functional Programming},
  pages =         {e2},
  title =         {Programming with ornaments},
  volume =        {27},
  year =          {2016},
  doi =           {10.1017/S0956796816000307},
}

@article{Dagand2017,
  author =        {Dagand, Pierre-{\'E}variste},
  journal =       {Journal of Functional Programming},
  number =        {e9},
  title =         {The essence of ornaments},
  volume =        {27},
  year =          {2017},
  doi =           {10.1017/S0956796816000356},
}

