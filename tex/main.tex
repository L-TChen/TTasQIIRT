
\documentclass[a4paper,UKenglish,numberwithinsect,cleveref,thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}

\title{Type theories as quotient inductive-recursive types}
\author{Liang-Ting Chen\footnote{Corresponding author; authors are listed in alphabetical order.}}{Institute of Information Science, Academia Sinica, Taiwan \and \url{http://l-tchen.github.io}}{ltchen@iis.sinica.edu.tw}{https://orcid.org/0000-0002-3250-1331}{Supported by the National Science and Technology Council of Taiwan under grant NSTC 114-2222-E-001-001-MY3.}
\author{Fredrik Nordvall Forsberg}{Department of Computer and Information Sciences, University of Strathclyde, UK \and \url{https://fredriknf.com}}{fredrik.nordvall-forsberg@strath.ac.uk}{https://orcid.org/0000-0001-6157-9288}{Supported by the Engineering and Physical Sciences Research Council [EP/Y000455/1].}
\author{Tzu-Chun Tsai}{Institute of Information Science, Academia Sinica, Taiwan}{gene0905@icloud.com}{}{Supported by the National Science and Technology Council of Taiwan under grant NSTC 112-2221-E-001-003-MY3.}
\authorrunning{L.-T.~Chen, F.~Nordvall Forsberg, and T.-C.~Tsai}
\Copyright{Liang-Ting Chen, Fredrik Nordvall Forsberg, and Tzu-Chun Tsai}
\ccsdesc[500]{Theory of computation~Type theory}
\keywords{inductive-inductive types, quotient inductive types, inductive-recursive types, substitution calculus, category with families}
\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{The formal development is hosted at the GitHub repository: \url{https://github.com/genetsai95/DTT-QIIRT}.}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional
\acknowledgements{We'd like to thank Hsiang-Shang Ko and Meven Lennon-Bertrand.}%optional

\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{YYY}
\EventNoEds{1}
\EventLongTitle{10th International Conference on Formal Structures for Computation and Deduction (FSCD 2025)}
\EventShortTitle{FSCD 2025}
\EventAcronym{FSCD}
\EventYear{2025}
\EventDate{July 14--20, 2025}
\EventLocation{Birmingham, United Kingdom}
\EventLogo{}
\SeriesVolume{XX}
\ArticleNo{XX}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage{manfnt}
\usepackage{underscore}
\newcommand{\danger}{\marginpar[\hfill\dbend]{\dbend\hfill}}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},#1]{#2}}
\newcommand{\Gene}[2][]{\todo[inline,author={Gene},caption={},#1]{#2}}
\newcommand{\Fredrik}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}

\input{macro.tex}


\begin{document}

\maketitle

\begin{abstract}
  \LT[noinline]{Try to interest Thorsten Altenkirch in the abstract}
  Defining type theory in type theory is a long-standing challenge and a benchmark for the expressiveness of a proof assistant.
  Altenkirch and Kaposi used quotient inductive-inductive types to represent exactly the well-typed terms of type theory, with the price to be paid that terms frequently contain transports along equality constructors.
  As a result, proofs need to painstakingly account for coercions alongside the interesting part.
  This %mess
  has been dubbed `transport hell', but is typically suppressed in informal presentation for clarity, hiding the gap between the intention and the formalisation of type theory in type theory.
  In this paper, we aim to shorten this gap, using quotient inductive-inductive-recursive types and definitions by overlapping patterns, reducing the use of transports.
  As a case study, we investigate the (parallel) substitution calculus and type theory with a universe and $\Pi$-types, and compare ours with quotient inductive-inductive definitions.
\end{abstract}

\section{Introduction} \label{sec:intro}

Metaprogramming and mechanised metatheory in a type-theoretic proof assistant relies on having an internal representation of type theory within type theory itself.
%
In the spirit of type theory, we would like to represent well scoped and well typed terms only --- this also has technical advantages, such as theorem statements not having to deal with impossible cases, or separately having to prove wellformedness lemmas, etc.
%
Doing this effectively seems to require several sophisticated features of the host type theory, most notably advanced inductive definitions.
%
For example, inductive families~\cite{Dybjer1994} can be used to represent the simply typed lambda calculus~\cite{Altenkirch1999}, while some kind of simultaneous definitions such as inductive-recursive~\cite{Dybjer2000} or inductive-inductive~\cite{Nordvall-Forsberg2014} definitions seem to be required for dependent type theory~\cite{Danielsson2006,Chapman2009}.
%
This is not just a matter of the pure strength of the host theory, but also expressivity and convenience: while it is known how to reduce inductive-inductive definitions to inductive families in principle~\cite{Kaposi2020a}, the resulting development would be considerable harder to work with, and most likely would have exhausted the resources of both the proof assistant and its user.

Altenkirch and Kaposi~\cite{Altenkirch2016a} showed that by employing \emph{quotient inductive-inductive types}~\cite{Altenkirch2018}, the internal representation of well typed terms could be significantly simplified, since equations such as $\beta$- and $\eta$-equality can be represented by the identity type thanks to quotient constructors.
%
Yet, there is a general phenomenon, called `transport hell', when working with quotient inductive-inductive types: to make use of equalities in later constructors and when using the eliminator for the type, the equalities need to be transported across.
%
Any method that reduces the friction this introduces seem worth exploring.
%

In this paper, we show that the development can be further streamlined by combining quotient inductive-inductive types and inductive-recursive types.
%
The basic idea, following a suggestion by Kaposi~\cite{Kaposi2023} and a precursor by Dybjer~\cite{Dybjer1996} and Danielsson~\cite{Danielsson2006}, is to replace the inductively defined action of a substitution on a type with a recursive definition, which computes.
%
Our development also makes use of another feature not usually found in standard presentations of type theory: recursive pattern matching definitions with overlapping patterns.
%
This is helpful to again avoid transport hell in the form of equations that do not reduce due to the standard translation of pattern matching to case trees.
%
As a result, many equations will hold strictly, and we can avoid the use of transport in the definition of type theory itself (which does not seem possible with quotient inductive-inductive types alone).
\LT{terminology: strict vs.\ definitional vs.\ judgemental?}
%

%However, we found that using quotient inductive-inductive-recursive types alone were not sufficient for a smooth development.
%%
%%Not only do we want the action of substitutions on types to compute definitionally, but we also want as many equations to hold strictly as possible:
%%
%%on the one hand, we want substitutions to distribute over type formers, but on the other hand we want substitutions to satisfy composition and unit laws of the category of context and substitutions up to definitional equality.
%%
%Instead, we also needed to make use of functions defined by overlapping patterns.
%%
%In a proof assistant such as Agda, this can be emulated by Agda's experimental support for rewrite rules, but with an additional proof burden on the user to show (informally) that their use is justified meta-theoretically.
%%
%To get some help with this task by Agda's confluence checker, it is often necessary to needlessly complicate a definition to convince the checker that the proposed rewrite rules are indeed confluent.

%
We emphasise that, following a fine tradition of previous attempts to represent type theory in type theory~\cite{Danielsson2006,Chapman2009,Altenkirch2016a}, we are making use of type-theoretic features that are so far not yet well understood or foundationally well motivated.
Nevertheless, Agda can be convinced to accept our formal implementation, using some experimental flags to introduce additional rewrite rules.\footnote{%
  As shown in \cite{Cockx2021}, adding non-terminating rewrite rules does not break consistency as long as these rules are consistent, so consistency is not an issue in our development.
}
Indeed, we also see this paper as a case study to motivate further developments for quotient inductive-inductive-recursive types and overlapping patterns.

\paragraph*{Contributions}
\begin{itemize}
  \item Exploration of the use of quotient inductive-inductive-recursive types and definitions by overlapping patterns.
    In particular, we give in a type theory:
    \begin{itemize}
      \item a definition of parallel substitution calculus;
      \item a definition of type theory with a universe and $\Pi$-types,
    \end{itemize}
   using quotient inductive-inductive-recursive types and definitions by overlapping patterns to define type substitution and term substitution partially.
  \item Comparison with other definitions using quotient inductive-inductive types.
\end{itemize}


\subsection{Plan of the paper}

\section{Metatheory and formalisation} \label{sec:meta}

We work in intensional Martin-L\"of type theory with uniqueness of identity proofs. In \cref{sec:models,sec:formal-implementation}, we also assume function extensionality.
%
We mostly follow the notational conventions of the HoTT book~\cite{UFP2013} (even if we do not assume the univalence axiom), except that we write dependent function types using Agda notation $(x : A) \to B(x)$.
%
We are further inspired by Agda in writing $\implicit{x}B(x)$ for $(x : A) \to B(x)$ when $x$ is treated as an ``implicit'' argument which is not given explicitly, but instead can be figured out from context.

We write $x \jdeq y$ for definitional equality, $x =^{A} y$ for the identity type stating that elements $x : A$ and $y : A$ of a type $A$ are equal, and $\dpath{P}{p}{t}{u}$ for the ``dependent'' identity type where $P : A \to \Set$, $t : P(x)$, $u : P(y)$ and $p : x =^A y$. One possible realisation of this type is as $t =^{P}_{p} u \defeq \transfib{P}{p}{t} =^{P y} u$, where $\transfibf{P} : (p : x =^A y) \to P(x) \to P(y)$ is our notation for the operation which allows is to transport values between type families applied to elements that are equal up to the identity type.
%
Finally, we write $x \simeq y$ for the \emph{heterogeneous} identity type, where we allow $x : A$ and $y : B$ to have potentially different types.
As shown by McBride~\cite{McBride1999}, the heterogeneous identity type is equivalent to the ordinary identity type equipped with the principle of uniqueness of identity proofs.

We have formally implemented our definitions and proofs in Agda, with the following options: \texttt{-{}-with-K}, \texttt{-{}-exact-split}, \texttt{-{}-rewriting}, and \texttt{-{}-local-confluence-check}. We simulate quotient inductive types using postulated equations to introduce equality constructors~\cite{Licata2011}.
Some of our theorem statements are meta-theoretical, and thus cannot be checked by Agda. Others can only be checked  partially, because of postulated quotient inductive types. We have marked such ``informal'' proofs with the symbol \resizebox*{!}{\baselineskip}{\textdbend}.

%\LT{
%Points to include:
%\begin{enumerate}
%  \item identity type $x =^{A} y$ for $x, y : A$, dependent identity type, $t =^{P}_{p} u \defeq \transfib{P}{p}{t} =^{P y} u$ for $t : P(x)$ and $u : P(y)$, heterogeneous equality~\cite{McBride1999} in \Agda $x \simeq y$ for $x : A$ and $y : B$
%  \item We work with intensional type theory with uniqueness of identity proof and function extensionality (only used for NbE and the standard model for the extensional identity type).
%  \item We use Agda to formally implement our definitions with the following options: \texttt{-{}-with-K}, \texttt{-{}-local-confluence-check}, \texttt{-{}-exact-split}, and \texttt{-{}-rewriting} using postulated equations~\cite{Licata2011} to introduce equality constructors for quotient types.
%\end{enumerate}}
%
%\LT{The symbol \textdbend indicates a property that is proved informally or checked partially with \Agda (because of postulated quotient inductive typeswbe checked ).}

\subsection{Inductive-recursive types}

An ordinary inductive type $A$, such as for example the type of natural numbers $A = \mathbb{N}$, allows functions out of the type $f : A \to X$ to be defined by recursion, by providing an elimination rule which says that such a function $f$ is defined by its values $f(\mathsf{c}_i\,x)$ on all of the constructors $\mathsf{c}_i$ of $A$. For example, a function $f: \mathbb{N} \to X$ is given by the values $f(0)$ and $f(\mathsf{suc}\,n)$, where the latter might refer to the already computed value $f(n)$.
%
The type is first defined inductively by listing its constructors, and then afterwards recursive functions can be defined out of it.

In contrast, an inductive-recursive type is defined inductively \emph{simultaneously} with a recursively defined function out of it. The prototypical example is Martin-L\"of's universe \`a la Tarski, where a type $U$ of codes for small types is defined simultaneously with a ``decoding'' function $T : U \to \Set$ which maps each code to the type it represents. Crucially, the code for dependent function types
\[
  \pi : (a : U) \to (T(a) \to U) \to U
\]
with $T(\pi(a, b)) = (x : T(a)) \to T(b(x))$ only makes sense because we already have access to the decoding function $T$.
%
Inductive-recursive types (IRT) were introduced by Dybjer~\cite{Dybjer2000}, and then extensively studied by Dybjer and Setzer~\cite{Dybjer1999,Dybjer2003}.
The general schema allows one to define a type $A$ inductively, together with a recursive function $F : A \to D$, for some fixed (possibly large) type $D$.

An IRT $(A, F)$ comes with an elimination rule that allows to define a dependent function  $f : (x : A) \to P(x)$ by giving values $f(\mathsf{c}_i\,x)$ on all of the constructors $\mathsf{c}_i$ of $A$, again reflecting that $A$ is inductively defined.
%
However, note that the recursive function $F : A \to D$ is not defined using this elimination rule, but part of the definition of the type itself.
%
In particular, the elimination rule can be used to define endofunctions on $A$, but the recursive function  $F : A \to D$ must always target a fixed pre-existing type $D$.
%
In this work, we will consider an extension \emph{generalised} IRTs, where also $F : A \to A$ is allowed.
%
Such IRTs were previously used by Danielsson~\cite{Danielsson2006} to represent type theory in type theory, and are discussed by Kaposi~\cite{Kaposi2023}.
%
Their general metatheory would be interesting future work.

%\LT{Mention that the recursion part of induction-recursion are already not defined by elimination rule.}


\subsection{Definitions by overlapping patterns} \label{sec:meta:overlapping}
\cite{Cockx2014,Altenkirch2016a}
\LT{We use $f\;\vec{x} \reduce \vec{t}$ to indicate a function clause of a definition by overlapping patters.}
\subsection{Quotient inductive-inductive types}
% \subsection{Quotient inductive(-inductive)-recursive types}

Quotient inductive types (QITs) are a special case of higher inductive types~\cite{Lumsdaine2020} from homotopy type theory, where constructors can not only introduce new elements, but also new equalities between the introduced elements.
%
Since we assume uniqueness of identity proofs globally, all QITs are implicitly truncated to be sets in the sense of homotopy type theory.
%
For example, the type of \emph{join lists} $\JList{X}$ can be given by the QIT
with the following constructors:
\begin{alignat*}{3}
  \Jnil & : \JList{X} \\
  \Jsing{\blank} & : X \to \JList{X} \\
  \Jconcat{\blank}{\blank} & : \JList{X} \to \JList{X} \to \JList{X} \\
  \mathsf{idl} & : \implicit{\ell}\; (\Jconcat{\ell}{\Jnil}) =^{\JList{X}} \ell \\
  \mathsf{idr} & : \implicit{\ell}\; (\Jconcat{\Jnil}{\ell}) =^{\JList{X}} \ell \\
  \mathsf{assoc} & : \implicit{\ell_0, \ell_1, \ell_2}\; (\Jconcat{(\Jconcat{\ell_0}{\ell_1})}{\ell_2}) =^{\JList{X}} (\Jconcat{\ell_0}{(\Jconcat{\ell_1}{\ell_2})})
\end{alignat*}


A quotient inductive-inductive type~\cite{Altenkirch2018} (QIIT) further allows the simultaneous definition of a type $A$ and a family of types $B : A \to \Set$, where both $A$ and $B$ are defined inductively --- this is different from an inductive-recursive definition of $A$ and $F : A \to D$, where $F$ is defined recursively; indeed, inductive-inductive definitions only make sense when $D = \Set$.
The metatheory of QIITs has been extensively studied by Altenkirch, Kaposi and Kov\'acs~\cite{Kovacs2018,Kaposi2019,Kovacs2020}.

We can also define join lists as a quotient inductive-\emph{recursive} type, as follows: The type $\JList{X}$ is defined simultaneously with a recursively defined function $\flatten : \JList{X} \to \List{X}$ which flattens a join list into an ordinary list. We keep the constructors $\Jnil$, $\Jsing{\blank}$ and $\Jconcat{\blank}{\blank}$, but replace $\mathsf{idl}$, $\mathsf{idr}$ and $\mathsf{assoc}$ by a single constructor
\[
\mathsf{nf} : (\ell, \ell' : \JList{X}) \to \flatten\,\ell =^{\mathsf{List}\,X} \flatten\,\ell' \to \ell =^{\JList{X}} \ell'
\]
which states that join lists are equal as soon as their flattenings are equal. For $\flatten$ to be well defined, it needs to respect the $\mathsf{nf}$ constructor, but this is a tautology: if $\ell =^{\JList{X}} \ell'$ because $\flatten\,\ell =^{\mathsf{List}\,X} \flatten\,\ell'$, then obviously $\flatten\,\ell =^{\mathsf{List}\,X} \flatten\,\ell'$.

%Shulman~\cite{Shulman2014} considered combining higher inductive types and inductive-recursive types, but the foundational status of this combination is underdeveloped. We will also make use of such a combination, which gives additional motivation to study its metatheory in future work.




\LT{How the congruence rule for the identity type can be used in QII(R)T?}
\subsection{Definitions by rewrite rules}
\cite{Cockx2020,Cockx2021}

Unfortunately, neither general schemata of quotient inductive-inductive-recursive types nor definitions by overlapping patterns have been developed or implemented in existing proof assistants.

\paragraph*{Local confluence}
\LT{Explain the notion of critical pair; local peak}
\paragraph*{Strong normalisation}
\cite{Abel2002}
\LT{Explain how these two conditions imply global confluence}

\section{Type theories as quotient inductive-inductive-recursive types} \label{sec:QIIRTs}
\LT{
\begin{enumerate}
  \item Goal: remove transports in the definition so that less transports during reasoning.
  \item Motivation: make type substitution definitional so that we do not have to apply transport along structural rules for types explicitly.
  \item Develop the quotient inductive-inductive-recursive definition of type theory step by step (which needs to be locally confluent and terminating).
    \begin{enumerate}
      \item parallel substitution: type substitution
      \item the type of elements of $A$: term substitution needs to be split into two definitional substitution and explicit term substitution to maintain local confluence.
      \item $\Pi$-type: because of the substitution lifting $\sigma^+ \defeq (\pi_1\idS, \pi_2\idS)$ is used we need to introduce a definitional lifting to maintain local confluence.
        We prefer categorical combinator and avoid using $\left< t \right>$ in the definition, which would introduce transports in the definition.
      \item Other type formers can be introduced as usual (as long as we use categorical combinators).
    \end{enumerate}
\end{enumerate}
}

We begin with the definition of the parallel substitution calculus~\cite{Martin-Lof1992} as a QIIT, emphasising how the use of transports in its very definition complicates formal reasoning.
We then introduce its QIIRT counterpart (\cref{subsec:SC-QIIRT}) which shortens the gap between formal and informal reasoning.
Then, we develop a type theory with a universe (\cref{subsec:SC+U}), $\Pi$-types (\cref{subsec:SC+U+Pi}), and other type formers (\cref{subsec:SC+U+Pi+more}).

\subsection{Substitution calculus as a quotient inductive-inductive type} \label{subsec:SC-QIIT}

Substitution calculus has a type $\Ctx$ of contexts, a type $\Ty\,\Gamma$ of types in context $\Gamma : \Ctx$, a type $\Sub\;\Gamma\;\Delta$ of substitutions from context $\Gamma$ to context $\Delta$, and a type $\Tm\;\Gamma\;A$ of terms in context $\Gamma$ of type $A$. 
This amounts to the following type families, all mutually inductively defined (hence inductive-inductive):
\begin{alignat*}{3}
  \Ctx   & : \Set                   \\
  \Ty    & : \Ctx \to \Set          \\
  \Sub   & : \Ctx \to \Ctx \to \Set \\
  \Tm    & : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Set
\end{alignat*}
The type $\Ctx$ has two constructors: $\emptyctx$ for the empty context, and $\blank,\blank$ for context extension, typed as follows.
\begin{alignat*}{3}
  \emptyctx & : \Ctx \\
  \blank,\blank & : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Ctx
\end{alignat*}
Note that a context extension $\Gamma , A$ is only wellformed if $A : \Ty\;\Gamma$, ensuring overall wellformedness of contexts, but requiring contexts and types to be defined simultaneously.

Type substitution takes a substitution $\sigma : \Sub\;\Gamma\;\Delta$ and an inhabitant $A : \Ty\;\Delta$ to form a type under $\Gamma$, i.e., type substitution as a constructor has type
\begin{alignat*}{3}
  [\blank]\blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma
\end{alignat*}
where $\Gamma$ and $\Delta$ are kept implicit.
\Fredrik{Could we change this to $A[\sigma]$ instead?}

Since $\Ty$ is inductively defined, we add a base case to ensure that $\Ty\;\Gamma$ is not empty for every $\Gamma$:
%
%If we were defining the notion of cwfs, type substitution would be enough for $\Ty$.
%For our inductive definition (i.e.\ the initial cwf), however, we need a base case in $\Ty\;\Gamma$, otherwise the type $\Ty$ would be empty as well as other types.
%Hence another constructor is introduced:
\begin{alignat*}{3}
  \UU & : \implicit{\Gamma} & \Ty\, \Gamma.
\end{alignat*}
For now, $\UU$ serves as a constant, but we will reuse $\UU$ for the type of small types later.

Substitutions from $\Gamma$ to $\Delta$ can be understood intuitively as lists of terms of type $A$ under the context $\Gamma$ for each $A$ in $\Delta$: we have the empty substitution $\emptysub$, and substitution extensions $\sigma, t$ which are intended to substitute the most recently bound variable by the term~$t$, and act like $\sigma$ on the other variables:
\begin{alignat*}{3}
  \emptysub & : \implicit{\Gamma}\;\Sub\;\Gamma\;\emptyctx \\
  \blank,\blank & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\;\Gamma\;([ \sigma ]\, A) \to \Sub\;\Gamma\;(\Delta, A),
\end{alignat*}
Note that type substitution $[\sigma]\;A$ is needed, because $A$ is well-formed in context $\Delta$ rather than in $\Gamma$.
We also ask for identity substitutions $\idS$ and compositions $\sigma;\tau$, because the substitution calculus is supposed to be the initial \emph{category} with families:
%Substitutions also have the identity substitution $\idS$ and composition $\blank;\blank$ (because substitution calculus is the initial \emph{category} with families),
\begin{alignat*}{3}
  \idS & : \implicit{\Gamma}\;\Sub\;\Gamma\;\Gamma \\
  \blank;\blank & : \implicit{\Gamma, \Delta, \Theta}\;\Sub\;\Gamma\;\Delta \to \Sub\;\Delta\;\Theta \to \Sub\;\Gamma\;\Theta
\end{alignat*}
These need to satisfy certain laws, which we introduce later as equality constructors.
Context extension is characterised by its projections, which picks out the rest of the context and the most recent variable
%Context comprehension is given by projections from \emph{non-empty} substitutions $\sigma : \Sub\;\Gamma\;(\Delta, A)$ for its \emph{tail} and its \emph{head}:
\begin{alignat*}{3}
  \pi_1 & : \implicit{\Gamma, \Delta, A}\;\Sub\;\Gamma\;(\Delta, A) \to \Sub\;\Gamma\;\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\;\Gamma\;(\Delta, A)) \to \Tm\;\Gamma\;([ \pi_1\,\sigma ]\; A)
\end{alignat*}
respectively.
Again, type substitution $[\pi_1\,\sigma]\,A$ is needed for~$\pi_2$, because $A$ is well-formed in context $\Delta$ instead of $\Gamma$.
Finally, we have term substitution, which given a substitution $\sigma : \Sub\;\Gamma\;\Delta$ turns terms in context $\Delta$ to terms in context $\Gamma$, appropriately preserving the type, which is also substituted:
\begin{alignat*}{3}
  [\blank] \blank & : \implicit{\Gamma,\Delta, A}\;(\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Delta\;A \to \Tm\;\Gamma\;([\sigma]\; A).
\end{alignat*}
Note that $[\blank]\blank$ is overloaded for type and term substitution.

The structural rules for type substitution are stipulated by following equality constructors:
\begin{alignat*}{3}
  [\idS]_T & : \implicit{\Gamma, A}                               && [ \idS ] \;A         && =^{\Ty\,\Gamma}\;A \\
  [;]_T    & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A} && [ \sigma ; \tau ]\;A && =^{\Ty\,\Gamma} [ \sigma ]\;([ \tau ]\;A) \\
  []\UU      & : \implicit{\Gamma, \Delta, \sigma}                && [ \sigma ]\;\UU        && =^{\Ty\,\Gamma} \UU
\end{alignat*}

The codomain $\Delta$ of a substitution $\sigma:\Sub\;\Gamma\;\Delta$ also tells the number of terms in $\sigma$, giving rise to two $\eta$-laws --- one for $\Delta$ being empty, and one for $\Delta$ being non-empty:
\begin{alignat*}{5}
  \emptyctx\eta   & : \implicit{\Gamma, A, \sigma}\; && \sigma        && =^{\Sub\,\Gamma\,\emptyctx} & \emptysub \\
  \pi\eta         & : \implicit{\Gamma, \Delta, \sigma}\; && \sigma   && =^{\Sub\,\Gamma\,(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma)
\end{alignat*}

The laws for substitution composition are stipulated using equality constructors, where, for the first time, we see the need to adjust the types involved with a $\transp$ in order for both sides to have the same type.
\begin{alignat*}{5}
  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma} && {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma} && {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \text{;-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \Xi, \sigma, \tau, \gamma} && (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} && \sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau) , \alert{\transfib{\Tm\,\Gamma}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] t}}
\end{alignat*}
%
Composition of substitutions $\blank;\blank$ acts like a list concatenation, so
we would expect $\sigma; (\tau, t)$ to be the same thing as $(\sigma; \tau), [\sigma]\,t$. However $[\sigma]\,t$ is of type $\Tm\;\Gamma\;([\sigma]\,[\tau]\;A)$, but the context extension $(\sigma; \tau), [\sigma]\,t$ requires $[\sigma]\,t$ to have type $\Tm\;\Gamma\;([\sigma; \tau]\,A)$ instead. Of course, we have an equality constructor $[;]_{\Ty}^{-1}\colon [\sigma]\,[\tau]\;A = [\sigma;\tau]\,A$ which we can transport along to fix up the equation.

%$\sigma; (\tau, t)$ is intuitively equal to $(\sigma; \tau), [\sigma]\,t$ whereas the term $t$ is of type $\Tm\;\Delta\;([\tau]\;A)$. 
%However, by the type of substitution extension, $[\sigma]\,t$ requires to be of type $\Tm\;\Gamma\;([\sigma; \tau]\,A)$ instead, so we have to transport $[\sigma]\,t$ explicitly along $[;]_{\Ty}^{-1}\colon [\sigma]\,[\tau]\;A = [\sigma;\tau]\,A$ to obtain a term of type $\Tm\;\Gamma\;([\sigma;\tau]\;A)$.

The first and second projections of a non-empty substitution $(\sigma, t)$ should  obviously be $\sigma$ and $t$ respectively
\begin{alignat*}{5}
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_1(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\,([\blank]\,A)}_{\alert{\pi_1\beta}} &&  t, 
\end{alignat*}
but again, note that the type of $\pi_2\beta$ only makes sense because we can transport along $\pi_1\beta$ to make sure both sides of the equation have the same type: $\pi_2(\sigma, t)$ is an habitant of $\Tm\;\Gamma\;([\pi_1\,(\sigma, t)]\,A)$ instead of $\Tm\;\Gamma\;([\sigma]\,A)$.
%whereas $\pi_2(\sigma, t)$ is an habitant of $\Tm\;\Gamma\;([\pi_1\,(\sigma, t)]\,A)$ instead of $\Tm\;\Gamma\;([\sigma]\,A)$ on the right-hand side. 
%Therefore, we have to transport $\pi_2(\sigma, t)$ along $\pi_1\beta$, so the above equality constructor is, in fact, $\transfib{\Tm\;\Gamma\;([\blank]\,A)}{\pi_1\beta}{\pi_2(\sigma, t)} =^{\Tm\;\Gamma\;([\sigma]\,A)} t$.
%
Similarly, for term substitution, terms are transported along the corresponding rules:
\begin{alignat*}{5}
  [\idS]_t         & : \implicit{\Gamma, A, t} && {[\idS]\,t}         && =^{\Tm\;\Gamma}_{\alert{[\idS]_\Ty}}  && t \\
  [;]_t            & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\sigma ; \tau]\,t} && =^{\Tm\;\Gamma}_{\alert{[;]_{\Ty}}}   && {[ \sigma ]\,[ \tau ]\,t}
\end{alignat*}
equivalent to the following (homogeneous) identities
\[
  \transfib{\Tm\;\Gamma}{[\idS]_{\Ty}}{[\idS]\,t} =^{\Tm\,\Gamma\,A} t
  \quad\text{and}\quad
  \transfib{\Tm\;\Gamma}{[;]_{\Ty}}{[\sigma;\tau]\,t} =^{\Tm\,\Gamma\,([\sigma]\,[\tau]A)} [\sigma]\,[\tau]\,t
\]
respectively.
Constructors introduced so far complete the definition of substitution calculus.

The use of transports in the formal definition fixes type mismatches but hinders equational reasoning about these terms even for a simple fact below.
\begin{example}\label{ex:pi2-comp}
  Given substitutions $\sigma : \Sub\;\Gamma\; \Delta$ and $\tau : \Sub\;\Delta\;(\Theta, A)$ for any $A : \Ty\,\Theta$, we may apply the projection $\pi_2$ to the composite $(\sigma; \tau)$ to access the first term $\pi_2(\sigma; \tau)$ of type $[\sigma;\tau] A$ under the context $\Gamma$, and this term should be equal to the first term $\pi_2\,\tau$ of $\tau$ after applying the substitution $\sigma$. 
  In short, the following equality apparently holds
  \[
    \pi_2\,(\sigma ; \tau) = [\sigma] (\pi_2\,\tau)
  \]
  by a back-of-the-envelope calculation
  \begin{equation} \label{eq:pi2-comp-proof}
    \pi_2\,(\sigma ; \tau) 
    = \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))
    = \pi_2\,(\sigma;\pi_1\,\tau, [\sigma]\,(\pi_2\,\tau))
    = [\sigma] (\pi_2\,\tau).
  \end{equation}
  Yet, the left-hand side is a term of type $[\pi_1\,(\sigma;\tau)] A$, but the other is $[\sigma] [\pi_1\,\tau] A$.
  Hence the above identity does not even make sense, since their types do not match.
  Alas, instead, we have to write $\pi_2\,(\sigma ; \tau) =^{\Tm\,\Gamma}_{p} [\sigma] (\pi_2\,\tau)$ for some $p: [\pi_1(\sigma; \tau)]\,A = [\sigma]\,[\pi_1\tau]\,A$ or, equivalently
  \begin{equation}\label{eq:pi2-comp-real-proof}
    ([\pi_1(\sigma; \tau)]\,A, \pi_2(\sigma; \tau)) =^{(A : \Ty\,\Gamma) \times (\Tm \Gamma A)} ([\sigma]\,[\pi_1\,\tau]A, [\sigma] (\pi_2\,\tau))
  \end{equation}
  as inhabitants of a $\Sigma$-type, so we can reason about term equalities along with type equalities.
  Moreover, in~\eqref{eq:pi2-comp-proof} we have used the rule $\mathsf{concat}$ which introduced another transported term, so we will have to remove that $\transp$ to derive the right hand side.

  To better illustrate the annoyance, note that a complete proof of \eqref{eq:pi2-comp-real-proof} requires us to show each of following equations:
  \begin{alignat*}{3}
         & ([\pi_1(\sigma; \tau)]\,A                    &&, \pi_2\,(\sigma ; \tau)) \\
    = {} & ([\pi_1(\sigma; (\pi_1\tau , \pi_2\tau))]\,A &&, \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))) \\
    = {} & ([\pi_1(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})]\,A &&, \pi_2\,(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})) \\
    = {} & ([\sigma;\pi_1\,\tau]\,A &&, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})) \nonumber \\
    = {} & (\sub{\sigma}{\sub{\pi_1\tau}{A}} &&, [\sigma] (\pi_2\,\tau)). \nonumber
  \end{alignat*}
  The first three equations corresponding to \eqref{eq:pi2-comp-proof} follow with Lemma~2.3.4 in \cite{UFP2013}, while the last has nothing to do with substitution calculus but the path lifting property (\cite[Lemma~2.3.2]{UFP2013}).
\end{example}

\subsection{Substitution calculus as a quotient inductive-inductive-recursive type} \label{subsec:SC-QIIRT}

To retain the intuitive way of reasoning such as in equation \eqref{eq:pi2-comp-proof} \emph{formally}, we would like to make type substitution rules definitional, since the root cause is that type substitution does not compute since it is a constructor, leading to type mismatches occurring with substitution.

One possibility is to define the substitution calculus as a quotient inductive-inductive-recursive type, where type substitution is defined by recursion, and hence computes.
%Now that $[ \idS ]_{\Ty}\;A = A$ and $[ \sigma ; \tau ]_{\Ty}\;A = [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A)$ do not make $[\blank]_{\Ty}\blank$ a (total) function, we may be tempted to define it by
%\begin{alignat*}{3}
%[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
%[ \sigma ]_{\Ty}\;\UU & = \UU
%\end{alignat*}
Note that this does not follow the schema of inductive-recursive definitions given by Dybjer and Setzer~\cite{Dybjer2000,Dybjer2003}, since the codomain of the recursive function is the inductively defined typed itself.\footnote{%
  While the general schema for this more liberal notion of induction-recursion remains underdeveloped, this definition is accepted in \Agda and used in other formalisations of type theory~\cite{Danielsson2006}.}
%Nevertheless, $[\idS]_{\Ty}\,A$ and $[\sigma; \tau]_{\Ty}\,A$ do not reduce to~$A$ and~$[\sigma]_{\Ty}\,[\tau]_{\Ty}\,A$ respectively, even though they are provable.
%This definition fails to remove any transport in the definition of substitution calculus.
%
Since we want type substitution to both act structurally on types and commute with identities and composition, we could try to define it recursively as follows:
\begin{alignat}{3}
[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \nonumber \\
[ \sigma ]_{\Ty}       \;\UU  & \defeq \UU                                   \label{eq:type-sub-at2-1} \\
[ \idS ]_{\Ty}         \;A    & \defeq A                                     \label{eq:type-sub-at2-2} \\
[ \sigma ; \tau ]_{\Ty}\;A    & \defeq [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \label{eq:type-sub-at2-3}
\end{alignat}
However, this definition does \emph{not} reduce \eqref{eq:type-sub-at2-2} or \eqref{eq:type-sub-at2-3} definitionally.
By design, definitions by pattern matching will be elaborated to a form that corresponds to the \emph{eliminator} either using \emph{first-match semantics}~\cite{Cockx2020a} for function clauses or an explicit construct for pattern matching, so that \eqref{eq:type-sub-at2-2} or \eqref{eq:type-sub-at2-3} will only fire if we know that $A$ is not $\UU$.
\LT[noinline]{How about \Coq and \Lean?}
\Fredrik[noinline]{They also translate to eliminators, so I think we do not need to say anything}
%In the above definition, only the eliminator for $\Ty\;\Delta$ will be considered using the first-match semantics, which amounts to the following definition:
%\begin{alignat*}{3}
%[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
%[ \sigma ]_{\Ty}\;\UU  & \reduce \UU
%\end{alignat*}
%where $\reduce$ is used to emphasise the reduction (which entails the definitional equality): we have done nothing different from our first attempt! 
%As a result, neither  are definitional.
We may swap \eqref{eq:type-sub-at2-1} with \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} to make \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} definitional, but then \eqref{eq:type-sub-at2-1} will be translated to 
\[
[ \emptysub ]_{\Ty}\;\UU         \reduce \UU, \qquad
[ \sigma, t ]_{\Ty}\;\UU         \reduce \UU, \qquad\text{and}\qquad 
[ \pi_1\,\sigma ]_{\Ty}\;\UU     \reduce \UU,
\]
where we have written $t \reduce t'$ for $t \equiv t'$ to emphasise the reduction behaviour. Thus in this case we have again lost the definitional equality $[\sigma]\;\UU \equiv \UU$.
%
%making $[\sigma]\;\UU = \UU$ propositional instead.
%Not being able to reduce $[ \sigma ]_{\Ty}\;\UU$ to $\UU$ would make our later extension with a type $\El\,a$ for $a : \Tm\;\Gamma\;\UU$ require another transport in the definition.
%Likewise, for any extension with a type former such as $\Pi$-types, structural rules would still be propositional.
%That is, using the standard semantics of function definition, we are not able to make type substitution definitional for \emph{both} $\Sub\;\Gamma\;\Delta$ and $\Ty\;\Delta$ at the same time.

To ensure that type substitution is definitional for all %\emph
{rules}, we turn to a definition by overlapping patterns (\Cref{sec:meta:overlapping}) instead to make each clause definitional. 
In addition, we can include other derived rules such as $[\pi_1(\sigma, t)]_{\Ty}\;A = [ \sigma]_{\Ty}\;A$ as long as they are locally confluent and terminating.
We end up with the following definition for type substitution:
\begin{alignat}{3}
[\blank]_{\Ty} \blank            &: \implicit{\Gamma, \Delta} \; \Sub\,\Gamma\,\Delta \to \Ty\,\Delta \to \Ty\,\Gamma \nonumber \\
[ \idS ]_{\Ty}\;A                & \reduce A \label{eq:def-type-subst-1}\\
[ \sigma ; \tau ]_{\Ty}\;A       & \reduce [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \label{eq:def-type-subst-2}\\
[ \pi_1(\sigma, t) ]_{\Ty}\;A    & \reduce [\sigma]_\Ty\;A                       \label{eq:def-type-subst-3} \\
[ \pi_1(\sigma; \tau) ]_{\Ty}\;A & \reduce [\sigma]_\Ty\;([\pi_1\tau]_\Ty\;A)    \label{eq:def-type-subst-4} \\
[ \sigma ]_{\Ty}\;\UU            & \reduce \UU                                   \label{eq:def-type-subst-5}
\end{alignat}
We first check that this definition of type substitution is confluent.\footnote{%
\Agda implements a local confluence checker with the experimental option \text{-{}-local-confluence-check}.
This option is turned on globally in our formal implementation.}
\begin{proposition}[Local confluence] \label{prop:local-confluence-1}
  Type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
  \danger
\end{proposition}
\begin{proof}
  To show the local confluence, we consider all local peaks, i.e.\ each combination of \eqref{eq:def-type-subst-5} with \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4},
  \[
    [\idS]_{\Ty}\;\UU, \qquad [\sigma;\tau]_{\Ty}\;\UU, \qquad [\pi_1(\sigma, t)]_{\Ty}\;\UU, \qquad\text{and}\qquad [\pi_1(\sigma; \tau)]_{\Ty}\;\UU
  \]
  and show that each applicable clause does result in $\UU$.

  For example, $[\sigma;\tau]_{\Ty}\;\UU \reduce [\sigma]_{\Ty}\;([\tau]_{\Ty}\;\UU) \reduce [\sigma]_{\Ty}\;\UU \reduce \UU$ using \eqref{eq:def-type-subst-2} as the first reduction and $[\sigma;\tau]_{\Ty}\;\UU \reduce \UU$ using \eqref{eq:def-type-subst-5} as the first reduction.
  It is easy to see that remaining local peaks reduce to the same term.
\end{proof}
\begin{proposition}[Termination]
  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
  \danger
\end{proposition}
\begin{proof}
  Clearly terms on the RHS are structurally smaller~\cite{Abel2002}.
\end{proof}

With this definition of type substitution, other equality constructors can be introduced without any $\transp$, and we can give the updated constructors the types below.
\begin{alignat*}{5}
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} &&\sigma ; (\tau , t) && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau), [ \sigma ]\;t \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\, A} &&  t \\
  [\idS]t         & : \implicit{\Gamma, A, t} && {[\idS]\,t}          && =^{\Tm\,\Gamma\,A} && t \\
  [;]t            & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\sigma ; \tau]\,t} && =^{\Tm\,\Gamma\,[\sigma ; \tau] A} && {[ \sigma ]\;([ \tau ]\;t})
\end{alignat*}

We revisit \Cref{ex:pi2-comp} to demonstrate the pragmatic benefit of QIIRTs over QIITs.
\begin{example}
  The equation $\pi_2\,(\sigma; \tau) = [\sigma](\pi_2\,\tau)$ can be formally stated without any transport.
  The type of the term on the LHS is $[\pi_1(\sigma;\tau)]_{\Ty}\;A$ which is definitionally equal to $[\sigma]_\Ty\;([\pi_1\tau]_\Ty\;A)$, i.e.\ the type of the term on the RHS.
  Moreover, the first components in each step of the proof of \eqref{eq:pi2-comp-real-proof}, are definitionally equal because of \eqref{eq:def-type-subst-3} and \eqref{eq:def-type-subst-4}.
  Consequently, the back-of-the-envelope calculation~\eqref{eq:pi2-comp-proof} is \emph{formally correct}.
\end{example}

As we are defining a function on a quotient inductive type, we have to prove that $[\blank]_{\Ty}\blank$ is coherent, i.e., that it respects all equality constructors.
\LT[noinline]{Should we mention any general condition for coherence?}
\Fredrik[noinline]{Is there one?}
\begin{proposition}[Coherence]\label{prop:coherence-1}
  $[\sigma]_{\Ty}\,A$ is (propositionally) equal to $[\tau]_{\Ty}\,A$ for every equality constructor $p : \sigma = \tau$.
  \danger
\end{proposition}
\begin{proof}
  As equality constructors $[\idS]_T$, $[;]_T$, and $[]\UU$ for types become definitional, it suffices to show that the following identities
  \begin{align*}
    [\sigma;\idS]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [\idS;\sigma]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [(\sigma;\tau);\gamma]_{\Ty} \;A & = [\sigma; (\tau; \gamma)]_{\Ty}A, \\
    [\pi_1(\sigma, t)]_{\Ty}\;A      & = [\sigma]_{\Ty}\;A, \\
    [\sigma; (\tau, t)]_{\Ty} \;A    & = [(\sigma;\tau), [\sigma]\, t]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\emptyctx]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\pi_1\sigma, \pi_2\sigma]_{\Ty}\;A
  \end{align*}
  hold propositionally.
  The first two identities of the first row hold definitionally by \eqref{eq:def-type-subst-1} and \eqref{eq:def-type-subst-2}, while terms of the both sides of the third reduce to $[\sigma]_{\Ty}\;([\tau]_{\Ty}\;([\gamma]_{\Ty}\;A))$ by \eqref{eq:def-type-subst-2}.

  The sole identity of the second row is clause \eqref{eq:def-type-subst-3} of the definition of $[\blank]_{\Ty}\blank$.

  We show the remaining cases by induction on $A$.
  However, $\UU$ is the only constructor for $\Ty\;\Gamma$ for any $\Gamma$ and each of the identities with $A \defeq \UU$ reduce to $\UU$.
\end{proof}
\begin{remark}\label{re:coherence-proof}
  Note that in the above proof the first four identities hold definitionally by \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4}, while the last three identities follow from \eqref{eq:def-type-subst-5} by induction on $A$.
  As we extend substitution calculus with other type formers, the first four identities will always hold but the last three depend on how congruence rules for type substitution is defined.
\end{remark}

\LT{We may wonder if the last three identities can be made definitional.
Can we find a complete set of rules?}

\subsection{Adding a universe} \label{subsec:SC+U}
In this section, we extend substitution calculus with an empty universe $\UU$ of small types~$\El\,u$.
For a QII definition \cite{Altenkirch2016a}, this extension adds the following constructors
\begin{alignat*}{3}
  \El   & : \implicit{\Gamma} && \Tm\,\Gamma\;\UU \to \Ty\,\Gamma \\
  []\El & : \implicit{\Gamma, \Delta, \sigma, u} && [ \sigma ]\,(\El\, u) =^{\Tm\;\Gamma\;\UU} \El\,(\alert{\transfib{\Tm\;\Gamma}{[]\UU}{\color{black}[\sigma]{u}}})
\end{alignat*}
%as the type $\UU$ of universe and its structural rule $[]\UU$ have been added to avoid a trivial inductive type.
The type substitution $[\sigma](\El\,u)$ is, informally, the type of the term substitution $[\sigma]\,u$ for $u : \Tm\;\Delta\;\UU$, and the transport is needed to coerce $[\sigma]\,u : \Tm\;\Gamma\;([\sigma]\;\UU)$ into $\Tm\;\Gamma\;\UU$.

In our QIIR definition, $\transfib{\Tm\;\Gamma}{[]\UU}{\blank}$ is no longer needed, since $[]\UU$ becomes definitional. 
Likewise, the equality constructor $[]\El$ may be replaced by 
\begin{alignat*}{3}
  [ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma] {u})
\end{alignat*}
Yet, this naive change breaks the local confluence!
The problem is that there is now additional interaction between types and terms. Observe that the local peak
\[
  \El\,u \Leftarrow [\idS]_{\Ty}(\El\,u) \reduce \El([\idS]\,u).
\]
cannot reduce to the same term, since the term substitution $[\idS]\,u$ is merely a constructor.

To repair the local confluence, we add a simultaneously defined function $[\blank]_{\Tm}\blank$ for term substitution apart from the explicit term substitution $[\blank]\blank$ as follows
\begin{alignat*}{3}
  [\blank]_{\Tm}\blank & : (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Delta\,A \to \Tm\,\Gamma\,([\sigma]_{\Ty}\,A) \\
[ \idS ]_{\Tm}\,t          & \reduce t \\
[ \sigma ; \tau ]_{\Tm}\,t & \reduce [ \sigma ]_{\Tm}\;([ \tau ]_{\Tm}\;t) \\
[ \pi_1(\sigma, t) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\,t \\
[ \pi_1(\sigma; \tau) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\; ([\pi_1\tau]_\Tm \,t) \\
[ \sigma ]_{\Tm}\,t        & \reduce [ \sigma ]\,t, \quad \text{otherwise}
\end{alignat*}
which reduces substitutions that occur in \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4} recursively so that the reduction can be propagated from type to term substitution.
The remaining cases reduce to the explicit term substitution $[\sigma]\,t$.
Note that $[\blank]_{\Tm}\blank$ can be defined with the standard semantics for function definition, since there are no overlapping patterns.
\begin{remark}
  The function $[\blank]_{\Tm}\blank$ can be understood as a \emph{smart constructor} for the explicit term substitution $[\blank]\blank$, a well-known idiom in functional programming, since the function $[\blank]_{\Tm}\blank$ (mostly) builds an explicit substitution but computes certain cases away.
\end{remark}

Then, the equality constructor $[]\El$ is accordingly changed to 
\begin{align}
  [ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma]_{\Tm} {u}) \label{eq:def-type-subst-7}
\end{align}
to retain the local confluence for type substitution:
\begin{proposition}[Local confluence] \label{prop:local-confluence-2}
  Type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
  \danger
\end{proposition}
\begin{proof}
  In addition to previous cases in the proof of \Cref{prop:local-confluence-1}, consider terms 
  \[
    [\idS]_{\Ty}\;(\El\,u), \qquad [\sigma;\tau]_{\Ty}\;(\El\,u), \qquad [\pi_1(\sigma, t)]_{\Ty}\;(\El\,u), \qquad\text{and}\qquad [\pi_1(\sigma; \tau)]_{\Ty}\;(\El\,u)
  \]
  which reduce to the following terms
  \[
    \El\,u, \qquad \El([\sigma]_{\Tm}\,[\tau]_{\Tm}\,u), \qquad \El([\sigma]_{\Tm}\,u), \qquad\text{and}\qquad
    \El([\sigma]_{\Tm}\,[\pi_1\tau]_{\Tm}\,u)
  \]
  respectively, no matter which function clause of $[\blank]_{\Ty}\blank$ is used.
  Therefore, type substitution is locally confluent.
\end{proof}
\begin{proposition}[Termination]
  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
  \danger
\end{proposition}
\begin{proof}
  Again, each recursive call is on a structurally smaller term~\cite{Abel2002}.
\end{proof}

We also have to show that the recursive substitution $[\blank]_{\Tm}\blank$ is propositionally equal to the explicit substitution $[\blank]\blank$, so they can be used together consistently.

\begin{proposition}\label{prop:correctness-1}
  For any $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Tm\;\Delta\;A$, the term $[\sigma]t$ is propositionally equal to $[\sigma]_{\Tm}\,t$.
\end{proposition}
\begin{proof}
  We show this statement by induction on $\sigma$. Since we are proving a propositional equality, and we are assuming uniqueness of identity proofs, all equality constructors are automatically respected, so we only need to worry about the point constructors.
  \begin{enumerate}
    \item For the identity substitution $\idS$, we have $[\idS]t = t \judgeq [\idS]_{\Tm} t$ by definition.
    \item For a composite substitution $\sigma; \tau$, we have
      \begin{align*}
        [\sigma;\tau]t & = [\sigma]\,([\tau] t)            && \text{by $[;]t$} \\
%                       & = [\sigma]\,([\tau]_{\Tm}\,t)       && \text{by the induction hypothesis $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                       & = [\sigma]_{\Tm}\,([\tau]_{\Tm}\,t) && \text{by the induction hypothesis (twice)} \\ %$[\sigma]u = [\sigma]_{\Tm}\,u$ for any $u$} \\
                       & \judgeq [\sigma;\tau]_{\Tm}\,t && \text{by definition.}
      \end{align*}
    \item For $\pi_1(\sigma, t)$, we have
      \begin{align*}
        [\pi_1(\sigma, t)]t & = [\sigma] t               && \text{by $\pi_1\beta$} \\
                            & = [\sigma]_{\Tm} \,t       && \text{by the induction hypothesis} \\ % $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                            & \judgeq [\pi_1(\sigma, t)]_{\Tm}\,t && \text{by definition.}
      \end{align*}
    %\item For $\pi_1(\sigma; \tau)$, it is proved similarly as the previous case.
    \item For the remaining cases, $[\sigma]_{\Tm} t$ is equal to $[\sigma]\,t$ definitionally.
  \end{enumerate}
  Hence, we conclude that $[\blank]_{\Tm}\blank$ is propositionally equal to $[\blank]\blank$.
\end{proof}

Finally, we have to show that both $[\blank]_{\Ty}\blank$ and $[\blank]_{\Tm}\blank$ are coherent.
\begin{proposition}[Coherence] \label{prop:coherence-2}
  For every equality constructor $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$, the following identities
  \danger
  \[
    [\sigma]_{\Ty}\,A = [\tau]_{\Ty}\,A
    \quad\text{and}\quad
    [\sigma]_{\Tm}\,t = [\tau]_{\Tm}\,t
  \]
  hold for any type $A$ and any term $t$.
\end{proposition}
\begin{proof}
  By \Cref{re:coherence-proof}, for type substitution, we only have to consider the following cases 
  \begin{align*}
    [\sigma; (\tau, t)]_{\Ty} \;A    & = [(\sigma;\tau), [\sigma]\, t]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\emptyctx]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\pi_1\sigma, \pi_2\sigma]_{\Ty}\;A
  \end{align*}
  while other cases hold definitionally.
  Again, for each case, we prove them by induction on $A$ and consider the case $A \defeq \El\,u$ only which is added to the definition of $[\blank]_{\Ty}\blank$ in this section. 
  However, all cases follow easily from \Cref{prop:correctness-1}.
  For example, consider the first case:
  \begin{align*}
    [\sigma; (\tau, t)]_{\Ty}(\El\,u) & \judgeq \El([\sigma; (\tau, t)]_{\Tm}\,u) && \text{by \eqref{eq:def-type-subst-7}} \\
                                      & = \El( [\sigma; (\tau, t)]\,u)            && \text{by \cref{prop:correctness-1}} \\
                                      & = \El( [\sigma; \tau, [\sigma]t)]\,u)     && \text{by $\mathsf{concat}$} \\
                                      & = \El( [\sigma; \tau, [\sigma]t)]_{\Tm}\,u) && \text{by \cref{prop:correctness-1}} \\
                                      & \judgeq [\sigma; \tau, [\sigma]t)]_{\Ty}\left(\El\,u\right) && \text{by \eqref{eq:def-type-subst-7} }
  \end{align*}
  The remaining two cases are omitted.

  As for term substitution $[\blank]_{\Tm}\blank$, each case follows from \cref{prop:correctness-1} in conjunction with the congruence rule for the identity type.
\end{proof}

\begin{remark}
We have seen that a naive extension with a universe breaks the local confluence of type substitution defined in \cref{subsec:SC-QIIRT}, because the newly added function clause interacts with other existing clauses.
In general, every term occurs on the right-hand side of a clause needs to propagate the reduction to allow a confluent term to exist, and this propagation can be achieved by turning a term involving a substitution $\sigma$ into a recursion.
\end{remark}

\subsection{Adding \texorpdfstring{$\Pi$}{Π}-types} \label{subsec:SC+U+Pi}

In this section, we extend the type theory in \cref{subsec:SC+U} with $\Pi$-types, i.e.\ dependent function types, whose the context of its codomain is extended with the domain type.
For the QIIT of type theory in \cite{Altenkirch2016a}, it amounts to adding the following constructors for the type formation rule, the term introduction/elimination rules:
\begin{alignat*}{3}
  \Pi     &: \implicit{\Gamma}            && (A : \Ty\,\Gamma) \to \Ty\,(\Gamma, A) \to \Ty\,\Gamma \\
  \lambda &: \implicit{\Gamma, A, B}      && \Tm\;(\Gamma, A)\;B \to \Tm\,\Gamma\,(\Pi\;A\;B) \\
  \mathsf{app} &: \implicit{\Gamma, A, B} && \Tm\;\Gamma\;(\Pi\;A\;B) \to \Tm\;(\Gamma, A)\;B
\end{alignat*}
the computation rules
\begin{alignat*}{5}
  \Pi\beta           & : \implicit{\Gamma, A, B, t} && \mathsf{app}\,(\lambda\,t) && =^{\Tm\,\Gamma,A} && t \\
  \Pi\eta            & : \implicit{\Gamma, A, B, t} && t                        && =^{\Tm\,\Gamma,A} && \lambda(\mathsf{app}\,t)
\end{alignat*}
and the structural rules for substitution
\begin{alignat}{5}
  []\Pi              & : \implicit{\Gamma, \Delta, \sigma, A, B}    && [ \sigma ]_{\Ty}\,(\Pi\;A\;B) && =^{\Ty\;\Gamma} && \Pi\,(\sub{\sigma}{A})\,([\sigma\uparrow A]\,B) \label{eq:def-type-subst-8} \\
  \mathsf{[]\lambda} & : \implicit{\Gamma, \Delta, \sigma, A, B, t} && [\sigma]_{\Tm} (\lambda\,t) && =^{\Tm\,\Gamma}_{\alert{[]\Pi}} && \lambda\,([\sigma \uparrow A]\,t) \nonumber
\end{alignat}
where $\sigma \uparrow A$ is the \emph{lifting}  of $\sigma$ by a type $A$ defined as $(\pi_1\idS; \sigma, \alert{\transfib{\Tm\;\Gamma}{[;]_T}{\color{black}\pi_2\idS}})$. 

For our QIIR definition, %$\sigma\uparrow A$ and $[]\lambda$ do not need a transport since $[;]_T$ and $[]\Pi$ are definitional.
we do not need any transport since $[;]_T$ and $[]\Pi$ are definitional.
However, once again, adding \eqref{eq:def-type-subst-8} directly to the type substitution $[\blank]_{\Ty}\blank$ breaks the local confluence, because the reduction gets stuck upon the lifting $\sigma \uparrow A$.
For example, $[\idS]_{\Ty}(\Pi\;A\;B)$ reduces to $\Pi\;A\;([\idS \uparrow A]_{\Ty}B)$ where $\idS \uparrow A$ is propositionally but not definitionally equal to $\idS$, so the local peak $\Pi\;A\;B \Leftarrow [\idS]_{\Ty}(\Pi\;A\;B) \reduce \Pi\;A\;([\idS \uparrow A]_{\Ty}B)$ cannot be joined. 

To retain the local confluence, we turn $\sigma \uparrow A$ into a simultaneously defined function:
\begin{alignat}{3}
  \blank\uparrow \blank & : (\sigma : \Sub\,\Gamma,\Delta) \to (A : \Ty\,\Delta) \to \Sub\,(\Gamma, [\sigma]_{\Ty}\,A)\, (\Delta, A) \label{eq:type-of-lifting} \\
\idS                \uparrow A & \reduce \idS \nonumber \\
(\sigma ; \tau)     \uparrow A & \reduce (\sigma \uparrow \sub{\tau}{A} ) ; (\tau \uparrow A) \nonumber \\
\pi_1(\sigma, t)    \uparrow A & \reduce \sigma \uparrow A \nonumber \\
\pi_1(\sigma; \tau) \uparrow A & \reduce (\sigma \uparrow \sub{\pi_1 \tau}{A}) ; (\pi_1 \tau \uparrow A)\nonumber \\
\sigma              \uparrow A & \reduce \sigma^+ , \quad \text{otherwise} \nonumber
\end{alignat}
where $\sigma^+ \defeq (\pi_1\idS ; \sigma, \pi_2\idS)$.
Then, we add another clause for type substitution and an equality constructor for term substitution without transport:
\begin{alignat}{5}
                     & [ \sigma ]_{\Ty}\,(\Pi\,A\,B) && \reduce \Pi\,(\sub{\sigma}{A})\,(\sub{\sigma\uparrow A}{B}) \label{eq:def-type-subst-9} \\
  \mathsf{[]\lambda} & : [\sigma]_{\Tm} (\lambda\,t) && =^{\Tm\,\Gamma\,([\sigma]_{\Ty}(\Pi\,A\,B))} && \lambda\,([\sigma \uparrow A]_{\Tm}\,t) \nonumber
\end{alignat}

\begin{proposition}[Local confluence]\label{prop:local-confluence-3}
  Type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
  \danger
\end{proposition}
\begin{proof}
  In addition to previous cases in \cref{prop:local-confluence-1,prop:local-confluence-2}, consider
  \begin{align*}
    [\idS]_{\Ty}\;(\Pi\;A\;B) && [\sigma;\tau]_{\Ty}\;(\Pi\;A\;B) && [\pi_1(\sigma, t)]_{\Ty}\;(\Pi\;A\;B) && [\pi_1(\sigma; \tau)]_{\Ty}\;(\Pi\;A\;B).
  \end{align*}
  Each of them reduces to the following terms after applying clauses of $\blank\uparrow\blank$ and $[\blank]_{\Ty}\blank$:
  \begin{align*}
    & \Pi\;A\;B                && \Pi\;([\sigma]_{\Ty}\,[\tau]_{\Ty}\,A)\;([\sigma \uparrow [\tau]\,A ]_{\Ty}\,[\tau \uparrow A ]_{\Ty}\,B) \\
    & \Pi\;([\sigma]_{\Ty}\;A)([\sigma \uparrow A]_{\Ty}\;B) && \Pi\;([\sigma]_{\Ty}\,[\pi_1\tau]_{\Ty}\,A)\;([\sigma \uparrow [\pi_1\tau]_{\Ty}\,[\pi_1\tau \uparrow A]_{\Ty}\,B)
  \end{align*}
  respectively.
  Hence, the type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
\end{proof}
\begin{proposition}[Termination]
  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
  \danger
\end{proposition}

Similar to term substitution, we can show that the lifted substitution $\sigma \uparrow A$ is propositionally equal to $\sigma^+$, based on two basic properties\footnote{%
  The reader is invited to prove them using the QII definition of type theory.}
about the lifting.
\begin{lemma} \label{lem:lifting}
  The following statements hold:
  \[
    \idS^+ =^{\Sub\;(\Gamma, A)\;(\Gamma, A)} \idS
    \qquad\text{and}\qquad
    (\sigma; \tau)^+     =^{\Sub\;(\Gamma, [\sigma]_{\Ty}\,[\tau]_{\Ty}\,A)\;(\Theta, A)} \sigma^+ ; \tau^+.
  \]
\end{lemma}

\begin{proposition} \label{prop:correctness-2}
  For every $\sigma : \Sub\;\Gamma\;\Delta$, and $A : \Ty\;\Delta$, the lifting
  $\sigma \uparrow A$ is propositionally equal to $(\pi_1 \idS ; \sigma , \pi_2 \idS)$.
\end{proposition}
\begin{proof}
  We prove the statement by induction on $\sigma$ with \cref{lem:lifting}.
  Every case follows from equational reasoning straightforwardly.
  For example, if $\sigma$ is a composite $\sigma;\tau$, we have
  \begin{align*}
    (\sigma;\tau) \uparrow A & \judgeq (\sigma \uparrow [\tau]\,A);(\tau \uparrow A) && \text{by definition} \\
                             & = \sigma^+;\tau^+                                     && \text{by induction hypothesis} \\ 
                             & = (\sigma;\tau)^+                                     && \text{by \cref{lem:lifting}.} 
  \end{align*}
  Other cases follow similarly.
\end{proof}

As we are working with a different type theory from \cref{subsec:SC+U}, we still have to prove the propositional equality $[\sigma]\,t = [\sigma]_{\Tm}\,t$ but the same argument still applies:
\begin{proposition} \label{prop:correctness-3}
  For every $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Ty\;\Delta\;A$,
  the term $[\sigma]t$ is propositionally equal to $[\sigma]_{\Tm}\,t$.
\end{proposition}

Finally, we show that these simultaneously defined functions are coherent.
\begin{proposition}[Coherence]
  For every $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$, the following identities
  \danger
  \[
    \sigma \uparrow A =^{\lam{\gamma}\Sub\;(\Gamma, [ \gamma ]_{\Ty} A)\;(\Delta, A)}_{\alert{p}} \tau \uparrow A
    \qquad\text{and}\qquad
    [\sigma]_{\Tm}\,t =^{\lam{\gamma}\Tm\;\Gamma\;([\gamma]_{\Ty}A)}_{\alert{p}} [\tau]_{\Tm}\,t,
  \]
  hold for any type $A$ and any term $t$.
\end{proposition}
\begin{proof}
  These two identities follow from \cref{prop:correctness-2,prop:correctness-3} easily with the heterogeneous identity (see \cref{sec:meta}).
\Fredrik{This heterogeneous equality has not been used so far; it would be good to not have to introduce it all, except perhaps locally in the proof here.}
\end{proof}

\subsubsection{Multiple lifting and the coherence of type substitution}
\Fredrik{This section gets rather technical. Keeping the page limit in mind, I wonder if we should only briefly summarise it in the main text?}

For the coherence of~$[\blank]_{\Ty}\blank$, we have to generalise the desired identity to account for the lifting, since a naive induction does not work: for example, unfolding $[\sigma]_{\Ty}\,(\Pi\;A\;B)$ leads to
\[
  \Pi\;([\sigma]_{\Ty}\,A)\;([\sigma\uparrow A]_{\Ty}\,B)
\]
where the induction hypothesis $[\sigma]_{\Ty}\,B = [\emptysub]_{\Ty}\,B$ cannot be applied.
Instead, we will define the \emph{multiple lifting} $\sigma \upuparrows \Xi$ by a telescope $\Xi = A_1, \dots, A_n$, which intuitively means multiple applications of lifting: $\sigma \uparrow A_1 \uparrow \dots \uparrow A_n$.
Then, we show the identity
$[\sigma \mathop{\upuparrows} \Xi ]_{\Ty}\,A = [\tau \mathop{\upuparrows} \Xi ]_{\Ty}\,A$
for arbitrary $\Xi$, subsuming the special case $[\sigma ]_{\Ty}\,A = [\tau ]_{\Ty}\,A$ for $\Xi$ being empty.

First, define an inductive-recursive type of \emph{telescopes} under a context $\Gamma$ simultaneously with a concatenation $\blank \dplus \blank$ as follows.

\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  \Tel               & :                   && \Ctx \to \Set                                     \\
  \emptytel          & : \implicit{\Gamma} && \Tel\;\Gamma \\
  \blank,\blank      & : \implicit{\Gamma} && (\Xi : \Tel\;\Gamma) (A : \Ty\;(\Gamma \dplus \Xi)) \to \Tel\;\Gamma
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  \blank & \dplus\blank     && :       (\Gamma : \Ctx) (\Xi : \Tel\;\Gamma) \to \Ctx \\
  \Gamma & \dplus \emptytel && \reduce \Gamma \\
  \Gamma & \dplus (\Xi, A)  && \reduce (\Gamma \dplus \Xi) , A
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip\noindent
Then, we define the multiple lifting $\blank \upuparrows \blank$.
Observe that its type, generalising the type \eqref{eq:type-of-lifting} of a single lifting $\blank\uparrow\blank$, should be
\[
\blank\upuparrows \blank : (\sigma : \Sub\;\Gamma\;\Delta) \to (\Xi : \Tel\;\Delta)
\to \Sub\;(\Gamma \dplus ([\sigma]_{\Tel}\,\Xi))\;(\Delta \dplus \Xi)
\]
asking for telescope substitution $[\blank]_{\Tel}\blank :  \Sub\;\Gamma\;\Delta \to \Tel\;\Delta \to \Tel\;\Gamma$, but $[\blank]_{\Tel}\blank$ also needs the multiple lifting for the case $[ \sigma ]_{\Tel}\,(\Xi, A)$ (why?).
Hence, we arrive the conclusion that telescope substitution and the multiple lifting by a telescope need to be defined mutually:
\begin{minipage}{.5\linewidth}
\begin{alignat*}{5}
  & [ \sigma ]_{\Tel}\,\emptytel && \reduce \emptytel \\
  & [ \sigma ]_{\Tel}\,(\Xi, A)  && \reduce [ \sigma ]_{\Tel}\,\Xi, [\sigma \upuparrows \Xi]_{\Ty}\,A
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\linewidth}
\begin{alignat*}{5}
  & \sigma \upuparrows \emptytel && \reduce \sigma \\
  & \sigma \upuparrows (\Xi, A)  && \reduce (\sigma \upuparrows \Xi) \uparrow A
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip

To prove the coherence property for the multiple lifting, we would need the properties $\idS_\Gamma \upuparrows \Xi = \idS_{\Gamma \dplus  \Xi}$ and $(\sigma; \tau) \upuparrows \Xi = (\sigma\upuparrows [\tau]_{\Tel} \Xi); (\tau \upuparrows \Xi)$, similar to \cref{lem:lifting}, but these identities cannot be typed: the type of $\idS_{\Gamma} \upuparrows \Xi$ is $\Sub\;(\Gamma \dplus [\idS]_{\Tel}\,\Xi)\;(\Gamma \dplus \Xi)$ while the type of $\idS$ on the RHS is $\Sub\;(\Gamma \dplus \Xi)\;(\Gamma \dplus \Xi)$; similarly for the substitution composition.

Instead of resorting to \transp, we also turn telescope substitution $[\blank]_{\Tel}\blank$ and the multiple lifting into definitions by overlapping patterns by adding following clauses:

\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  & [ \idS   ]_{\Tel}       \,\Xi && \reduce \Xi \\
  & [ \sigma ; \tau ]_{\Tel}\,\Xi && \reduce [ \sigma ]_{\Tel}\,([\tau]_{\Tel}\,\Xi)
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  & \idS          \upuparrows \Xi && \reduce \idS \\
  & (\sigma;\tau) \upuparrows \Xi && \reduce (\sigma \upuparrows [ \tau ]_{\Tel} \Xi) ; (\tau \upuparrows \Xi)
\end{alignat*}
\end{minipage}\vskip\belowdisplayskip\noindent
whose confluence property is easy to see.

Now, we proceed with the coherence property for the recursive functions introduced so far.
The first set of equality constructors are easy to prove, since the lifting and substitution operations compute independently for these cases:
\begin{proposition}[Coherence, I]
  \danger
  For the following equality constructors $p : \sigma = \tau$
  \[
    \mathsf{idr} : \sigma;\idS = \sigma, \quad
    \mathsf{idl} : \idS;\sigma = \sigma, \quad\text{and}\quad
    \textnormal{;-}\mathsf{assoc} : (\sigma;\tau);\gamma = \sigma; (\tau; \gamma), 
  \]
  the identities $[\sigma]_{\Tel}\,\Xi \judgeq [\tau]_{\Tel}\,\Xi$ and $[\sigma ]_{\Ty}\,A \judgeq [\tau ]_{\Ty}\,A$
  hold definitionally for any telescope $\Xi$ and any type $A$ and
  \[
    \sigma \upuparrows \Xi =^{\Sub\;(\Gamma\dplus [\sigma]_{\Tel}\Xi)\;(\Delta\dplus\Xi)}
    \tau   \upuparrows \Xi
  \]
  holds propositionally for any telescope $\Xi$.
\end{proposition}
\begin{proof}
  Thanks to overlapping patterns, the coherence of $[\blank]_{\Tel}\blank$ and $[\blank]_{\Ty}\blank$ for these cases holds definitionally by definition and the coherence of $\blank \upuparrows \blank$ boils down to the equality constructor itself.
  Take $\mathsf{idr}$ as an example, we can see 
  \begin{align*}
    (\sigma; \idS) \upuparrows \Xi & \judgeq (\sigma \upuparrows [\idS]_{\Tel} \Xi) ; (\idS \upuparrows \Xi) \\
                                   & \judgeq (\sigma \upuparrows \Xi) ; \idS \\
                                   & = \sigma \upuparrows \Xi
  \end{align*}
  where the last identity follows from $\mathsf{idr}:(\sigma \upuparrows \Xi) ; \idS = \sigma \upuparrows \Xi$.

  For other two equality constructors, the arguments follow similarly.
\end{proof}
The second set of equality constructors are more involved, as we have to prove the coherence for the lifting and substitution operations altogether mutually:
\begin{proposition}[Coherence, II]
  \LT[noinline]{Josh Ko suggests us to follow the proof structure in our formal implementation.}
  For the following equality constructors $p : \sigma = \tau$
  \begin{alignat*}{5}
    \pi_1\beta    & : \pi_1(\sigma, t)  && = \sigma \qquad\qquad & \mathsf{concat} & : \sigma; (\tau, t) && = (\sigma;\tau), [\sigma]\, t \\
    \emptyctx\eta & : \sigma            && = \emptyctx & \pi\eta & : \sigma && = \pi_1\sigma, \pi_2\sigma
  \end{alignat*}
   the identities
  \danger
  \begin{align*}
  [\sigma]_{\Tel}\,\Xi & = [\tau]_{\Tel}\,\Xi 
                         & [\sigma \upuparrows \Xi ]_{\Ty}\,A & =^{\lam{\gamma}\Ty\;(\Gamma \dplus [\gamma]_{\Tel}\Xi)}_{\alert{p}} [\tau \upuparrows \Xi ]_{\Ty}\,A \\
  \sigma \upuparrows \Xi & =^{\lam{\gamma}\Sub\;(\Gamma\dplus [\gamma]_{\Tel}\Xi)\;(\Delta\dplus\Xi)}_{\alert{p}} \tau \upuparrows \Xi
%    &
%  [\sigma \upuparrows \Xi ]_{\Tm}\,t & =^{\lam{\gamma}\Tm\;(\Gamma \dplus [\gamma]_{\Tel}\Xi)\;([\gamma \upuparrows \Xi]_{\Ty} A)}_{\alert{p}} [\tau \upuparrows \Xi ]_{\Tm}\,t
  \end{align*}
  hold for any telescope $\Xi : \Tel\,\Delta$ and type $A : \Ty\;(\Delta\dplus \Xi)$.
\end{proposition}
\begin{proof}
  We show the statement for $\pi_1\beta: \pi_1(\sigma, t) = t$ and the other three cases follow similarly.

  First, we prove the coherence for $[\blank]_{\Ty}\,A$ by induction on $A$ and the coherence for the other two identities $[\blank]_{\Tel}\, \Xi$ and $\blank \upuparrows \Xi$ by induction on $\Xi$.
  \begin{enumerate}
    \item Consider the following cases for $[\sigma\upuparrows\Xi]_{\Ty}\,A = [\tau \upuparrows \xi]_{\Ty}\,A$ by induction on $A$.
      \begin{description}
        \item[$A$ is $\UU$:] By definition
          \[
            [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,\UU_{\Delta\dplus \Xi} \judgeq \UU_{\Gamma \dplus [\pi_1(\sigma, t)]_{\Tel}\,\Xi} \quad\text{and}\quad [\sigma\upuparrows \Xi]_{\Ty}\,\UU_{\Delta\dplus \Xi} \judgeq \UU_{\Gamma \dplus [\sigma]_{\Tel}\,\Xi}
          \]
          By assumption, $[\pi_1(\sigma, t)]_{\Tel}\,\Xi = [ \sigma]_{\Tel}\,\Xi$ and by congruence $\Gamma \dplus [\pi_1(\sigma, t)]_{\Tel}\,\Xi = \Gamma \dplus [ \sigma]_{\Tel}\,\Xi$ holds.
          Then, $\UU_{\Gamma \dplus [\pi_1(\sigma, t)]_{\Tel}\,\Xi} \simeq \UU_{\Gamma \dplus [\sigma]_{\Tel}\,\Xi}$ holds by congruence for $\UU$.
          \LT{Justify the use of congruence rule for QIIT, e.g. $\transfib{\Ty}{p}{\UU_{\Gamma}} = \UU_{\Delta}$ for $p : \Gamma = \Delta$}

        \item[$A$ is $\El\,u$:]
          Similar to \Cref{prop:coherence-2}, we use \Cref{prop:correctness-3} and the congruence law for $[\blank]\,u$ to derive the desired identity.

        \item[$A$ is $\Pi\,B\,C$:]
          Note that one of the induction hypothesises is
          \[
            [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,C = [\sigma \upuparrows \Xi]_{\Ty}\,C
          \]
          for \emph{arbitrary} $\Xi$, so we can apply the induction hypothesis to $B$ and $C$ below:
          \begin{align*}
            & [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,(\Pi\,B\,C) \\
            \judgeq{} & \Pi\,([\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,B)\,([(\pi_1(\sigma, t) \upuparrows \Xi) \uparrow B]\,C) && \text{by the definition of $[\blank]_{\Ty}(\Pi\,B\,C)$} \\
            \judgeq{} & \Pi\,([\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,B)\,([(\pi_1(\sigma, t) \upuparrows (\Xi, B)]\,C) && \text{by the definition of $\upuparrows$} \\
            ={}       & \Pi\,([\sigma \upuparrows \Xi]_{\Ty}\,B)\,([\sigma \upuparrows (\Xi, B)]\,C) && \text{by induction hypothesises} \\
            \judgeq{} & \Pi\,([\sigma \upuparrows \Xi]_{\Ty}\,B)\,([(\sigma \upuparrows \Xi) \uparrow B]\,C) && \text{by the definition of $\upuparrows$} \\
            \judgeq{} & [\sigma\upuparrows \Xi]_{\Ty}\,(\Pi\,B\,C) && \text{by the definition of $[\blank]_{\Ty}(\Pi\,B\,C)$.}
          \end{align*}
      \end{description}
    \item By induction on $\Xi$, consider following cases for $[\pi_1(\sigma, t)]_{\Tel}\,\Xi = [\sigma]_{\Tel}\,\Xi$. 
      \begin{description}
        \item[$\Xi$ is the empty telescope $\emptytel$:] By definition, $[\pi_1(\sigma, t)]_{\Tel}\,\emptytel \judgeq \emptytel \judgeq [\sigma]_{\Tel}\,\emptytel$.
        \item[$\Xi$ is the telescope extension $\Xi, A$:] 
          \begin{align*}
            [\pi_1(\sigma, t)]_{\Tel}\,(\Xi, A) & \judgeq [\pi_1(\sigma, t)]_{\Tel}\,\Xi, [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,A && \text{by definition} \\
                                                & = [\sigma]_{\Tel}\,\Xi, [\sigma \upuparrows \Xi]_{\Ty}\,A \\
                                                & \judgeq [\sigma]_{\Tel}(\Xi, A) && \text{by definition}
          \end{align*}
      \end{description}
    \item By induction on $\Xi$, consider the following cases for $\pi_1(\sigma, t) \upuparrows \Xi = \sigma \upuparrows\,\Xi$.
      \begin{description}
        \item[$\Xi$ is the empty telescope $\emptytel$:] $\pi_1(\sigma, t) \upuparrows \emptytel \judgeq \pi_1(\sigma, t) = \sigma \judgeq \sigma \upuparrows \emptytel$ by definition and the equality constructor.
        \item[$\Xi$ is the telescope extension $\Xi, A$:] 
          \begin{align*}
            \pi_1(\sigma, t) \upuparrows (\Xi, A) & \judgeq (\pi_1(\sigma, t) \upuparrows \Xi) \uparrow A \\
                                                  & =^{} (\pi_1(\sigma, t) \upuparrows \Xi)^{+} \\
                                                  & =^{\lam{\gamma}\Sub\,(\Gamma\dplus[\gamma]_{\Tel}\,\Xi, [\gamma \upuparrows \Xi]_{\Ty}\,A)\,(\Delta \dplus \Xi, A)}_{p} (\sigma\upuparrows \Xi)^{+} \\
                                                  & = (\sigma \upuparrows \Xi) \uparrow A \\
                                                  & \judgeq \sigma \upuparrows (\Xi , A)
          \end{align*}
      \end{description}
  \end{enumerate}
  
\end{proof}

\begin{corollary}[Coherence]
  The identity $[\sigma]_{\Ty}\,A = [\tau]_{\Ty}\,A$ holds for every equality constructor $p : \sigma = \tau$.
  \danger
\end{corollary}


We conclude this extension with $\Pi$-types by noting that single term substitution
\begin{alignat*}{3}
  \left<\blank\right> & : \Tm\;\Gamma\;A \to \Sub\;\Gamma\;(\Gamma, A) \\
  \left< t \right> & \defeq (\idS , t),
\end{alignat*}
used to define the ordinal application: $t \mathop{\$} u \defeq [ \left< u \right> ]_{\Tm} (\mathsf{app}\,t)$, 
can be introduced without any transport, which is $(\idS, \alert{\transfib{\Tm\;\Gamma}{[id]_T^{-1}}{\color{black}t}})$ in its QII definition.
Similarly, the structural rule for substitution on $\mathsf{app}$ can be derived
\begin{align*}
  [\sigma \uparrow A ]_{\Tm}(\mathsf{app}\;t) & = \mathsf{app}\,\lambda([\sigma \uparrow A ]_{\Tm}(\mathsf{app}\;t)) && \text{by $\Pi\beta^{-1}$} \\
                                              & = \mathsf{app}\,\left([\sigma]\,\lambda\,(\mathsf{app}\,t)\right) && \text{by $[]\lambda^{-1}$} \\
                                              & = \mathsf{app}\,([\sigma]\,t) && \text{by $\Pi\eta^{-1}$.}
\end{align*}
without any transport (cf.\ \cite{Altenkirch2016a}), since \eqref{eq:def-type-subst-8} has become definitional. 


\subsection{... and other type formers} \label{subsec:SC+U+Pi+more}
\LT{%
\begin{enumerate}
  \item Discuss the extensional identity type.
  \item Discuss Coquand universes.
  \item Discuss the unit type.
  \item Discuss the Boolean type.
  \item Discuss the type of natural numbers.
\end{enumerate}
}
\Fredrik{I think we should keep this brief. I started doing the natural numbers in Agda, but there were some problems with the rewrite $[\sigma] \mathsf{Nat} = \mathsf{Nat}$ not firing in the type of the eliminator...}


\section{The elimination principle and models} \label{sec:models}
\LT{Terminology: the eliminator principle vs.\ eliminator vs.\ induction principle?}
\LT{%
\begin{enumerate}
  \item Show that two definitions are equivalent (ongoing).
  \item Show that methods are equivalent (ongoing).
\end{enumerate}
}
With the QIIR definition of a type theory, we show how to \emph{eliminate} $\Ctx$, $\Ty\,\Gamma$, $\Sub\;\Gamma\;\Delta$, and $\Tm\,\Gamma\,A$ to another types by functions subject to equations corresponding to point constructors, equality constructors, and function clauses (\cref{subsec:eliminator}) .
Then, we can give this QIIR definition of type theory a \emph{standard model} (\cref{subsec:std-model}) and compare our QIIR definition with its QII counterpart syntactically and semantically (\cref{subsec:equivalence}).

\subsection{The elimination principle} \label{subsec:eliminator}
\LT{We shall say something about the elimination/induction principle in \cref{sec:meta}}

To eliminate $\Ctx$, $\Ty\,\Gamma$, $\Sub\;\Gamma\;\Delta$, and $\Tm\,\Gamma\,A$, we have to specify types
\begin{align*}
  \Ctx^M & : \Ctx \to \Set &
  \Sub^M & : \implicit{\Gamma, \Delta}\,\Ctx^M\;\Gamma \to \Ctx^M\;\Delta \to \Sub\;\Gamma\;\Delta \to \Set \\
  \Ty^M  & : \implicit{\Gamma}\,\Ctx^M\;\Gamma \to \Ty\;\Gamma \to \Set & 
  \Tm^M  & : \implicit{\Gamma, A}\; (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Tm\;\Gamma\;A \to \Set
\end{align*}
called the \emph{motivates} as the target types for the elimination:
\begin{alignat*}{5}
  \elim_{\Ctx} & : (\Gamma : \Ctx)   && \to \Ctx^M\;\Gamma \\
  \elim_{\Ty}  & : (A : \Ty\;\Gamma) && \to \Ty^M\;(\elim_{\Ctx}\,\Gamma)\;A \\
  \elim_{\Sub} & : (\sigma : \Sub\;\Gamma\;\Delta) && \to \Sub^M\;(\elim_{\Ctx}\,\Gamma)\;(\elim_{\Ctx}\;\Delta)\;\sigma \\
  \elim_{\Tm}  & : (t : \Tm\;\Gamma\;A) && \to \Tm^M\;(\elim_{\Ctx}\,\Gamma)\;(\elim_{\Ty}\,A)\;t.
\end{alignat*}
Each constructor $c$ is interpreted by a corresponding functions $c^M$ indexed by $c$, i.e.\ 
\begin{alignat*}{3}
  \emptyctx_{\Ctx}^M     & :                      && \Ctx^M\;\emptyctx \\
  \blank,_{\Ctx}^M\blank & : \implicit{\dots} && (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Ctx^M\;(\Gamma, A) \\
  \UU^M & : \implicit{\dots} && \Ty^M\;\Gamma^M\;\UU \\
  \emptysub_{\Sub}^M     & : \implicit{\dots} && \Sub^M\;\Gamma^M\;\emptyctx_{\Ctx}^M\;\cdot \\
  \blank,_{\Sub}^M\blank & : \implicit{\dots} && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Gamma^M\;([\sigma^M]^M_{\Ty}\,A^M)\;t \to \Sub^M\;\Gamma^M\;(\Delta^M ,^M_{\Ctx} A^M)\;(\sigma, t) \\
  \idS^M          & : \implicit{\dots} && \Sub^M\;\Gamma^M\;\Gamma^M\;\idS \\
  [\blank]^M\blank & : \implicit{\dots} && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)([\sigma]\,t) \\
                   && \vdots
\end{alignat*}
and simultaneously defined functions are also given by corresponding functions 
\begin{alignat*}{3}
  [\blank]_{\Ty}^M\blank & : \implicit{\dots} && \Sub^M\;\Gamma^M\;\Delta^M\;\sigma \to \Ty^M\;\Delta^M\;A \to \Ty^M\;\Gamma^M\;([\sigma]_{\Ty}\,A) \\
  [\blank]_{\Tm}^M\blank & : \implicit{\dots} && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)([\sigma]_{\Tm}\,t) \\
                         && \vdots
\end{alignat*}
subject to the corresponding equations \emph{and function clauses}, e.g., 
\begin{alignat*}{5}
  [\idS]_{\Ty}^M & : \implicit{\dots} && [ \idS^M ]^M_{\Ty} \;A^M && =^{\Ty^M\,\Gamma^M}\;&& A^M \\
  [;]_{\Ty}^M & : \implicit{\dots} && [ \sigma^M ;^M \tau^M ]^M_{\Ty} \;A^M && =^{\Ty^M\,\Gamma^M}\; && [\sigma^M]^M_{\Ty}\,([\tau^M]^M_{\Ty}\,A^M) \\
  [\idS]_{\Tm}^M & : \implicit{\dots} && [\idS^M]^M_{\Tm}\;t^M && =^{\lam{A^M}\Tm^M\;\Gamma^M\;A^M\;t}_{\alert{[\idS^M]}} && t^M \\
                 && \vdots
\end{alignat*}
called \emph{methods}.
For brevity, we omit the rest of methods and refer to the Agda implementation for them.
\LT[noinline]{Add a link.}
We also have omitted the list of implicitly quantified variables: each variable $A$ implicitly quantified in a constructor $c$ has accordingly an $A$-indexed variable $A^M$ in $c^M$. 


\begin{definition}
  An \emph{eliminator} for the QIIR definition of type theory is a tuple of motives and methods above.
\end{definition}

\begin{remark}
To state these methods, we cannot avoid using transports in identities that would need transports in its QII definition of a type theory (e.g.\ $[\idS]_{\Tm}^M$) since identities (e.g.\ $[\idS]_{\Ty}^M$) are propositional just like equality constructors in its QII definition.
However, in the elimination principle for the QII definition, the situation is even worse: the above identity $[\idS]_{\Ty}^M$ \emph{already} requires $\alert{\transfib{\Ty^M\;\Gamma^M}{[\idS]_{\Ty}}{\color{black}[\idS^M]_{\Ty}^M\,A^M}}$ to coerce its type $\Ty^M\;\Gamma^M\;([\idS]\,A)$ to $\Ty^M\;\Gamma^M\;A$ to match the index $A$ of $A^M$, which are not needed in our QIIR definition.
That is, the eliminator for the QIIR definition requires fewer transports than its QII counterpart.
Nevertheless, the difference is insignificant, as both definitions would be derived from the signature of a quotient inductive-inductive(-recursive) type.
\end{remark}

Given an eliminator, the following clauses are derived to carry out the actual computation
\begin{alignat*}{5}
  \elim_{\Ctx}\,\emptyctx   & \reduce \emptyctx_{\Ctx}                                    && : \Ctx^M\;\emptyctx  \\
  \elim_{\Ctx}\,(\Gamma, A) & \reduce (\elim_{\Ctx}\,\Gamma),_{\Ctx}^{M} (\elim_{\Ty}\,A) && : \Ctx^M\;(\Gamma, A) \\
  \elim_{\Ty}\,\UU          & \reduce \UU^M && :\Ty^M\;\Gamma^M\;\UU \\
  \elim_{\Sub}\,\emptysub   & \reduce \emptysub^M_{\Sub} &&: \Sub^M\;\Gamma^M\;\emptyctx^M_{\Ctx}\;\emptyctx \\
                            & \vdots
\end{alignat*}
interpreting each constructor using the corresponding method inductively.

Here, the key difference from its QII counterpart is that type substitution $[\blank]\blank$ was a constructor and $[\sigma]\,A$ was eliminated to $[\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A)$; similarly for term substitution.
In contrast, substitution operations $[\blank]_{\Ty}\blank$ and $[\blank]_{\Tm}$ are functions rather than constructors, meaning they cannot be eliminated inductively but instead become propositional identities. 
\begin{proposition}\label{prop:provable-function-clauses}
  Given the motives and the methods, we have
\begin{alignat*}{5}
  \elim_{\Ty}[] & : \implicit{\dots} & \elim_{\Ty}\,([\sigma]_{\Ty}\,A) & = && [\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A) \\
  \elim_{\Tm}[] & : \implicit{\dots} & \elim_{\Tm}\,([\sigma]_{\Tm}\,t) & =^{\lam{A^M}\Tm^M\;\Gamma^M\;A^M\;t}_{\alert{\elim_{\Ty}[]}} && [\elim_{\Sub}\,\sigma]^M_{\Tm}\,(\elim_{\Tm}\,t)
\end{alignat*}
\end{proposition}
\LT{Add some remark regarding the proof?}

These identities are used to interpret constructors whereas definitional identities are used in syntax.
Consider eliminating an extension $\sigma, t$ for $\sigma : \Sub\;\Gamma\;\Delta$ and $t : \Tm\;\Gamma\;([\sigma]_{\Ty}\,A)$, i.e.\ 
\[
  \elim_{\Sub}(\sigma, t) = (\elim_{\Sub}\,\sigma) ,^M_{\Sub} \; \alert{t^M}.
\]
In the QII definition, $t^M$ is just $\elim_{\Tm}\,t$ of type
\begin{equation} \label{eq:elim-subext}
  \Tm^M\;\Gamma^M\;(\elim_{\Ty}\;([\sigma]_{\Ty}\,A))\;t\judgeq \Tm^M\;\Gamma^M\;[\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A)\;t
\end{equation}
as the RHS of \eqref{eq:elim-subext} is indeed the type for the second argument of $\blank,^M_{\Sub}\blank$.
In the QIIR definition, on the contrary, the type of $\elim_{\Tm}\;t$ is $\elim_{\Ty}\;([\sigma]_{\Ty}\,A)$ is not definitionally equal to the RHS of \eqref{eq:elim-subext}, so $\elim_{\Sub}(\sigma, t)$ has to be
\[
  (\elim_{\Sub}\,\sigma) ,_{\Sub}^M \alert{\transfib{\Tm^M\;(\elim_{\Ctx}\,\Gamma)}{\elim_{\Ty}[]}{\color{black}(\elim_{\Tm}\,t)}}
\]
transporting $\elim_{\Tm}\,t$ along the identity $\elim_{\Ty}[]$ to replace \eqref{eq:elim-subext}.

\begin{remark}
Note again that our inductive-recursive definition is not an instance of the general schema of inductive-recursion in the sense of Dybjer and Setzer~\cite{Dybjer2000,Dybjer2003} where simultaneously defined functions do not require corresponding interpretation as they target meta-theoretic types instead of inductive types being defined.
\end{remark}

\subsection{The standard model} \label{subsec:std-model}

The soundness of our definition is justified by the standard model, which is further given by the same motives as those for its QII counterpart~\cite[Section~4]{Altenkirch2016a}:
\begin{align*}
  \Ctx^M & \defeq \lam{\_} \Set &
  \Sub^M & \defeq \lam{\Gamma^M}{\Delta^M}{\_} \Gamma^M \to \Delta^M \\
  \Ty^M  & \defeq \lam{\Gamma^M}{\_}\Gamma^M \to \Set & 
  \Tm^M  & \defeq \lam{\Gamma^M}{A^M}{\_} (\gamma : \Gamma^M) \to A^M \gamma
\end{align*}
with the additional methods to its QII counterpart:
\begin{align*}
  \blank\uparrow^M\blank & \judgeq \lam{\sigma^M}{A^M}{(\gamma, x^M)} (\sigma^M\,\gamma , x^M) & \\
                         & : (\sigma^M : \Gamma^M \to \Delta^M) (A^M : \Delta^M \to \Set) \to \Sigma\;\Gamma^M\;(\lam{\gamma}A^M\,(\sigma^M\,\gamma)) \to \Sigma\,\Delta^M\,A^M \\
  [\blank]_{\Tm}^M\blank & \judgeq \lam{\sigma^M}{t^M} (\sigma^M ; t^M)  \\
                         & : (\Gamma^M \to \Delta^M) \to ((\delta : \Delta^M) \to A^M\,\delta) \to (\gamma : \Gamma^M) \to A^M\,(\sigma^M\,\gamma)
\end{align*}
where $[\blank]_{\Tm}^M\blank$ is the same as the method for the explicit term substitution $[\blank]^M\blank$.
The additional identities for these methods all hold definitionally.
For example, 
\LT{give an example}

Indeed, it is not surprising.
Additional rules we have used to enable further reduction are derivable already, so they can be justified by the same standard model.
It is nature to ask: what is the theoretical difference between the QIIR and QIIR definitions?
\subsection{Comparison with type theory as QIIT} \label{subsec:equivalence}
\section{Formal implementation} \label{sec:formal-implementation}
\LT{Mention the NbE for SC here}
\LT{Compare some formal proofs with pen-and-paper proofs here}
\section{Discussion}
\subsection{Related work}
\paragraph*{Formalisation of type theory in type theory}
\cite{Danielsson2006,Altenkirch2016a,Chapman2009}
\cite{Altenkirch2017}
\cite{Munoz1998}
\cite{Dybjer1996,Castellan2021}
\LT{Dybjer \cite{Dybjer1996} already says cwf is inductive-recursive}

Substitution calculus is closely related to \emph{categories with families}~\cite{Dybjer1996}.
\paragraph*{Quotient inductive-recursive definition of single substitution calculus}
\cite{Kaposi2023,Kaposi2024a}
\paragraph*{Schemata of inductive types}
\cite{Kaposi2019}
\LT{How does the general schema in \cite{Kaposi2019} model equality constructors? extensionally? Can their schemata manifest the difference of our QIIR definition and the QII definition in \cite{Altenkirch2016a}?}

\subsection{Future work}
\LT{Remember that it is for further developments.}
\paragraph*{Type theory in type theory}
\cite{Pujet2022,Pujet2024,Pujet2022a}
\LT{OTT is a concrete instance of a type theory with UIP and function extensionality.}

\paragraph*{Semantics and design for definitions by overlapping patterns}
\LT{Overlapping patters are discussed by Cocks \cite{Cockx2014}, but we would like to integrate it with the schema of QIIRT.}
\LT{\cite{Eremondi2025} has recently hinted a possible direction for overlapping patterns using sheaf theory.}

\paragraph*{A schema of quotient inductive-inductive-recursive types in observation type theory}
\LT{What a general schema should have?  inductive types should be allowed as the codomain of a recursion.}
  
\LT{OTT also has a natural setoid model (which should be useful to manifest the difference between recursion and equality constructor) but quotient (inductive-)inductive(-recursive) types in OTT are underdeveloped.}


\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}

\appendix

\section{Complete definitions}
\begin{alignat*}{3}
  \Ctx      & : && \Set                   \\
  \Ty       & : && \Ctx \to \Set          \\
  \Sub      & : && \Ctx \to \Ctx \to \Set \\
  \Tm       & : && (\Gamma : \Ctx) \to \Ty\,\Gamma \to \Set \\
  \emptyctx & : && \Ctx \\
  \blank,\blank & : && (\Gamma : \Ctx) \to \Ty\,\Gamma \to \Ctx \\
  [\blank]\blank & : \implicit{\Gamma, \Delta} && \Sub\,\Gamma\,\Delta \to \Ty\,\Delta \to \Ty\,\Gamma \\
  \emptysub & : \implicit{\Gamma} && \Sub\,\Gamma\,\emptyctx \\
  \blank,\blank & : \implicit{\Gamma, \Delta, A} && (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,([ \sigma ]_{\Ty} A) \to \Sub\,\Gamma,(\Delta, A) \\
  \idS & : \implicit{\Gamma} && \Sub\,\Gamma\,\Gamma \\
  \blank;\blank & : \implicit{\Gamma, \Delta, \Theta} && \Sub\,\Gamma\,\Delta \to \Sub\,\Delta\,\Theta \to \Sub\,\Gamma\,\Theta \\
  \pi_1 & : \implicit{\Gamma, \Delta, A} && \Sub\,\Gamma\,(\Delta, A) \to \Sub\,\Gamma\,\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A} && (\sigma : \Sub\,\Gamma\,(\Delta, A)) \to \Tm\,\Gamma\,([ \pi_1\,\sigma ]\, A) \\
  [\blank] \blank & : \implicit{\Gamma,\Delta, A} && (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Delta\,A \to \Tm\,\Gamma\,([\sigma]\, A) \\
  \UU     & : \implicit{\Gamma} && \Ty\, \Gamma \\
  \El     & : \implicit{\Gamma} && \Tm\,\Gamma\,U \to \Ty\,\Gamma \\
  \Pi     & : \implicit{\Gamma} && (A : \Ty\,\Gamma) \to \Ty\,(\Gamma, A) \to \Ty\,\Gamma \\
\end{alignat*}

\begin{alignat*}{5}
[ \idS ]_{\Ty}\,A             & \reduce A \\
[ \sigma ; \tau ]_{\Ty}\,A    & \reduce [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \\
[ \pi_1(\sigma, t) ]_{\Ty}\,A & \reduce [\sigma]_\Ty\,A \\
[ \pi_1(\sigma; \tau) ]_{\Ty}\,A & \reduce [\sigma]_\Ty ([\pi_1\tau]_\Ty \,A) \\
[ \sigma ]_{\Ty}\,\UU           & \reduce \UU \\
[ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma]_{\Tm}{u}) \\
[ \sigma ]_{\Ty}\,(\Pi\,A\,B) & \reduce \Pi\,(\sub{\sigma}{A})\,(\sub{\sigma\uparrow A}{B}) \\
\idS                \uparrow A & \reduce \idS \\
\sigma ; \tau       \uparrow A & \reduce (\sigma \uparrow \sub{\tau}{A} ) ; (\tau \uparrow A) \\
\pi_1(\sigma, t)    \uparrow A & \reduce \sigma \uparrow A \\
\pi_1(\sigma; \tau) \uparrow A & \reduce \sigma \uparrow (\sub{\pi_1 \tau}{A}) ; (\pi_1 \tau \uparrow A) \\
\sigma              \uparrow A & \reduce (\pi_1 \idS ; \sigma , \pi_2 \idS) & \text{otherwiese} \\
 [ \idS ]_{\Tm}\,t                & \reduce t \\
 [ \sigma ; \tau ]_{\Tm}\,t       & \reduce [ \sigma ]_{\Tm}\;([ \tau ]_{\Tm}\;t) \\
 [ \pi_1(\sigma, t) ]_{\Tm}\,t    & \reduce [\sigma]_\Tm\,t \\
 [ \pi_1(\sigma; \tau) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\; ([\pi_1\tau]_\Tm \,t) \\
 [ \sigma ]_{\Tm}\,t              & \reduce [ \sigma ]\,t & \text{otherwise}
\end{alignat*}

\begin{alignat*}{5}
  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma} && {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma} && {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  ;\text{-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, \gamma} && (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} &&\sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau) , [ \sigma ] t \\
  \emptyctx\eta   & : \implicit{\Gamma, \sigma} && \sigma                   && =^{\Sub\,\Gamma\,\emptyctx} & \emptysub \\
  \pi\eta         & : \implicit{\Gamma, A, \sigma} && \sigma                   && =^{\Sub\,\Gamma\,(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma) \\
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_1(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\, A} &&  t \\
  [\idS]t         & : \implicit{\Gamma, A, t} && {[\,\idS\,]\,t}          && =^{\Tm\,\Gamma\,A} && t \\
  [;]t            & :\implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\,\sigma ; \tau\,]\,t} && =^{\Tm\,\Gamma\,[\sigma ; \tau] A} && {[ \sigma ]\,[ \tau ]\,t} \\
\end{alignat*}

\section{Formal definitions in Agda}
\end{document}
