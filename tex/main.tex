
\documentclass[a4paper,UKenglish,numberwithinsect,cleveref,thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}

\title{Type theory as a quotient inductive-recursive type}
\author{Liang-Ting Chen\footnote{Corresponding author; authors are listed in alphabetical order.}}{Institute of Information Science, Academia Sinica, Taiwan \and \url{http://l-tchen.github.io}}{ltchen@iis.sinica.edu.tw}{https://orcid.org/0000-0002-3250-1331}{Supported by the National Science and Technology Council of Taiwan under grant NSTC [funding].}
\author{Tzu-Chun Tsai}{Institute of Information Science, Academia Sinica, Taiwan}{gene0905@icloud.com}{}{Supported by the National Science and Technology Council of Taiwan under grant NSTC 112-2221-E-001-003-MY3.}
\authorrunning{L.-T.~Chen and T.-C.~Tsai}
\Copyright{Liang-Ting Chen and Tzu-Chun Tsai}
\ccsdesc[500]{Theory of computation~Type theory}
\keywords{inductive-inductive types, quotient inductive types, inductive-recursive types, substitution calculus, category with families}
\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{The formal development is hosted at the GitHub repository: \url{https://github.com/genetsai95/DTT-QIIRT}.}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional
\acknowledgements{We'd like to thank Fredrik Nordvall Forsberg, Hsiang-Shang Ko, and Meven Lennon-Bertrand.}%optional

\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{todonotes}

\input{macro.tex}


\begin{document}

\maketitle

\begin{abstract}
  Type theory can be defined in a type theory as a quotient inductive-inductive type, but terms are painstakingly littered with explicit coercions, i.e.\ \transp's, along equality constructors.
  This mess has been dubbed the \emph{transport hell} by the community in private but typically suppressed in presentation for clarity, ignoring the elephant in the room.
  In this paper, we aim for shortening the gap between formal and informal definitions of type theory in type theory using quotient inductive-inductive-recursive types and definitions by overlapping patterns altogether, reducing the use of \transp's.
  As a case study, we investigate (parallel) substitution calculus and type theory with Coquand universes and $\Pi$-types as quotient inductive-inductive-recursive types with meta-theoretic properties proved and compare our definitions with quotient inductive-inductive definitions.
\end{abstract}

\section{Introduction} \label{sec:intro}
Points to elaborate:
\begin{enumerate}
  \item QIITs are littered with transports, causing too much pains while formalising a type theory.
  \item Rewrite rules are popular to make structural rules definitional but requires efforts to justify meta-theoretic properties in general.
  \item Further, the confluence check adopted by \Agda is based on complete development and requires one-step parallel reductions to have a confluent term, making a definition more complicated than necessary.
  \item Moreover, the use of rewrite rules is typically \emph{not} presented and discussed in literature. We are ignoring the elephant in the room.
  \item Instead, definitions by overlapping patterns (in theory) requires strong normalisation and local confluence, making definitions simpler to design.
  \item The rules for type substitutions are \emph{structural} shared with other type theories based on parallel substitution (in particular cwf).
  
\end{enumerate}


\paragraph*{Contributions}
\begin{itemize}
  \item Exploration of the use of quotient inductive-inductive-recursive types and definitions by overlapping patterns.
    In particular, we give in a type theory:
    \begin{itemize}
      \item a definition of parallel substitution calculus;
      \item a definition of type theory with Coquand universes and $\Pi$-types,
    \end{itemize}
   whose type substitution rules are definitional using quotient inductive-inductive-recursive types and definitions by overlapping patterns.
  \item Comparison with other definitions using quotient inductive-inductive types.
\end{itemize}


\subsection{Plan of the paper}
\subsection{Related work}
\paragraph*{Formalisation of type theory in type theory}
\cite{Danielsson2006,Altenkirch2016a}
\cite{Altenkirch2017}

\paragraph*{Single substitution calculus}
\cite{Kaposi2023,Kaposi2024a}
\paragraph*{Schemata of inductive types}
\cite{Kaposi2019}
\cite{Dybjer2003,Dybjer2000,Dybjer1999}

\section{Metatheory and formalisation}
\cite{Pujet2022,Pujet2024,Pujet2022a}
Points to include:
\begin{enumerate}
  \item identity type $x =^{A} y$ for $x, y : A$, dependent identity type, $t =^{P}_{p} u \defeq \transfib{P}{p}{t} =^{P y} u$ for $t : P(x)$ and $u : P(y)$, heterogeneous equality in \Agda $x \simeq y$ for $x : A$ and $y : B$
  \item 
\end{enumerate}

\subsection{Definitions by overlapping patterns}
\cite{Cockx2014,Altenkirch2016a}
\subsection{Quotient inductive-inductive-recursive types}
\subsection{Definitions by rewrite rules}
\cite{Cockx2020,Cockx2021}

Unfortunately, neither general schemata of quotient inductive-inductive-recursive types nor definitions by overlapping patterns have been developed or implemented in existing proof assistants.

\paragraph*{Local confluence}
\paragraph*{Strong normalisation}


\section{Type theories as quotient inductive-inductive-recursive types} \label{sec:QIIRTs}
\subsection{Parallel substitution calculus} \label{subsec:SC}
\begin{alignat*}{3}
  \Ctx   & : \Set                   \\
  \Ty    & : \Ctx \to \Set          \\
  \Sub   & : \Ctx \to \Ctx \to \Set \\
  \Tm    & : (\Gamma : \Ctx) \to \Ty\,\Gamma \to \Set \\
  \emptyctx & : \Ctx \\
  \blank,\blank & : (\Gamma : \Ctx) \to \Ty\,\Gamma \to \Ctx \\
  [\blank]\blank &: \implicit{\Gamma, \Delta} \; \Sub\,\Gamma\,\Delta \to \Ty\,\Delta \to \Ty\,\Gamma \\
  U & : \implicit{\Gamma}\;\Ty\, \Gamma\\
  \emptysub & : \implicit{\Gamma}\;\Sub\,\Gamma\,\emptyctx \\
  \blank,\blank & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,([ \sigma ]_{\Ty} A) \to \Sub\,\Gamma,(\Delta, A) \\
  \idS & : \implicit{\Gamma}\;\Sub\,\Gamma\,\Gamma \\
  \blank;\blank & : \implicit{\Gamma, \Delta, \Theta}\;\Sub\,\Gamma\,\Delta \to \Sub\,\Delta\,\Theta \to \Sub\,\Gamma\,\Theta \\
  \pi_1 & : \implicit{\Gamma, \Delta, A}\;\Sub\,\Gamma\,(\Delta, A) \to \Sub\,\Gamma\,\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\,\Gamma\,(\Delta, A)) \to \Tm\,\Gamma\,([ \pi_1\,\sigma ]\, A) \\
  [\blank] \blank & : \implicit{\Gamma,\Delta, A}\;(\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Delta\,A \to \Tm\,\Gamma\,([\sigma]\, A)
\end{alignat*}


\begin{alignat*}{3}
  [\idS]_T & : \implicit{\Gamma, A}                               && [ \idS ] \,A         && =^{\Ty\,\Gamma} A \\
  [;]_T    & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A} && [ \sigma ; \tau ]\,A && =^{\Ty\,\Gamma} [ \sigma ]\;([ \tau ]\;A) \\
  []U      & : \implicit{\Gamma, \Delta, \sigma}                  && [ \sigma ]\,U        && =^{\Ty\,\Gamma} U
\end{alignat*}

\begin{alignat*}{5}
  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma} && {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma} && {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  ;\text{-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \Xi, \sigma, \tau, \gamma} && (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} && \sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau) , \alert{\transfib{\Tm\,\Gamma}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] t}} \\
  \emptyctx\eta   & : \implicit{\Gamma, \sigma} && \sigma                   && =^{\Sub\,\Gamma\,\emptyctx} & \emptysub \\
  \pi\eta         & : \implicit{\Gamma, \Delta, \sigma} && \sigma                   && =^{\Sub\,\Gamma\,(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma) \\
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_1(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\,([\blank]\,A)}_{\alert{\pi_1\beta}} &&  t \\
  [\idS]_t         & : \implicit{\Gamma, A, t} && {[\,\idS\,]\,t}          && =^{\Tm\,\Gamma}_{\alert{[\idS]_\Ty}}  && t \\
  [;]_t            & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\,\sigma ; \tau\,]\,t} && =^{\Tm\,\Gamma}_{\alert{[;]_{\Ty}}}   && {[ \sigma ]\,[ \tau ]\,t} \\
\end{alignat*}

\begin{example}
  Given substitutions $\sigma : \Sub\;\Gamma\; \Delta$ and $\tau : \Sub\;\Delta\;(\Theta, A)$ for any $A : \Ty\,\Theta$, we may apply the projection $\pi_2$ to the composite $(\sigma; \tau)$ to access the first term $\pi_2(\sigma; \tau)$ of type $[\sigma;\tau] A$ under the context $\Gamma$, and this term should be equal to the first term $\pi_2\,\tau$ of $\tau$ after applying the substitution $\sigma$. 
  In short, the following equality apparently holds
  \[
    \pi_2\,(\sigma ; \tau) = [\sigma] (\pi_2\,\tau)
  \]
  by a back-of-the-envelope calculation
  \begin{equation} \label{eq:pi2-comp-proof}
    \pi_2\,(\sigma ; \tau) 
    = \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))
    = \pi_2\,(\sigma;\pi_1\,\tau, [\sigma]\,(\pi_2\,\tau))
    = [\sigma] (\pi_2\,\tau).
  \end{equation}
  Yet, the left-hand side is a term of type $[\pi_1\,(\sigma;\tau)] A$, but the other is $[\sigma] [\pi_1\,\tau] A$.
  Hence the above identity does not even make sense, since their types do not match.
  Alas, instead, we have to write $\pi_2\,(\sigma ; \tau) =^{\Tm\,\Gamma}_{p} [\sigma] (\pi_2\,\tau)$ or, equivalently
  \[
    ([\pi_1(\sigma; \tau)]\,A, \pi_2(\sigma; \tau)) =^{(A : \Ty\,\Gamma) \times (\Tm \Gamma A)} ([\sigma]\,[\pi_1\,\tau]A, [\sigma] (\pi_2\,\tau))
  \]
  as inhabitants of a $\Sigma$-type, so we can reason about term equalities along with type equalities.
  Moreover, in~\eqref{eq:pi2-comp-proof} we have used the rule $\mathsf{concat}$ which introduced another transported term, so we will have to eliminate that $\transp$ to derive the right hand side.

  To better illustrate the annoyance, we provide a complete proof.
  First, we claim each of the following steps holds:
  \begin{alignat}{3}
         & ([\pi_1(\sigma; \tau)]\,A                    &&, \pi_2\,(\sigma ; \tau)) \label{eq:pi2-proof-1} \\
    = {} & ([\pi_1(\sigma; (\pi_1\tau , \pi_2\tau))]\,A &&, \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))) \\
    = {} & ([\pi_1(\sigma;\pi_1\,\tau, t)]\,A &&, \pi_2\,(\sigma;\pi_1\,\tau, t)) \nonumber \\
    = {} & ([\pi_1(\sigma;\pi_1\,\tau, t)]\,A &&, \pi_2\,(\sigma;\pi_1\,\tau, t)) \nonumber \\
    = {} & (\sub{\sigma;\pi_1\tau}{A} &&, [\sigma] (\pi_2\,\tau)) \nonumber
  \end{alignat}
  where $p \judgeq [;]_{\Ty}^{-1} : \sub{\sigma}{\sub{\pi_1\,\tau}{A}} \to \sub{\sigma; \pi_1 \tau}{A}$ and $t \judgeq\transfib{\Tm\,\Gamma}{p}{[\sigma]\,(\pi_2\,\tau)}$.
\end{example}

\begin{alignat*}{3}
[ \idS ]_{\Ty}\,A             & \jdeq A \\
[ \sigma ; \tau ]_{\Ty}\,A    & \jdeq [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \\
[ \pi_1(\sigma, t) ]_{\Ty}\,A & \jdeq [\sigma]_\Ty\,A \\
[ \sigma ]_{\Ty}\,U           & \jdeq U
\end{alignat*}

\begin{alignat*}{3}
  \mathsf{idr}    & : {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \mathsf{idl}    & : {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  ;\text{-}\mathsf{assoc} & : (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau) , [ \sigma ] t \\
  \emptyctx\eta   & : \sigma                   && =^{\Sub\,\Gamma\,\emptyctx} & \emptysub \\
  \pi\eta         & : \sigma                   && =^{\Sub\,\Gamma\,(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma) \\
  \pi_1\beta      & : \pi_1(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\, A} &&  t \\
  [\idS]t         & : {[\,\idS\,]\,t}          && =^{\Tm\,\Gamma\,A} && t \\
  [;]t            & : {[\,\sigma ; \tau\,]\,t} && =^{\Tm\,\Gamma\,[\sigma ; \tau] A} && {[ \sigma ]\,[ \tau ]\,t} \\
\end{alignat*}

\subsection{... with Coquand universes} \label{subsec:SC+U}
\cite{Coquand2013}
\begin{alignat*}{3}
[ \idS ]_{\Tm}\,t          & = t \\
[ \sigma ; \tau ]_{\Tm}\,t & = [ \sigma ]_{\Tm}\;[ \tau ]_{\Tm}\;t \\
[ \sigma ]_{\Tm}\,t        & = [ \sigma ]\,t & \text{otherwise}  \\
\end{alignat*}
\subsection{... and \texorpdfstring{$\Pi$}{Π}-types} \label{subsec:SC+U+Pi}

\section{Metatheoretic properties}

\section{Future work}

\paragraph*{Type theory in (observational) type theory}

\paragraph*{Formalising definitions by overlapping patterns}

\paragraph*{A general schema of quotient inductive-inductive-recursive types}

\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}

\appendix

\begin{conjecture}\label{testenv-conjecture}
\end{conjecture}

\begin{claim}\label{testenv-claim}
\end{claim}

\begin{claim*}\label{testenv-claim2}
\end{claim*}

\begin{claimproof}
\end{claimproof}
\begin{lstlisting}[caption={Formal definition in \Agda},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
for i:=maxint to 0 do 
begin 
    j:=square(root(i));
end;
\end{lstlisting}

\end{document}
