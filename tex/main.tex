\documentclass[a4paper,UKenglish,numberwithinsect,cleveref,thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}

\title{Type theories as quotient inductive-recursive types}
\author{Liang-Ting Chen\footnote{Corresponding author; authors are listed in alphabetical order.}}{Institute of Information Science, Academia Sinica, Taiwan \and \url{http://l-tchen.github.io}}{ltchen@iis.sinica.edu.tw}{https://orcid.org/0000-0002-3250-1331}{Supported by the National Science and Technology Council of Taiwan under grant NSTC 114-2222-E-001-001-MY3.}
\author{Fredrik Nordvall Forsberg}{Department of Computer and Information Sciences, University of Strathclyde, UK \and \url{https://fredriknf.com}}{fredrik.nordvall-forsberg@strath.ac.uk}{https://orcid.org/0000-0001-6157-9288}{Supported by the Engineering and Physical Sciences Research Council [EP/Y000455/1].}
\author{Tzu-Chun Tsai}{Institute of Information Science, Academia Sinica, Taiwan}{gene0905@icloud.com}{}{Supported by the National Science and Technology Council of Taiwan under grant NSTC 112-2221-E-001-003-MY3.}
\authorrunning{L.-T.~Chen, F.~Nordvall Forsberg, and T.-C.~Tsai}
\Copyright{Liang-Ting Chen, Fredrik Nordvall Forsberg, and Tzu-Chun Tsai}
\ccsdesc[500]{Theory of computation~Type theory}
\keywords{inductive-inductive types, quotient inductive types, inductive-recursive types, substitution calculus, category with families}
\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{The formal development is hosted at the \textsc{GitHub} repository: \url{https://github.com/L-TChen/TTasQIIRT}}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional
\acknowledgements{We'd like to thank Hsiang-Shang Ko and Meven Lennon-Bertrand.}%optional

\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{YYY}
\EventNoEds{1}
\EventLongTitle{10th International Conference on Formal Structures for Computation and Deduction (FSCD 2025)}
\EventShortTitle{FSCD 2025}
\EventAcronym{FSCD}
\EventYear{2025}
\EventDate{July 14--20, 2025}
\EventLocation{Birmingham, United Kingdom}
\EventLogo{}
\SeriesVolume{XX}
\ArticleNo{XX}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage{float}
\usepackage{manfnt}
\newcommand{\danger}{\marginpar[\hfill\dbend]{\dbend\hfill}}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},color={pink},#1]{#2}}
\newcommand{\Gene}[2][]{\todo[inline,author={Gene},caption={},#1]{#2}}
\newcommand{\Fredrik}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}
\lstset{
    breaklines=true,
    breakatwhitespace=true,
    literate=%
      {≡}{$\equiv$}1
      {Γ}{$\Gamma$}1
      {Δ}{$\Delta$}1 
      {→}{$\to$}1
      {≅}{$\cong$}1
}

\input{macro.tex}


\begin{document}

\maketitle

\begin{abstract}
  Defining type theory in type theory is a long-standing benchmark for the strength and expressivity of type theory and proof assistants.
  Altenkirch and Kaposi used quotient inductive-inductive types to elegantly represent exactly the well-typed terms of type theory in intensional type theory, with the price to be paid that terms frequently contain transports along equality constructors.
  As a result, proofs need to painstakingly account for coercions alongside the interesting part.
  This %mess
  has been dubbed `transport hell', but is typically suppressed in informal presentation for clarity, hiding the gap between the intention and the formalisation.
  In this paper, we aim to shorten this gap, using quotient inductive-inductive-recursive types and definitions by overlapping patterns, reducing the use of transports.
  As a case study, we investigate type theory with a universe and $\Pi$-types, and compare our development with one using quotient inductive-inductive types.
\end{abstract}

\section{Introduction} \label{sec:intro}

Metaprogramming and mechanised metatheory in a type-theoretic proof assistant relies on having an internal representation of type theory within type theory itself.
%
In the spirit of type theory, we would like to represent well scoped and well typed terms only --- this also has technical advantages, such as theorem statements not having to deal with impossible cases, or separately having to prove wellformedness lemmas, etc.
%
Doing this effectively seems to require several sophisticated features of the host type theory, most notably advanced inductive definitions.
%
For example, inductive families~\cite{Dybjer1994} can be used to represent the simply typed lambda calculus~\cite{Altenkirch1999}, while some kind of simultaneous definitions such as inductive-recursive~\cite{Dybjer2000} or inductive-inductive~\cite{Nordvall-Forsberg2014} definitions seem to be required for dependent type theory~\cite{Danielsson2006,Chapman2009}.
%
This is not just a matter of the pure strength of the host theory, but also expressivity and convenience: while it is known how to reduce inductive-inductive definitions to inductive families in principle~\cite{Kaposi2020a}, the resulting development would be considerably harder to work with, most likely exhausting the resources of both the proof assistant and its user.

Altenkirch and Kaposi~\cite{Altenkirch2016a} showed that by employing \emph{quotient inductive-inductive types}~\cite{Altenkirch2018}, the internal representation of well typed terms could be significantly simplified, since equations such as $\beta$- and $\eta$-equality can be represented by the identity type thanks to equality constructors.
%
Yet, there is a general phenomenon, called `transport hell', when working with quotient inductive-inductive types: to make use of equalities in later constructors and when using the eliminator for the type, the equalities need to be transported across.
%

A typical workaround in practice \cite{Kaposi2019,Kaposi2024a} is to add equality constructors as rewrite rules after an inductive definition and further identify equality constructors with the reflxivity proof.
%
As the host theory is assumed to satisfy the uniqueness of identity proof and function extensionality, this workaround can be justified by conservativity of equality reflection over intensional type theory~\cite{Hofmann1996,Winterhalter2019,Kapulkin2025}.
%
However, this workaround is computationally ill-behaved, as confluence does not hold in general.
Also, the presentation often differs from the actual definition of type theory in intensional type theory.
%
Any method that reduces the friction introduced by the use of equality constructors without compromising on computational properties and the gap between formalisation and presentation seem worth exploring.
%

In this paper, we show that the development can be further streamlined by combining quotient inductive-inductive types and inductive-recursive types, called quotient inductive-inductive-recursive types (\emph{QIIRT}s for short).
%
The basic idea, following a suggestion by Kaposi~\cite{Kaposi2023} and a precursor by Dybjer~\cite{Dybjer1996} and Danielsson~\cite{Danielsson2006}, is to replace the inductively defined action of a substitution on a type with a recursive definition, which computes.
%
Our development also makes use of another feature not usually found in standard presentations of type theory: recursive pattern matching definitions with overlapping patterns.
%
This is helpful to again avoid transport hell in the form of equations that do not reduce due to the standard translation of pattern matching to case trees.
%
As a result, many equations will hold strictly, and we can avoid the use of transport in the definition of type theory itself (which does not seem possible with quotient inductive-inductive types alone).
%

%However, we found that using quotient inductive-inductive-recursive types alone were not sufficient for a smooth development.
%%
%%Not only do we want the action of substitutions on types to compute strictly, but we also want as many equations to hold strictly as possible:
%%
%%on the one hand, we want substitutions to distribute over type formers, but on the other hand we want substitutions to satisfy composition and unit laws of the category of context and substitutions up to strict equality.
%%
%Instead, we also needed to make use of functions defined by overlapping patterns.
%%
%In a proof assistant such as Agda, this can be emulated by Agda's experimental support for rewrite rules, but with an additional proof burden on the user to show (informally) that their use is justified meta-theoretically.
%%
%To get some help with this task by Agda's confluence checker, it is often necessary to needlessly complicate a definition to convince the checker that the proposed rewrite rules are indeed confluent.

%
We emphasise that, following a fine tradition of previous attempts to represent type theory in type theory~\cite{Danielsson2006,Chapman2009,Altenkirch2016a}, we are making use of type-theoretic features that are so far not yet well understood or foundationally well motivated.
Nevertheless, \Agda can be convinced to accept our formal implementation, using user-defined rewrite rules~\cite{Cockx2020,Cockx2021}.
Indeed, we also see this paper as a case study to motivate further developments for quotient inductive-inductive-recursive types and overlapping patterns.

\subparagraph*{Contributions}
This paper explores the use of QIIRTs and definitions by overlapping patterns to define type theories in intensional type theory.
In particular, we give
\begin{itemize}
  \item definitions of parallel substitution calculus, type theories with a universe and $\Pi$-types,
  \item with their elimination principles and the standard model;
  \item a comparison with these definitions using quotient inductive-inductive types.
\end{itemize}

\subparagraph*{Plan of the paper}
In the rest of the paper, we introduce the metatheory in \cref{sec:meta}.
Then, we develop type theories formulated as QIIRTs in \cref{sec:QIIRTs}, followed by their elimination principles and usage in \cref{sec:models}.
We outline the \Agda formal implementation in \cref{sec:formal-implementation}, and we conclude with related and future work in \cref{sec:conclusion}.

\section{Metatheory and formalisation} \label{sec:meta}

We work in intensional Martin-L\"of type theory with uniqueness of identity proofs. In \cref{sec:models,sec:formal-implementation}, we also assume function extensionality and $\eta$-rules for $\Pi$-types and $\Sigma$-types.
%
We mostly follow the notational conventions of the HoTT book~\cite{UFP2013} (even if we do not assume the univalence axiom), except that we write dependent function types using \Agda notation $(x : A) \to B\,x$.
%
We are further inspired by \Agda in writing $\implicit{x}\;B\,x$ for $(x : A) \to B\,x$ when $x$ is treated as an `implicit' argument which should be clear from the context.
We write $\Set_i$ for the hierarchy of universes with the level index $i$ suppressed.

We write $x \jdeq y$ for strict equality, $x =^{A} y$ for the identity type stating that elements $x : A$ and $y : A$ of a type $A$ are equal, and $\dpath{P}{p}{t}{u}$ for the `dependent' identity type where $P : A \to \Set$, $t : P\,x$, $u : P\,y$ and $p : x =^A y$. One possible realisation of this type is as $t =^{P}_{p} u \defeq \transfib{P}{p}{t} =^{P\,y} u$, where $\transfibf{P} : (p : x =^A y) \to P\,x \to P\,y$ is the operation to transport values between the type family $P$ along the identity type.
%

We have implemented our definitions and proofs in \Agda; see \cref{sec:formal-implementation} for details.
However, some statements are metatheoretical and not checked in \Agda, while others are only partially checked by \Agda, as proof obligations are given manually. %for postulated equality constructors.
We have marked such `informal' proofs with the symbol \resizebox*{!}{\baselineskip}{\textdbend}.

\subsection{Inductive-recursive types}
\LT[noinline]{Shorten this section}
\LT[noinline]{the recursion part of IR is not given by the elimination rule}

An ordinary inductive type $A$, such as the type of natural numbers $A = \mathbb{N}$, allows functions out of the type $f : A \to X$ to be defined by recursion, using an elimination rule which says that such a function $f$ is defined by its values $f(\mathsf{c}_i\,x)$ on all of the constructors $\mathsf{c}_i$ of~$A$. For example, a function $f: \mathbb{N} \to X$ is given by the values $f(0)$ and $f(\suc\,n)$, where the latter might refer to the already computed value $f(n)$.
%
The type is first defined inductively by listing its constructors, and then afterwards recursive functions can be defined out of it.

In contrast, an inductive-recursive type is defined inductively \emph{simultaneously} with a recursively defined function out of it. The prototypical example is Martin-L\"of's universe \`a la Tarski, where a type $U$ of codes for small types is defined simultaneously with a `decoding' function $T : U \to \Set$ which maps each code to the type it represents. Crucially, the code for dependent function types
\[
  \pi : (a : U) \to (T(a) \to U) \to U
\]
with $T(\pi(a, b)) = (x : T\,a) \to T(b\, x)$ only makes sense because we already have access to the decoding function $T$.
%
Inductive-recursive types (IRT), introduced by Dybjer~\cite{Dybjer2000}, were extensively studied by Dybjer and Setzer~\cite{Dybjer1999,Dybjer2003}.
The general schema allows one to define a type $A$ inductively, together with a recursive function $F : A \to D$, for some fixed (possibly large) type $D$.

An IRT $(A, F)$ comes with an elimination rule that allows to define a dependent function  $f : (x : A) \to P(x)$ by giving values $f(\mathsf{c}_i\,x)$ on all of the constructors $\mathsf{c}_i$ of $A$, again reflecting that $A$ is inductively defined.
%
However, note that the recursive function $F : A \to D$ is \emph{not} defined using this elimination rule, but part of the definition of the type itself.
%
In particular, the elimination rule can be used to define endofunctions on $A$, but the recursive function  $F : A \to D$ must always target a fixed pre-existing type $D$.
%
In this work, we will consider an extension \emph{generalised} IRTs, where also $F : A \to A$ is allowed.
%
Such IRTs were previously used by Danielsson~\cite{Danielsson2006} to represent type theory in type theory, and are discussed by Kaposi~\cite{Kaposi2023}.
%
Their general metatheory would be interesting future work.

%\LT{Mention that the recursion part of induction-recursion are already not defined by elimination rule.}


\subsection{Quotient inductive-inductive and quotient inductive-recursive types}
% \subsection{Quotient inductive(-inductive)-recursive types}

Quotient inductive types (QITs) are a special case of higher inductive types~\cite{Lumsdaine2020}, where constructors can introduce not only new elements but also new equalities between the introduced elements.
%
Since we assume the uniqueness of identity proofs, all QITs are implicitly truncated to be sets in the sense of homotopy type theory.
%
For example, the type of \emph{join lists} $\JList{A}$ can be given by the QIT
with the following constructors:
%\begin{figure}[H]
\begin{minipage}{.35\textwidth}
\begin{alignat*}{3}
  \Jnil                    & : \implicit{A}      && \JList{A} \\
  \Jsing{\blank}           & : \implicit{A}      && A \to \JList{A} \\
  \Jconcat{\blank}{\blank} & : \implicit{A}      && \JList{A} \to \JList{A} \to \JList{A}
\end{alignat*}
\end{minipage}
\begin{minipage}{.64\textwidth}
\begin{alignat*}{3}
  \mathsf{idr}             & : \implicit{\ell}\; && (\Jconcat{\ell}{\Jnil}) =^{\JList{A}} \ell \\
  \mathsf{idl}             & : \implicit{\ell}\; && (\Jconcat{\Jnil}{\ell}) =^{\JList{A}} \ell \\
  \mathsf{assoc}           & : \implicit{\ell_0, \ell_1, \ell_2}\; && \Jconcat{(\Jconcat{\ell_0}{\ell_1})}{\ell_2} =^{\JList{A}} \Jconcat{\ell_0}{(\Jconcat{\ell_1}{\ell_2})}
\end{alignat*}
\end{minipage}
%\end{figure}
\vskip\belowdisplayskip\noindent
A quotient inductive-inductive type~\cite{Altenkirch2018} (QIIT) further allows the simultaneous definition of a type $A$ and a type family $B : A \to \Set$, where both $A$ and $B$ are defined inductively --- this is different from an inductive-recursive definition of $A$ and $F : A \to D$, where $F$ is defined recursively.
%; indeed, inductive-inductive definitions only make sense when $D = \Set$.
The metatheory of QIITs has been studied by Altenkirch et al.~\cite{Kaposi2018,Kaposi2019,Kovacs2020}

We can also define join lists as a quotient inductive-\emph{recursive} type, as follows: the type $\JList{A}$ is defined simultaneously with a recursion $\flatten : \implicit{A}\;\JList{A} \to \List{A}$ which flattens a join list into an ordinary list. We keep the constructors $\Jnil$, $\Jsing{\blank}$ and $\Jconcat{\blank}{\blank}$, but replace $\mathsf{idl}$, $\mathsf{idr}$ and $\mathsf{assoc}$ by a single constructor
\[
  \mathsf{nf} : \implicit{A}\;(\ell, \ell' : \JList{A}) \to \flatten\,\ell =^{\mathsf{List}\,A} \flatten\,\ell' \to \ell =^{\JList{A}} \ell'
\]
which states that join lists are equal as soon as their flattenings are equal. For $\flatten$ to be well defined, it needs to respect the $\mathsf{nf}$ constructor, but this is a tautology: if $\ell =^{\JList{A}} \ell'$ because $\flatten\,\ell =^{\mathsf{List}\,A} \flatten\,\ell'$, then obviously $\flatten\,\ell =^{\mathsf{List}\,A} \flatten\,\ell'$.

%Shulman~\cite{Shulman2014} considered combining higher inductive types and inductive-recursive types, but the foundational status of this combination is underdeveloped. We will also make use of such a combination, which gives additional motivation to study its metatheory in future work.


\subsection{Definitions by overlapping patterns} \label{sec:meta:overlapping}
Functions are typically defined informally using pattern matching for convenience and readability. Formally, however, they are either defined using an explicit pattern-matching construct or elaborated into case trees, which correspond to the \emph{eliminator}, following \emph{first-match} semantics~\cite{Cockx2020a} and employing termination and completeness checking.
This elaboration offers the conventional notation, while making computational behaviour opaque and favouring asymmetric definitions.
For example, two definitions of addition below
%\begin{figure}[H]%
\begin{minipage}{.48\textwidth}
  \begin{alignat*}{5}
    \blank  & + \blank     && : \N \to \N \to \N \\
    0       &  + m         && = m  \\
  n         &  + 0         && = m  \\
  (\suc\;n) &  + m         && = \suc\;(n + m) \\
  n         &  + (\suc\;m) && = \suc\;(n + m)
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  \blank         & +'\blank     && : \N \to \N \to \N \\
  0              & +' m         && \defeq m  \\
  (\suc\;n)      & +' 0         && \defeq \suc\;n \\
  (\suc\;n)      & +' (\suc\;m) && \defeq \suc\;(n +' \suc\;m)
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip\noindent
%\caption{Two seemingly different definitions of addition}
%\label{fig:additions}
%\end{figure}
are the same after elaboration in \Agda: eliminating the first argument of $+$ distinguishes $0$ and $\suc\;n$ and refines the second and the third clauses into clauses of $+'$, making the fourth clause useless.
Each clause of $+'$ is strict (hence the symbol $\defeq$ is used) while clauses of $+$ are not necessarily strict by definition.
%This semantics for function definitions decides how definitions reduce and therefore how identities are proved.

Cockx~\cite{Cockx2014} explores an alternative semantics for pattern matching, where all clauses are strict, even in the presence of \emph{overlapping patterns}.
Thus, when a function $f$ is defined with overlapping patterns, the notation $f\;\overrightarrow{p_i} \reduce t_i$ is used to emphasize its reduction behaviour.
Under this semantics, each clause of $+$ is strictly equal to its right-hand side, also allowing the symmetry addition to be proved commutative directly by induction on $n$ and $m$.

A key requirement for definitions with overlapping patterns is that, in addition to termination and completeness, any clause must eventually compute to the same term, i.e.\ $f$ is confluent.
Cockx shows that if a definition of $f$ is
\begin{enumerate}
  \item \emph{structurally recursive}~\cite{Abel2002}, i.e.\ arguments of recursive calls are structurally smaller, and
  \item \emph{locally confluent}, i.e.\ for any two function clauses $f\;\overrightarrow{p_1} \reduce t_1$ and $f\;\overrightarrow{p_2} \reduce t_2$ with a most general unifer $\sigma$ for $\overrightarrow{p_1}$ and $\overrightarrow{p_2}$, terms $\sigma t_1$ and $\sigma t_2$ have the same normal form, 
\end{enumerate}
then $f$ is confluent---essentially a variant of Newman's Lemma~\cite{Newman1942}.
We call a diagram $\sigma t_2 \Leftarrow f\;\sigma\overrightarrow{p_1} \Rightarrow \sigma t_1$ used in the analysis of local confluence a \emph{local peak}.

\LT[noinline]{remark that recursions in IR are not defined by elimination rules}

\section{Type theories as quotient inductive-inductive-recursive types} \label{sec:QIIRTs}

We begin with a recall of the definition of substitution calculus~\cite{Martin-Lof1992} as a QIIT, emphasising how the use of transports in its very definition complicates formal reasoning.
We then introduce its QIIRT counterpart (\cref{subsec:SC-QIIRT}) which shortens the gap between formal and informal reasoning, and develop a type theory with a universe (\cref{subsec:SC+U}) of small types, $\Pi$-types (\cref{subsec:SC+U+Pi}), and other type formers (\cref{subsec:SC+U+Pi+more}).

\subsection{Substitution calculus as a quotient inductive-inductive type} \label{subsec:SC-QIIT}

Substitution calculus has a type $\Ctx$ of contexts, a type $\Ty\,\Gamma$ of types in context $\Gamma : \Ctx$, a type $\Sub\;\Gamma\;\Delta$ of substitutions from context $\Gamma$ to context $\Delta$, and a type $\Tm\;\Gamma\;A$ of $A$-typed terms in $\Gamma$. 
This amounts to the following type families, mutually inductively defined:
\begin{align*}
  \Ctx   & : \Set                   & \Sub   & : \Ctx \to \Ctx \to \Set \\
  \Ty    & : \Ctx \to \Set          & \Tm    & : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Set
\end{align*}
$\Ctx$ has two constructors: $\emptyctx$ for the empty context, and $\blank,\blank$ for context extension, typed as
\[
  \emptyctx : \Ctx
  \qquad\qquad
  \blank,\blank : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Ctx.
\]
Note that a context extension $\Gamma , A$ is only wellformed if $A : \Ty\;\Gamma$, ensuring overall wellformedness of contexts, but requiring contexts and types to be defined simultaneously.

Type substitution takes a substitution $\sigma : \Sub\;\Gamma\;\Delta$ and an inhabitant $A : \Ty\;\Delta$ to form a type under $\Gamma$, i.e.\ with $\Gamma$ and $\Delta$ being implicit type substitution as a constructor has type
\begin{alignat*}{3}
  [\blank]\blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma
\end{alignat*}

\Fredrik[noinline]{Could we change this to $A[\sigma]$ instead?}
\LT[noinline]{I am okay with changing it in the paper: This notation is used in the formalisation to avoid using $\comp$ for substitution composition}
\LT[noinline]{The rule \textsf{concat} doesn't look like concatenation with the $\tau \comp \sigma$ because the $\sigma$ is a snoc-list.}

Since $\Ty$ is inductively defined, we add a base case $\UU : \implicit{\Gamma} \Ty\,\Gamma$ to ensure that $\Ty\;\Gamma$ is not empty.
%for every $\Gamma$:
%
%If we were defining the notion of cwfs, type substitution would be enough for $\Ty$.
%For our inductive definition (i.e.\ the initial cwf), however, we need a base case in $\Ty\;\Gamma$, otherwise the type $\Ty$ would be empty as well as other types.
%Hence another constructor is introduced:
%\begin{alignat*}{3}
%  \UU & : \implicit{\Gamma} & \Ty\, \Gamma.
%\end{alignat*}
For now, $\UU$ serves as a constant, but we will reuse $\UU$ for the type of small types later.

Substitutions from $\Gamma$ to $\Delta$ can be understood intuitively as (snoc-)lists of terms of type $A$ under the context $\Gamma$ for each $A$ in $\Delta$: we have the empty substitution $\emptysub$, and substitution extensions $\sigma, t$ which are intended to substitute the most recently bound variable by the term~$t$, and act like $\sigma$ on the other variables:
\[
  \emptysub : \implicit{\Gamma}\;\Sub\;\Gamma\;\emptyctx
  \qquad\qquad
  \blank,\blank : \implicit{\Gamma, \Delta, A}\; (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\;\Gamma\;([ \sigma ]\, A) \to \Sub\;\Gamma\;(\Delta, A).
\]
Note that type substitution $[\sigma]\,A$ is needed, because $A$ is well-formed in context $\Delta$ rather than in $\Gamma$.
We also ask for identity substitutions $\idS$ and compositions $\sigma;\tau$
%because the substitution calculus is supposed to be the initial \emph{category} with families:
%Substitutions also have the identity substitution $\idS$ and composition $\blank;\blank$ (because substitution calculus is the initial \emph{category} with families),
\[
  \idS : \implicit{\Gamma}\; \Sub\;\Gamma\;\Gamma
  \qquad\qquad \blank;\blank : \implicit{\Gamma, \Delta, \Theta}\;\Sub\;\Gamma\;\Delta \to \Sub\;\Delta\;\Theta \to \Sub\;\Gamma\;\Theta.
\]
These need to satisfy certain laws, which we introduce later as equality constructors.
Context extension is characterised by its projections, which picks out the rest of the context and the most recent variable
%Context comprehension is given by projections from \emph{non-empty} substitutions $\sigma : \Sub\;\Gamma\;(\Delta, A)$ for its \emph{tail} and its \emph{head}:
\begin{alignat*}{3}
  \pi_1 & : \implicit{\Gamma, \Delta, A}\;\Sub\;\Gamma\;(\Delta, A) \to \Sub\;\Gamma\;\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\;\Gamma\;(\Delta, A)) \to \Tm\;\Gamma\;([ \pi_1\,\sigma ]\, A)
\end{alignat*}
respectively.
Again, type substitution $[\pi_1\,\sigma]\,A$ is needed for~$\pi_2$, because $A$ is well-formed in context $\Delta$ instead of $\Gamma$.
Finally, we have term substitution, which given $\sigma : \Sub\;\Gamma\;\Delta$ turns terms in $\Delta$ to terms in $\Gamma$, appropriately preserving the type, which is also substituted:
\begin{alignat*}{3}
  [\blank] \blank & : \implicit{\Gamma,\Delta, A}\;(\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Delta\;A \to \Tm\;\Gamma\;([\sigma]\, A).
\end{alignat*}
%Note that $[\blank]\blank$ is overloaded for type and term substitution.

The structural rules for type substitution are stipulated by following equality constructors:
\begin{alignat*}{3}
  [\idS]_{\Ty} & : \implicit{\Gamma, A}                               && [ \idS ] \,A           && =^{\Ty\,\Gamma}\;A \\
  [;]_{\Ty}    & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A}\;&& [ \sigma ; \tau ]\,A  && =^{\Ty\,\Gamma}\;[ \sigma ]\,([ \tau ]\,A) \\
  []\UU      & : \implicit{\Gamma, \Delta, \sigma}                    && [ \sigma ]\,\UU        && =^{\Ty\,\Gamma}\;\UU
\end{alignat*}

The codomain $\Delta$ of a substitution $\sigma:\Sub\;\Gamma\;\Delta$ also tells the number of terms in $\sigma$, giving rise to two $\eta$-laws --- one for $\Delta$ being empty, and one for $\Delta$ being non-empty:
\[
  \emptyctx\eta : \implicit{\Gamma, A, \sigma}\; \sigma        =^{\Sub\,\Gamma\,\emptyctx} \; \emptysub
  \qquad\qquad
  \pi\eta       : \implicit{\Gamma, \Delta, \sigma}\; \sigma   =^{\Sub\,\Gamma\,(\Delta, A)} (\pi_1 \sigma, \pi_2 \sigma).
\]

The laws for substitution composition are stipulated using equality constructors, where, for the first time, we see the need to adjust the types involved with a $\transp$ in order for both sides to have the same type.
\begin{alignat*}{5}
  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma} && {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma} && {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \text{;-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \Xi, \sigma, \tau, \gamma}\; && (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} \; && \sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} \; &&  (\sigma ; \tau) , \alert{\transfib{\Tm\,\Gamma}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] t}}
\end{alignat*}
%
Composition of substitutions $\blank;\blank$ acts like a list concatenation, so
we would expect $\sigma; (\tau, t)$ to be the same thing as $(\sigma; \tau), [\sigma]\,t$. However $[\sigma]\,t$ is of type $\Tm\;\Gamma\;([\sigma]\,[\tau]\;A)$, but the extension $(\sigma; \tau), [\sigma]\,t$ requires $[\sigma]\,t$ to have type $\Tm\;\Gamma\;([\sigma; \tau]\,A)$ instead. Of course, we have an equality constructor $[;]_{\Ty}^{-1}\colon [\sigma]\,[\tau]\;A = [\sigma;\tau]\,A$ which we can transport along to fix up the equation.

%$\sigma; (\tau, t)$ is intuitively equal to $(\sigma; \tau), [\sigma]\,t$ whereas the term $t$ is of type $\Tm\;\Delta\;([\tau]\;A)$. 
%However, by the type of substitution extension, $[\sigma]\,t$ requires to be of type $\Tm\;\Gamma\;([\sigma; \tau]\,A)$ instead, so we have to transport $[\sigma]\,t$ explicitly along $[;]_{\Ty}^{-1}\colon [\sigma]\,[\tau]\;A = [\sigma;\tau]\,A$ to obtain a term of type $\Tm\;\Gamma\;([\sigma;\tau]\;A)$.

The first and second projections of $(\sigma, t)$ should obviously be $\sigma$ and $t$ respectively
\begin{alignat*}{5}
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_1(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\,([\blank]\,A)}_{\alert{\pi_1\beta}} &&  t, 
\end{alignat*}
but again, note that the type of $\pi_2\beta$ only makes sense because we can transport along $\pi_1\beta$ to make sure both sides of the equation have the same type: $\pi_2(\sigma, t)$ is an habitant of $\Tm\;\Gamma\;([\pi_1\,(\sigma, t)]\,A)$ instead of $\Tm\;\Gamma\;([\sigma]\,A)$.
%whereas $\pi_2(\sigma, t)$ is an habitant of $\Tm\;\Gamma\;([\pi_1\,(\sigma, t)]\,A)$ instead of $\Tm\;\Gamma\;([\sigma]\,A)$ on the right-hand side. 
%Therefore, we have to transport $\pi_2(\sigma, t)$ along $\pi_1\beta$, so the above equality constructor is, in fact, $\transfib{\Tm\;\Gamma\;([\blank]\,A)}{\pi_1\beta}{\pi_2(\sigma, t)} =^{\Tm\;\Gamma\;([\sigma]\,A)} t$.
%
Similarly, for term substitution, terms are transported along the corresponding rules:
\[
  [\idS]_{\Tm} : \implicit{\Gamma, A, t}\; {[\,\idS\,]\,t} =^{\Tm\;\Gamma}_{\alert{[\idS]_\Ty}} t
  \qquad\qquad
  [;]_{\Tm}    : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t}\; {[\,\sigma ; \tau\,]\,t} =^{\Tm\;\Gamma}_{\alert{[;]_{\Ty}}}{[\, \sigma\,]\,[\,\tau\,]\,t}
\]
%equivalent to the following (homogeneous) identities
%\[
%  \transfib{\Tm\;\Gamma}{[\idS]_{\Ty}}{[\idS]\,t} =^{\Tm\,\Gamma\,A} t
%  \quad\text{and}\quad
%  \transfib{\Tm\;\Gamma}{[;]_{\Ty}}{[\sigma;\tau]\,t} =^{\Tm\,\Gamma\,([\sigma]\,[\tau]A)} [\sigma]\,[\tau]\,t
%\]
%respectively.
Constructors introduced so far complete the inductive definition of substitution calculus.

The use of transports in the formal definition fixes type mismatches but hinders equational reasoning about these terms even for a simple fact below.
\begin{example}\label{ex:pi2-comp}
  Given substitutions $\sigma : \Sub\;\Gamma\; \Delta$ and $\tau : \Sub\;\Delta\;(\Theta, A)$ for any $A : \Ty\,\Theta$, we may apply the projection $\pi_2$ to the composite $(\sigma; \tau)$ to access the first term $\pi_2(\sigma; \tau)$ of type $[\sigma;\tau] A$ under the context $\Gamma$, and this term should be equal to the first term $\pi_2\,\tau$ of $\tau$ after applying the substitution $\sigma$. 
  In short, the following identity apparently holds
  \[
    \pi_2\,(\sigma ; \tau) = [\sigma] (\pi_2\,\tau)
  \]
  and is checked by a back-of-the-envelope calculation
  \begin{equation} \label{eq:pi2-comp-proof}
    \pi_2\,(\sigma ; \tau) 
    = \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))
    = \pi_2\,(\sigma;\pi_1\,\tau, [\sigma]\,(\pi_2\,\tau))
    = [\sigma] (\pi_2\,\tau).
  \end{equation}
  Yet, the left-hand side is a term of type $[\pi_1\,(\sigma;\tau)] A$, but the other is $[\sigma] [\pi_1\,\tau] A$.
  Hence the above identity does not even make sense, since their types do not match.
  Alas, instead, we have to write $\pi_2\,(\sigma ; \tau) =^{\Tm\,\Gamma}_{p} [\sigma] (\pi_2\,\tau)$ for some $p: [\pi_1(\sigma; \tau)]\,A = [\sigma]\,[\pi_1\tau]\,A$ or, equivalently
  \begin{equation}\label{eq:pi2-comp-real-proof}
    ([\pi_1(\sigma; \tau)]\,A, \pi_2(\sigma; \tau)) =^{(A : \Ty\,\Gamma) \times (\Tm \Gamma A)} ([\sigma]\,[\pi_1\,\tau]A, [\sigma] (\pi_2\,\tau))
  \end{equation}
  as inhabitants of a $\Sigma$-type, so we can reason about term equalities along with type equalities.
  Moreover, in~\eqref{eq:pi2-comp-proof} we have used the rule $\mathsf{concat}$ which introduced another transported term, so we will have to remove that $\transp$ to derive the right hand side.

  To better illustrate the annoyance, note that \eqref{eq:pi2-comp-real-proof} can be proved by following equations:
  \begin{alignat*}{3}
         & ([\pi_1(\sigma; \tau)]\,A                    &&, \pi_2\,(\sigma ; \tau)) \\
    = {} & ([\pi_1(\sigma; (\pi_1\tau , \pi_2\tau))]\,A &&, \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))) \\
    = {} & ([\pi_1(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})]\,A &&, \pi_2\,(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})) \\
    = {} & ([\sigma;\pi_1\,\tau]\,A &&, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})) \nonumber \\
    = {} & (\sub{\sigma}{\sub{\pi_1\tau}{A}} &&, [\sigma] (\pi_2\,\tau)). \nonumber
  \end{alignat*}
  The first three equations corresponding to \eqref{eq:pi2-comp-proof} follow with Lemma~2.3.4 in \cite{UFP2013}, while the last has nothing to do with substitution calculus but the path lifting property (\cite[Lemma~2.3.2]{UFP2013}).
\end{example}

\subsection{Substitution calculus as a quotient inductive-inductive-recursive type} \label{subsec:SC-QIIRT}

To retain the intuitive way of reasoning such as in equation \eqref{eq:pi2-comp-proof} \emph{formally}, we would like to make type substitution rules strict, since the root cause is that type substitution does not compute as a constructor, leading to type mismatches occurring with substitution.

One possibility is to define the substitution calculus as a QIIRT, where type substitution is defined by recursion, and hence computes.
%Now that $[ \idS ]_{\Ty}\;A = A$ and $[ \sigma ; \tau ]_{\Ty}\;A = [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A)$ do not make $[\blank]_{\Ty}\blank$ a (total) function, we may be tempted to define it by
%\begin{alignat*}{3}
%[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
%[ \sigma ]_{\Ty}\;\UU & = \UU
%\end{alignat*}
Note that this does not follow the schema of inductive-recursive definitions given by Dybjer and Setzer~\cite{Dybjer2000,Dybjer2003}, since the codomain of the recursive function is the inductively defined typed itself.\footnote{%
  While the general schema for this more liberal notion of induction-recursion remains underdeveloped, this definition is accepted in \Agda and used in other formalisations of type theory~\cite{Danielsson2006}.}
%Nevertheless, $[\idS]_{\Ty}\,A$ and $[\sigma; \tau]_{\Ty}\,A$ do not reduce to~$A$ and~$[\sigma]_{\Ty}\,[\tau]_{\Ty}\,A$ respectively, even though they are provable.
%This definition fails to remove any transport in the definition of substitution calculus.
%
Since we want type substitution to both act structurally on types and commute with identities and composition, we could try to define$[\blank]_{\Ty} \blank : \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma$ recursively as follows:
\begin{alignat}{3}
%[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \nonumber \\
[ \sigma ]_{\Ty}       \;\UU  & = \UU                                   \label{eq:type-sub-at2-1} \\
[ \idS ]_{\Ty}         \;A    & = A                                     \label{eq:type-sub-at2-2} \\
[ \sigma ; \tau ]_{\Ty}\;A    & = [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \label{eq:type-sub-at2-3}
\end{alignat}
As explained in \cref{sec:meta:overlapping}, this definition does \emph{not} reduce \eqref{eq:type-sub-at2-2} or \eqref{eq:type-sub-at2-3} \emph{strictly}, and \eqref{eq:type-sub-at2-2} or \eqref{eq:type-sub-at2-3} will fire only if we know that $A$ is not $\UU$.
%In the above definition, only the eliminator for $\Ty\;\Delta$ will be considered using the first-match semantics, which amounts to the following definition:
%\begin{alignat*}{3}
%[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
%[ \sigma ]_{\Ty}\;\UU  & \reduce \UU
%\end{alignat*}
%where $\reduce$ is used to emphasise the reduction (which entails the strict equality): we have done nothing different from our first attempt! 
%As a result, neither  are strict.
We may swap \eqref{eq:type-sub-at2-1} with \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} to make \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} strict, but then \eqref{eq:type-sub-at2-1} will be elaborated to 
\[
[ \emptysub ]_{\Ty}\;\UU         \judgeq \UU, \qquad
[ \sigma, t ]_{\Ty}\;\UU         \judgeq \UU, \qquad\text{and}\qquad 
[ \pi_1\,\sigma ]_{\Ty}\;\UU     \judgeq \UU,
\]
Thus in this case we have again lost the desired strict identity $[\sigma]\;\UU \equiv \UU$.
%
%making $[\sigma]\;\UU = \UU$ propositional instead.
%Not being able to reduce $[ \sigma ]_{\Ty}\;\UU$ to $\UU$ would make our later extension with a type $\El\,a$ for $a : \Tm\;\Gamma\;\UU$ require another transport in the definition.
%Likewise, for any extension with a type former such as $\Pi$-types, structural rules would still be propositional.
%That is, using the standard semantics of function definition, we are not able to make type substitution strict for \emph{both} $\Sub\;\Gamma\;\Delta$ and $\Ty\;\Delta$ at the same time.

To ensure that type substitution is strict for all %\emph
{rules}, we turn to a definition by overlapping patterns (\cref{sec:meta:overlapping}) instead to make each clause strict. 
In addition, we can include other derived rules such as $[\pi_1(\sigma, t)]_{\Ty}\;A = [ \sigma]_{\Ty}\;A$ as long as they are locally confluent and terminating.
We end up with the following definition for type substitution:
\begin{alignat}{3}
[\blank]_{\Ty} \blank            &: \implicit{\Gamma, \Delta} \; \Sub\,\Gamma\,\Delta \to \Ty\,\Delta \to \Ty\,\Gamma \nonumber \\
[ \idS ]_{\Ty}\;A                & \reduce A \label{eq:def-type-subst-1}\\
[ \sigma ; \tau ]_{\Ty}\;A       & \reduce [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \label{eq:def-type-subst-2}\\
[ \pi_1(\sigma, t) ]_{\Ty}\;A    & \reduce [\sigma]_\Ty\;A                       \label{eq:def-type-subst-3} \\
[ \pi_1(\sigma; \tau) ]_{\Ty}\;A & \reduce [\sigma]_\Ty\;([\pi_1\tau]_\Ty\;A)    \label{eq:def-type-subst-4} \\
[ \sigma ]_{\Ty}\;\UU            & \reduce \UU                                   \label{eq:def-type-subst-5}
\end{alignat}
We first check that this definition of type substitution is confluent.
%
\begin{proposition}\label{prop:local-confluence-1}
  Type substitution $[\blank]_{\Ty}\blank$ is terminating and locally confluent.
  \danger
\end{proposition}
\begin{proof}
  Termination is clear, since all recursive calls are on structurally smaller arguments~\cite{Abel2002}.
  To show the local confluence, we consider all local peaks, i.e.\ each combination of \eqref{eq:def-type-subst-5} with \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4},
  \[
    [\idS]_{\Ty}\;\UU, \qquad [\sigma;\tau]_{\Ty}\;\UU, \qquad [\pi_1(\sigma, t)]_{\Ty}\;\UU, \qquad\text{and}\qquad [\pi_1(\sigma; \tau)]_{\Ty}\;\UU
  \]
  and show that each applicable clause does result in $\UU$.

  For example, $[\sigma;\tau]_{\Ty}\;\UU \reduce [\sigma]_{\Ty}\;([\tau]_{\Ty}\;\UU) \reduce [\sigma]_{\Ty}\;\UU \reduce \UU$ using \eqref{eq:def-type-subst-2} as the first reduction and $[\sigma;\tau]_{\Ty}\;\UU \reduce \UU$ using \eqref{eq:def-type-subst-5} as the first reduction.
  It is easy to see that remaining local peaks reduce to the same term.
\end{proof}

With this definition of type substitution, other equality constructors can be introduced without any $\transp$, and we can give the updated constructors the types below.
\begin{alignat*}{5}
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} &&\sigma ; (\tau , t) && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau), [ \sigma ]\;t \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\, A} &&  t \\
  [\idS]t         & : \implicit{\Gamma, A, t} && {[\idS]\,t}          && =^{\Tm\,\Gamma\,A} && t \\
  [;]t            & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\sigma ; \tau]\,t} && =^{\Tm\,\Gamma\,[\sigma ; \tau] A} && {[ \sigma ]\;([ \tau ]\;t})
\end{alignat*}

We revisit \cref{ex:pi2-comp} to demonstrate the pragmatic benefit of QIIRTs over QIITs.
\begin{example} \label{ex:pi-comp-qiirt}
  The equation $\pi_2\,(\sigma; \tau) = [\sigma](\pi_2\,\tau)$ can be formally stated without any transport.
  The type of the term on the LHS is $[\pi_1(\sigma;\tau)]_{\Ty}\;A$ which is strictly equal to the type $[\sigma]_\Ty\;([\pi_1\tau]_\Ty\;A)$ of the term on the RHS.
  Moreover, the first components in each step of the proof of \eqref{eq:pi2-comp-real-proof}, are strictly equal because of \eqref{eq:def-type-subst-3} and \eqref{eq:def-type-subst-4}.
  Consequently, the back-of-the-envelope calculation~\eqref{eq:pi2-comp-proof} is \emph{formally correct}.
\end{example}

As we are defining a function on a quotient inductive type, we have to prove that $[\blank]_{\Ty}\blank$ is coherent, i.e., that it respects all equality constructors.
%\LT[noinline]{Should we mention any general condition for coherence?}
%\Fredrik[noinline]{Is there one?}
%\LT[noinline]{I think Cubical Agda has sort of conditions? (Cubical Agda does not support rewriting)}
\begin{proposition}\label{prop:coherence-1}
  For every equality constructor $p : \sigma = \tau$, we have $[\sigma]_{\Ty}\,A = [\tau]_{\Ty}\,A$.
  \danger
\end{proposition}
\begin{proof}
  As equality constructors $[\idS]_T$, $[;]_T$, and $[]\UU$ for types become strict, it suffices to show that the following identities
  \begin{align*}
    [\sigma;\idS]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [\idS;\sigma]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [(\sigma;\tau);\gamma]_{\Ty} \;A & = [\sigma; (\tau; \gamma)]_{\Ty}A, \\
    [\pi_1(\sigma, t)]_{\Ty}\;A      & = [\sigma]_{\Ty}\;A, \\
    [\sigma; (\tau, t)]_{\Ty} \;A    & = [(\sigma;\tau), [\sigma]\, t]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\emptyctx]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\pi_1\sigma, \pi_2\sigma]_{\Ty}\;A
  \end{align*}
  hold propositionally.
  The first two identities of the first row hold strictly by \eqref{eq:def-type-subst-1} and \eqref{eq:def-type-subst-2}, while terms of the both sides of the third reduce to $[\sigma]_{\Ty}\;([\tau]_{\Ty}\;([\gamma]_{\Ty}\;A))$ by \eqref{eq:def-type-subst-2}.

  The sole identity of the second row is clause \eqref{eq:def-type-subst-3} of the definition of $[\blank]_{\Ty}\blank$.

  We show the remaining cases by induction on $A$.
  However, $\UU$ is the only constructor for $\Ty\;\Gamma$ for any $\Gamma$ and each of the identities with $A \defeq \UU$ reduce to $\UU$.
\end{proof}
\begin{remark}\label{re:coherence-proof}
  In the above proof the first four identities hold strictly by \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4}, while the last three follow from \eqref{eq:def-type-subst-5} by induction on $A$.
  As we extend substitution calculus with other type formers, the first four identities will always hold but the last three depend on how type substitution is defined.
\end{remark}

\subsection{Adding a universe} \label{subsec:SC+U}
Now we extend substitution calculus with an empty universe $\UU$ of small types~$\El\,u$.
For a QII definition \cite{Altenkirch2016a}, this extension adds the following constructors
\begin{alignat*}{3}
  \El   & : \implicit{\Gamma} && \Tm\,\Gamma\;\UU \to \Ty\,\Gamma \\
  []\El & : \implicit{\Gamma, \Delta, \sigma, u} && [ \sigma ]\,(\El\, u) =^{\Tm\;\Gamma\;\UU} \El\,(\alert{\transfib{\Tm\;\Gamma}{[]\UU}{\color{black}[\sigma]{u}}})
\end{alignat*}
%as the type $\UU$ of universe and its structural rule $[]\UU$ have been added to avoid a trivial inductive type.
The type substitution $[\sigma](\El\,u)$ is, informally, the type of the term substitution $[\sigma]\,u$ for $u : \Tm\;\Delta\;\UU$, and the transport is needed to coerce $[\sigma]\,u : \Tm\;\Gamma\;([\sigma]\;\UU)$ into $\Tm\;\Gamma\;\UU$.

In our QIIR definition, $\transfib{\Tm\;\Gamma}{[]\UU}{\blank}$ is no longer needed, since $[]\UU$ becomes strict. 
Likewise, the equality constructor $[]\El$ may be replaced by 
\begin{alignat*}{3}
  [ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma] {u})
\end{alignat*}
Yet, this naive change breaks the local confluence!
The problem is that there is now additional interaction between types and terms. Observe that the local peak
\[
  \El\,u \Leftarrow [\idS]_{\Ty}(\El\,u) \reduce \El([\idS]\,u).
\]
cannot reduce to the same term, since the term substitution $[\idS]\,u$ is merely a constructor.

To repair the local confluence, we add a simultaneously defined function $[\blank]_{\Tm}\blank$ for term substitution apart from the explicit term substitution $[\blank]\blank$ as follows
\begin{alignat*}{3}
  [\blank]_{\Tm}\blank & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Delta\,A \to \Tm\,\Gamma\,([\sigma]_{\Ty}\,A) \\
[ \idS ]_{\Tm}\,t          & \reduce t \\
[ \sigma ; \tau ]_{\Tm}\,t & \reduce [ \sigma ]_{\Tm}\;([ \tau ]_{\Tm}\;t) \\
[ \pi_1(\sigma, t) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\,t \\
[ \pi_1(\sigma; \tau) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\; ([\pi_1\tau]_\Tm \,t) \\
[ \sigma ]_{\Tm}\,t        & \reduce [ \sigma ]\,t, \quad \text{otherwise}
\end{alignat*}
which reduces substitutions that occur in \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4} recursively so that the reduction can be propagated from type to term substitution.
The remaining cases reduce to the explicit term substitution $[\sigma]\,t$.
Note that $[\blank]_{\Tm}\blank$ can be defined with the standard semantics for function definition, since there are no overlapping patterns.
\begin{remark}
  The function $[\blank]_{\Tm}\blank$ can be understood as a \emph{smart constructor} for the explicit term substitution $[\blank]\blank$, a well-known idiom in functional programming, since the function $[\blank]_{\Tm}\blank$ (mostly) builds an explicit substitution but computes certain cases away.
\end{remark}

Then, the equality constructor $[]\El$ is accordingly changed to 
\begin{align}
  [ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma]_{\Tm} {u}) \label{eq:def-type-subst-7}
\end{align}
to retain the local confluence for type substitution. The proof is similar to the proof of \cref{prop:local-confluence-1}, and can be found in \cref{appendix:proofs}.
%\begin{proposition}[Termination]
%  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
%  \danger
%\end{proposition}
%\begin{proof}
%  Again, each recursive call is on a structurally smaller term~\cite{Abel2002}.
%\end{proof}
\begin{restatable}{proposition}{propConfluenceTwo}\label{prop:local-confluence-2}
  Type substitution $[\blank]_{\Ty}\blank$ is terminating and locally confluent.
  \qed
  \danger
\end{restatable}

We also have to show that the recursive substitution $[\blank]_{\Tm}\blank$ is propositionally equal to the explicit substitution $[\blank]\blank$, so they can be used together consistently.


\begin{restatable}{proposition}{propCorrectness}\label{prop:correctness-1}
  For any $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Tm\;\Delta\;A$, the term $[\sigma]t$ is propositionally equal to $[\sigma]_{\Tm}\,t$. \qed
\end{restatable}

Finally, we have to show that both $[\blank]_{\Ty}\blank$ and $[\blank]_{\Tm}\blank$ are coherent.
\begin{restatable}{proposition}{propCoherence}\label{prop:coherence-2}
  For every equality constructor $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$, the identities
  \danger
  \[
    [\sigma]_{\Ty}\,A = [\tau]_{\Ty}\,A
    \quad\text{and}\quad
    [\sigma]_{\Tm}\,t = [\tau]_{\Tm}\,t
  \]
  hold for any type $A$ and any term $t$. \qed
\end{restatable}

\begin{remark}
We have seen that a naive extension with a universe breaks the local confluence of type substitution defined in \cref{subsec:SC-QIIRT}, because the newly added function clause interacts with other existing clauses.
In general, every term occurs on the right-hand side of a clause needs to propagate the reduction to allow a confluent term to exist, and this propagation can be achieved by turning a term involving a substitution $\sigma$ into a recursion.
\end{remark}

\subsection{Adding \texorpdfstring{$\Pi$}{Π}-types} \label{subsec:SC+U+Pi}

We extend the type theory in \cref{subsec:SC+U} with $\Pi$-types, i.e.\ dependent function types, where the context of its codomain is extended with the domain type.
For the QIIT of type theory in \cite{Altenkirch2016a}, it amounts to adding the following constructors for the type formation rule, the term introduction/elimination rules:
\begin{alignat*}{3}
  \Pi     &: \implicit{\Gamma}           \; && (A : \Ty\,\Gamma) \to \Ty\,(\Gamma, A) \to \Ty\,\Gamma \\
  \lambda &: \implicit{\Gamma, A, B}     \; && \Tm\;(\Gamma, A)\;B \to \Tm\,\Gamma\,(\Pi\;A\;B) \\
  \mathsf{app} &: \implicit{\Gamma, A, B}\; && \Tm\;\Gamma\;(\Pi\;A\;B) \to \Tm\;(\Gamma, A)\;B
\end{alignat*}
the computation rules
\begin{alignat*}{5}
  \Pi\beta           & : \implicit{\Gamma, A, B, t}\; && \mathsf{app}\,(\lambda\,t) && =^{\Tm\;\Gamma\;A} && t \\
  \Pi\eta            & : \implicit{\Gamma, A, B, t}\; && t                          && =^{\Tm\;\Gamma\;A} && \lambda(\mathsf{app}\,t)
\end{alignat*}
and the structural rules for substitution
\begin{alignat}{5}
  []\Pi              & : \implicit{\Gamma, \Delta, \sigma, A, B}\;    && [ \sigma ]_{\Ty}\,(\Pi\;A\;B) && =^{\Ty\;\Gamma} && \Pi\,(\sub{\sigma}{A})\,([\sigma\uparrow A]\,B) \label{eq:def-type-subst-8} \\
  \mathsf{[]\lambda} & : \implicit{\Gamma, \Delta, \sigma, A, B, t}\; && [\sigma]_{\Tm} (\lambda\,t) && =^{\Tm\,\Gamma}_{\alert{[]\Pi}} && \lambda\,([\sigma \uparrow A]\,t) \nonumber
\end{alignat}
where $\sigma \uparrow A$ is the \emph{lifting}  of $\sigma$ by a type $A$ defined as $(\pi_1\idS; \sigma, \alert{\transfib{\Tm\;\Gamma}{[;]_T}{\color{black}\pi_2\idS}})$. 

For our QIIR definition, %$\sigma\uparrow A$ and $[]\lambda$ do not need a transport since $[;]_T$ and $[]\Pi$ are strict.
we do not need any transport since $[;]_T$ and $[]\Pi$ are strict.
However, once again, adding \eqref{eq:def-type-subst-8} directly to the type substitution $[\blank]_{\Ty}\blank$ breaks the local confluence, because the reduction gets stuck upon the lifting $\sigma \uparrow A$.
For example, $[\idS]_{\Ty}(\Pi\;A\;B)$ reduces to $\Pi\;A\;([\idS \uparrow A]_{\Ty}B)$ where $\idS \uparrow A$ is propositionally but not strictly equal to $\idS$, so the local peak $\Pi\;A\;B \Leftarrow [\idS]_{\Ty}(\Pi\;A\;B) \reduce \Pi\;A\;([\idS \uparrow A]_{\Ty}B)$ cannot be joined. 

To retain the local confluence, we turn $\sigma \uparrow A$ into a simultaneously defined function:
\begin{alignat}{3}
  \blank\uparrow \blank & : \implicit{\Gamma, \Delta}\; (\sigma : \Sub\,\Gamma,\Delta) (A : \Ty\,\Delta) \to \Sub\,(\Gamma, [\sigma]_{\Ty}\,A)\, (\Delta, A) \label{eq:type-of-lifting} \\
\idS                \uparrow A & \reduce \idS \nonumber \\
(\sigma ; \tau)     \uparrow A & \reduce (\sigma \uparrow \sub{\tau}{A} ) ; (\tau \uparrow A) \nonumber \\
\pi_1(\sigma, t)    \uparrow A & \reduce \sigma \uparrow A \nonumber \\
\pi_1(\sigma; \tau) \uparrow A & \reduce (\sigma \uparrow \sub{\pi_1 \tau}{A}) ; (\pi_1 \tau \uparrow A)\nonumber \\
\sigma              \uparrow A & \reduce \sigma^+ , \quad \text{otherwise} \nonumber
\end{alignat}
where $\sigma^+ \defeq (\pi_1\idS ; \sigma), \pi_2\idS$.
Then, we add another clause for type substitution and an equality constructor for term substitution without transport:
\begin{alignat}{5}
                     & [ \sigma ]_{\Ty}\,(\Pi\,A\,B) && \reduce \Pi\,(\sub{\sigma}{A})\,(\sub{\sigma\uparrow A}{B}) \label{eq:def-type-subst-9} \\
  \mathsf{[]\lambda} :{} & [\sigma]\, (\lambda\,t) && =^{\Tm\,\Gamma\,([\sigma]_{\Ty}(\Pi\,A\,B))} && \lambda\,([\sigma \uparrow A]\,\,t) \nonumber
\end{alignat}


\begin{restatable}{proposition}{propConfluenceThree}\label{prop:local-confluence-3}
  Type substitution $[\blank]_{\Ty}\blank$ is terminating and locally confluent.
  \qed
    \danger
\end{restatable}

Similar to term substitution, we can show that the lifted substitution $\sigma \uparrow A$ is propositionally equal to $\sigma^+$, based on two basic properties\footnote{%
  The reader is invited to prove them using the QII definition with transports.}
about the lifting.
\begin{lemma} \label{lem:lifting}
  The following statements hold:
  \[
    \idS^+ =^{\Sub\;(\Gamma, A)\;(\Gamma, A)} \idS
    \qquad\text{and}\qquad
    (\sigma; \tau)^+     =^{\Sub\;(\Gamma, [\sigma; \tau]_{\Ty}\,A)\;(\Theta, A)} \sigma^+ ; \tau^+.
  \]
\end{lemma}

\begin{restatable}{proposition}{propCorrectnessTwo}\label{prop:correctness-2}
    For every $\sigma : \Sub\;\Gamma\;\Delta$, and $A : \Ty\;\Delta$, the lifting
    $\sigma \uparrow A$ is propositionally equal to $\sigma^+$.
    \qed
\end{restatable}

As we are working with a different type theory from \cref{subsec:SC+U}, we still have to prove the identity $[\sigma]\,t = [\sigma]_{\Tm}\,t$ but the same argument still applies:
\begin{proposition} \label{prop:correctness-3}
  For every $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Ty\;\Delta\;A$,
  the term $[\sigma]t$ is propositionally equal to $[\sigma]_{\Tm}\,t$.
\end{proposition}

Finally, we show that these simultaneously defined functions are coherent.
\begin{restatable}{proposition}{propCoherenceUparrow} %[Coherence]
    For every equality constructor $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$, we have
    \danger
    \[
      \sigma \uparrow A =^{\lam{\gamma}\Sub\;(\Gamma, [ \gamma ]_{\Ty} A)\;(\Delta, A)}_{\alert{p}} \tau \uparrow A
      \qquad\text{and}\qquad
      [\sigma]_{\Tm}\,t =^{\lam{\gamma}\Tm\;\Gamma\;([\gamma]_{\Ty}A)}_{\alert{p}} [\tau]_{\Tm}\,t,
    \]
    for any type $A$ and any term $t$.
    \qed
\end{restatable}

\subsubsection{Multiple lifting and the coherence of type substitution}

We also need to prove the coherence for type substitution, i.e., that $[\sigma]_{\Ty}\,A = [\tau]_{\Ty}\,A$ for every equality constructor $p : \sigma = \tau$.
To do this, we need to generalise the desired identity to account for liftings, since a naive induction does not work: for example, on $\Pi$-types, we have
\begin{align*}
  [\sigma]_{\Ty}\,(\Pi\;A\;B) & = \Pi\;([\sigma]_{\Ty}\,A)\;([\sigma\uparrow A]_{\Ty}\,B) \\
  [\tau]_{\Ty}\,(\Pi\;A\;B) & = \Pi\;([\tau]_{\Ty}\,A)\;([\tau\uparrow A]_{\Ty}\,B)
\end{align*}
but the induction hypothesis does not give us $[\sigma\uparrow A]_{\Ty}\,B = [\tau\uparrow A]_{\Ty}\,B$.
Instead, we will define the \emph{multiple lifting} $\sigma \upuparrows \Xi$ by a telescope $\Xi = A_1, \dots, A_n$, which intuitively means multiple applications of lifting: $\sigma \uparrow A_1 \uparrow \dots \uparrow A_n$.
Then, for each constructor $p : \sigma = \tau$, we show the identity
$[\sigma \mathop{\upuparrows} \Xi ]_{\Ty}\,A = [\tau \mathop{\upuparrows} \Xi ]_{\Ty}\,A$
for arbitrary $\Xi$, subsuming the special case $[\sigma ]_{\Ty}\,A = [\tau ]_{\Ty}\,A$ when $\Xi$ is empty.

The type of telescopes over a `base' context $\Gamma$ $\Tel : \Ctx \to \Set$ are defined inductive-recursively simultaneously with a concatenation $\blank \dplus \blank$ as follows.

\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  \Tel               & :                   && \Ctx \to \Set                                     \\
  \emptytel          & : \implicit{\Gamma} && \Tel\;\Gamma \\
  \blank,\blank      & : \implicit{\Gamma} && (\Xi : \Tel\;\Gamma) (A : \Ty\;(\Gamma \dplus \Xi)) \to \Tel\;\Gamma
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  \blank & \dplus\blank     && :       (\Gamma : \Ctx) (\Xi : \Tel\;\Gamma) \to \Ctx \\
  \Gamma & \dplus \emptytel && \reduce \Gamma \\
  \Gamma & \dplus (\Xi, A)  && \reduce (\Gamma \dplus \Xi) , A
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip\noindent
Equipped with telescopes, we can now generalise single lifting with type \eqref{eq:type-of-lifting} to multiple lifting with type
\[
\blank\upuparrows \blank : (\sigma : \Sub\;\Gamma\;\Delta) \to (\Xi : \Tel\;\Delta)
\to \Sub\;(\Gamma \dplus ([\sigma]_{\Tel}\,\Xi))\;(\Delta \dplus \Xi)
\]
which requires us to also simultaneously define telescope substitution $[\blank]_{\Tel}\blank :  \Sub\;\Gamma\;\Delta \to \Tel\;\Delta \to \Tel\;\Gamma$.

\begin{minipage}{.5\linewidth}
\begin{alignat*}{5}
  & [ \sigma ]_{\Tel}\,\emptytel && \reduce \emptytel \\
  & [ \sigma ]_{\Tel}\,(\Xi, A)  && \reduce [ \sigma ]_{\Tel}\,\Xi, [\sigma \upuparrows \Xi]_{\Ty}\,A
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\linewidth}
\begin{alignat*}{5}
  & \sigma \upuparrows \emptytel && \reduce \sigma \\
  & \sigma \upuparrows (\Xi, A)  && \reduce (\sigma \upuparrows \Xi) \uparrow A
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip

To prove the coherence property for the multiple lifting, we would need the properties $\idS_\Gamma \upuparrows \Xi = \idS_{\Gamma \dplus  \Xi}$ and $(\sigma; \tau) \upuparrows \Xi = (\sigma\upuparrows [\tau]_{\Tel} \Xi); (\tau \upuparrows \Xi)$, similar to \cref{lem:lifting}, but these identities cannot be typed: the type of $\idS_{\Gamma} \upuparrows \Xi$ is $\Sub\;(\Gamma \dplus [\idS]_{\Tel}\,\Xi)\;(\Gamma \dplus \Xi)$ while the type of $\idS$ on the RHS is $\Sub\;(\Gamma \dplus \Xi)\;(\Gamma \dplus \Xi)$; similarly for the substitution composition.
%
Instead of resorting to \transp, we also turn telescope substitution $[\blank]_{\Tel}\blank$ and the multiple lifting into definitions by overlapping patterns by adding the following clauses:

\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  & [ \idS   ]_{\Tel}       \,&& \Xi && \reduce \Xi \\
  & [ \sigma ; \tau ]_{\Tel}\,&& \Xi && \reduce [ \sigma ]_{\Tel}\,([\tau]_{\Tel}\,\Xi)
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  & \idS          && \upuparrows \Xi && \reduce \idS \\
  & (\sigma;\tau) && \upuparrows \Xi && \reduce (\sigma \upuparrows [ \tau ]_{\Tel} \Xi) ; (\tau \upuparrows \Xi)
\end{alignat*}
\end{minipage}\vskip\belowdisplayskip\noindent
%whose confluence property is easy to see.

Of course, we also have to prove coherence for the newly introduced recursive functions to verify that they are well defined.

\begin{restatable}%[{Coherence for $[\blank]_{\Tel}$ and $\blank\upuparrows\blank$}]
{proposition}{coherenceTel}
  For every equality constructor $p : \sigma = \tau$ and telescope $\Xi$, we have
  $[\sigma]_{\Tel}\,\Xi = [\tau]_{\Tel}\,\Xi$ and $\sigma \upuparrows \Xi =^{\Sub\;(\Gamma\dplus [\sigma]_{\Tel}\Xi)\;(\Delta\dplus\Xi)} \tau \upuparrows \Xi$. \qed
  \danger
\end{restatable}

As promised, by instantiating $\Xi$ to be empty, we also get coherence for $[\blank]_{\Ty}$.

\begin{corollary}
  We have $[\sigma]_{\Ty}\,A = [\tau]_{\Ty}\,A$ for every equality constructor $p : \sigma = \tau$.
  \qed
  \danger
\end{corollary}


We conclude this extension with $\Pi$-types by noting that for $t : \Tm\,\Gamma\,(\Pi\,A\,B)$ and $u : \Tm\,\Gamma\,A$, also `ordinary' application
$t \mathop{\$} u \defeq [ (\idS , t) ]_{\Tm} (\mathsf{app}\,t)$ of type $\Tm\,\Gamma\,([(\idS , t)] B)$ can be defined without any transport. This is in contrast to the pure QII situation, where application is defined as $[ (\idS, \alert{\transfib{\Tm\;\Gamma}{[id]_T^{-1}}{\color{black}t}}) ]_{\Tm} (\mathsf{app}\,t)$.
%
%\begin{alignat*}{3}
%  \left<\blank\right> & : \implicit{\Gamma, A} \Tm\;\Gamma\;A \to \Sub\;\Gamma\;(\Gamma, A) \\
%  \left< t \right>    & \defeq (\idS , t),
%\end{alignat*}
%used to define the ordinal application: $t \mathop{\$} u \defeq [ \left< u \right> ]_{\Tm} (\mathsf{app}\,t)$, 
%can be introduced without any transport, which is $(\idS, \alert{\transfib{\Tm\;\Gamma}{[id]_T^{-1}}{\color{black}t}})$ in its QII definition.
Similarly, the structural rule for substitution on $\mathsf{app}$
\begin{align*}
  [\sigma \uparrow A ]\,(\mathsf{app}\;t) & = \mathsf{app}\,\lambda([\sigma \uparrow A ]\,(\mathsf{app}\;t)) && \text{by $\Pi\beta^{-1}$} \\
                                              & = \mathsf{app}\,\left([\sigma]\,\lambda\,(\mathsf{app}\,t)\right) && \text{by $[]\lambda^{-1}$} \\
                                              & = \mathsf{app}\,([\sigma]\,t) && \text{by $\Pi\eta^{-1}$.}
\end{align*}
can be derived without any transport (cf.\ \cite{Altenkirch2016a}), since \eqref{eq:def-type-subst-8} has become strict. 


\subsection{Adding other type formers} \label{subsec:SC+U+Pi+more}

We can add extensional identity types, a hierarchy of Coquand universes~\cite{Coquand2018}, and a unit type with an eta law, all without any additional difficulty. In particular, all these additions can be done without introducing any transports in the syntax. However, adding an inductive type such as the Booleans does introduce a little bit of friction; let us see why.
We introduce the type $\bool : \implicit{\Gamma}\;\Ty\;\Gamma$ itself, its constructors $\btrue, \bfalse : \implicit{\Gamma}\;\Tm\;\Gamma\;\bool$ and its elimination principle:
%
\begin{alignat*}{3}
  \belim &: \implicit{\Gamma} \; && (P : \Ty\;(\Gamma , \bool)) \to \Tm\;\Gamma\;([ \instSub{\bfalse} ]_{\Ty} P) \to \Tm\;\Gamma\;([ \instSub{\btrue} ]_{\Ty} P) \\
  &&& \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad \to (b : \Tm\;\Gamma\;\bool) \to \Tm\;\Gamma\;([ \instSub{b} ]_{\Ty} P)
\end{alignat*}
%
where $\instSub{t} \defeq (\idS, t) : \Sub\;\Gamma\;(\Gamma, A)$ for the substitution that substitutes $t : A$ for the top variable and leaves all other variables in place. We can add the expected computation rules
%
\begin{alignat*}{5}
  \bool\beta_{\bfalse}           & : \implicit{\Gamma, P, f, t}\; && \belim\,P\,f\,t\,\bfalse && =^{\Tm\;\Gamma\;[\instSub{\bfalse}]_{\Ty} P} {} && f \\
  \bool\beta_{\btrue}           & : \implicit{\Gamma, P, f, t}\; && \belim\,P\,f\,t\,\btrue && =^{\Tm\;\Gamma\;[\instSub{\btrue}]_{\Ty} P} {} && t
\end{alignat*}
%
and the structural rule for type substitution as another straightforward clause $[ \sigma ]_{\Ty}\,\bool \reduce \bool$,
but when we try to add the structural rule for term substitution applied to the eliminator, we end up with the following:
%
\begin{alignat*}{5}
  []\belim & : \implicit{\Gamma, \sigma, P, f, t, b}\; [ \sigma ] (\belim\,P\,f\,t\,b) \\
           & =^{\Tm\,\Gamma\,([ \sigma; \instSub{b} ]\,P)}_{\alert{p(b)}} \belim\,([ \sigma^+ ] P)\;(\alert{\transfib{\Tm\,\Gamma}{p(\bfalse)}{\textcolor{black}{[ \sigma ]\,f}}})\;(\alert{\transfib{\Tm\,\Gamma}{p(\btrue)}{\textcolor{black}{[ \sigma ]\,t}}})\; ([\sigma ]\,b)
\end{alignat*}
where the proof $p(x) : [ \instSub{[ \sigma ]_{\Ty}\,x} ; \sigma^+ ]\;P = [ \sigma ; \instSub{x} ]_{\Ty}\;P$ is needed to line up the types. Even though this is an equation between type substitutions, which we could hope make compute, there is no obvious way to direct the equation, and simply adding it as a reduction leads to confluence problems. Hence, we do not know how to get rid of these transports.

%\LT{%
%\begin{enumerate}
%  \item Discuss the extensional identity type.
%  \item Discuss Coquand universes.
%  \item Discuss the unit type.
%  \item Discuss the Boolean type.
%  % \item Discuss the type of natural numbers.
%\end{enumerate}
%}

\section{The elimination principle and models} \label{sec:models}

We show how to eliminate out of our QIIRT definition of type theory (\cref{subsec:eliminator}). In particular, we show how the elimination principle can be used to construct a standard model (\cref{subsec:std-model}) and compare our QIIRT definition with its QIIT counterpart (\cref{subsec:equivalence}).

\subsection{The elimination principle} \label{subsec:eliminator}

To eliminate $\Ctx$, $\Ty\,\Gamma$, $\Sub\;\Gamma\;\Delta$, and $\Tm\,\Gamma\,A$, we have to specify \emph{motive} type families
\begin{align*}
  \Ctx^M & : \Ctx \to \Set &
  \Sub^M & : \implicit{\Gamma, \Delta}\,\Ctx^M\;\Gamma \to \Ctx^M\;\Delta \to \Sub\;\Gamma\;\Delta \to \Set \\
  \Ty^M  & : \implicit{\Gamma}\,\Ctx^M\;\Gamma \to \Ty\;\Gamma \to \Set & 
  \Tm^M  & : \implicit{\Gamma, A}\; (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Tm\;\Gamma\;A \to \Set
\end{align*}
to act as the target types for the elimination principle:
\begin{alignat*}{10}
  \elim_{\Ctx} & : (\Gamma : \Ctx)   && \to \Ctx^M\;\Gamma &
  \elim_{\Sub} & : (\sigma : \Sub\;\Gamma\;\Delta) && \to \Sub^M\; && (\elim_{\Ctx}\,\Gamma)\;(\elim_{\Ctx}\;\Delta)\;&&\sigma \\
  \elim_{\Ty}  & : (A : \Ty\;\Gamma) && \to \Ty^M\;(\elim_{\Ctx}\,\Gamma)\;A \quad
               & \elim_{\Tm}  & : (t : \Tm\;\Gamma\;A) && \to \Tm^M\; && (\elim_{\Ctx}\,\Gamma)\;(\elim_{\Ty}\,A)\;&&t.
\end{alignat*}
Each constructor $\mathsf{c}$ should be interpreted by a corresponding \emph{method} $\mathsf{c}^M$ indexed by it, e.g.,
\begin{alignat*}{3}
%  \emptyctx_{\Ctx}^M     & :                    && \Ctx^M\;\emptyctx \\
  \blank,_{\Ctx}^M\blank & : \implicit{\Gamma, A}\; && (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Ctx^M\;(\Gamma, A) %\\
%  \UU^M & : \implicit{\dots} && \Ty^M\;\Gamma^M\;\UU \\
%  \emptysub_{\Sub}^M     & : \implicit{\dots}   && \Sub^M\;\Gamma^M\;\emptyctx_{\Ctx}^M\;\cdot \\
%  \blank,_{\Sub}^M\blank & : \implicit{\dots}   && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Gamma^M\;([\sigma^M]^M_{\Ty}\,A^M)\;t \to \Sub^M\;\Gamma^M\;(\Delta^M ,^M_{\Ctx} A^M)\;(\sigma, t) \\
%  \idS^M          & : \implicit{\dots} && \Sub^M\;\Gamma^M\;\Gamma^M\;\idS \\
%  [\blank]^M\blank & : \implicit{\dots} && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)([\sigma]\,t)
\end{alignat*}
and simultaneously defined functions are also interpreted by corresponding functions, e.g.,
\begin{alignat*}{3}
  [\blank]_{\Ty}^M\blank & : \implicit{\Gamma, \Gamma^M,\Delta, \Delta^M, \sigma, A} \; && \Sub^M\;\Gamma^M\;\Delta^M\;\sigma \to \Ty^M\;\Delta^M\;A \to \Ty^M\;\Gamma^M\;([\sigma]_{\Ty}\,A) %\\
%  [\blank]_{\Tm}^M\blank & : \implicit{\dots} && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)([\sigma]_{\Tm}\,t) %\\
%  \blank\uparrow^M\blank & : \implicit{\dots} \; && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to (A^M : \Ty^M\Delta^M\;A) \to
%    \Sub^M\;(\Gamma^M, [\sigma^M]_{\Ty}^M\,A^M)\;(\Delta^M, A^M)
\end{alignat*}
subject to the identities corresponding to equality constructors and function clauses, e.g.,
\begin{alignat*}{5}
  [\idS]_{\Ty}^M & : \implicit{\Gamma, \Gamma^M, A, A^M}\; && [ \idS^M ]^M_{\Ty} \;A^M && =^{\Ty^M\,\Gamma^M}\;&& A^M %\\
  %[;]_{\Ty}^M    & : \implicit{\dots}   && [ \sigma^M ;^M \tau^M ]^M_{\Ty} \;A^M && =^{\Ty^M\,\Gamma^M}\; && [\sigma^M]^M_{\Ty}\,([\tau^M]^M_{\Ty}\,A^M) \\
  %[\idS]_{\Tm}^M & : \implicit{\Gamma^M, t, t^M}   && [\idS^M]^M_{\Tm}\;t^M && =^{\lam{A^M}\Tm^M\;\Gamma^M\;A^M\;t}_{\alert{[\idS]^M_{\Ty}}} && \; t^M
\end{alignat*}
%
The elimination principle says that there are functions $\elim_{\Ctx}$, $\elim_{\Sub}$, $\elim_{\Ty}$ and $\elim_{\Tm}$ as soon as motives and methods are given.
When the motive families are constant, we call the principle a \emph{recursion principle} instead.
We refer to \cref{appendix:full-def} and our \Agda development for the full definition of the elimination principle.
%We also have omitted the list of implicitly quantified variables: each variable $A$ implicitly quantified in a constructor $c$ has accordingly an $A$-indexed variable $A^M$ in $c^M$. 
%%
%
%\begin{definition}
%  An \emph{eliminator} for the QIIR definition of type theory is a tuple of motives and methods above.
%  A \emph{recursor} is an eliminator whereas motives are constants over syntaxes.
%\end{definition}
%

\begin{remark}
  To state the methods, we cannot avoid using transports in identities that would need transports in its QII definition of a type theory --- for example, we have
  \[
    [\idS]_{\Tm}^M : \implicit{\Gamma^M, t, t^M} \;\;[\idS^M]^M_{\Tm}\;t^M  =^{\lam{A^M}\Tm^M\;\Gamma^M\;A^M\;t}_{\alert{[\idS]^M_{\Ty}}} \; t^M
  \]
  since identities occurring in a method %(e.g.\ $[\idS]_{\Ty}^M$)
  are propositional just like equality constructors in its QIIT definition.
  However, in the elimination principle for the QIIT definition, the situation is even worse, as we in general need yet another layer of transports for the methods to typecheck over the QIIT constructors.

  % : the above identity $[\idS]_{\Ty}^M$ already requires $\alert{\transfib{\Ty^M\;\Gamma^M}{[\idS]_{\Ty}}{\color{black}[\idS^M]_{\Ty}^M\,A^M}}$ to coerce its type $\Ty^M\;\Gamma^M\;([\idS]\,A)$ to $\Ty^M\;\Gamma^M\;A$ to match the index $A$ of $A^M$, which are not needed in our QIIR definition.
%That is, the eliminator for the QIIR definition requires fewer transports than its QII counterpart.
\end{remark}

The elimination principle computes by interpreting each constructor using the corresponding method inductively, e.g.,
\begin{alignat*}{5}
%  \elim_{\Ctx}\;\emptyctx   & \reduce \emptyctx_{\Ctx}                                    && : \Ctx^M\;\emptyctx  \\
  \elim_{\Ctx}\;(\Gamma, A) & \reduce (\elim_{\Ctx}\,\Gamma),_{\Ctx}^{M} (\elim_{\Ty}\,A) && : \Ctx^M\;(\Gamma, A) %\\
%  \elim_{\Ty}\;\UU          & \reduce \UU^M && :\Ty^M\;\Gamma^M\;\UU \\
%  \elim_{\Sub}\;\emptysub   & \reduce \emptysub^M_{\Sub} &&: \Sub^M\;\Gamma^M\;\emptyctx^M_{\Ctx}\;\emptyctx \\
%                            & \vdots
\end{alignat*}
%
Interestingly, a key difference compared to its QIIT counterpart is that $[\blank]_{\Ty}\blank$, $[\blank]_{\Tm}$, and $\blank\uparrow\blank$ are functions rather than (formed by) constructors, meaning they cannot be eliminated inductively but instead become propositional identities.
%type substitution $[\blank]\blank$ was a constructor and $[\sigma]\,A$ was eliminated to $[\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A)$; similarly for term substitution.
\begin{restatable}{proposition}{propProvableFunc}\label{prop:provable-function-clauses}
  Given the motives and the methods, we can prove
\begin{alignat*}{5}
  \elim_{\Ty}[] & : \elim_{\Ty}\,([\sigma]_{\Ty}\,A) && = && [\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A) \\
  \elim_{\Tm}[] & : \elim_{\Tm}\,([\sigma]_{\Tm}\,t) && =^{\lam{A^M}\Tm^M\;\Gamma^M\;A^M\;t}_{\alert{\elim_{\Ty}[]}} && [\elim_{\Sub}\,\sigma]^M_{\Tm}\,(\elim_{\Tm}\,t) \\
  \elim_{\Sub}[] & : \elim_{\Sub}(\sigma\uparrow A) && =^{\lam{B^M}\Sub^M\;(\Gamma^M,^M B^M)\;(\Delta^M, A^M)\;(\sigma \uparrow A)}_{\alert{\elim_{\Ty}[]}} && (\elim_{\Sub} \sigma) \uparrow^M (\elim_{\Ty}\,A)
\end{alignat*}
\end{restatable}

These identities are needed for the computation rules where strict identities are used in syntax.
For example, for $\sigma : \Sub\;\Gamma\;\Delta$ and $t : \Tm\;\Gamma\;([\sigma]_{\Ty}\,A)$, we have 
\[
  \elim_{\Sub}(\sigma, t) = (\elim_{\Sub}\,\sigma) ,_{\Sub}^M \alert{\transfib{\Tm^M\;(\elim_{\Ctx}\,\Gamma)}{\elim_{\Ty}[]}{\color{black}(\elim_{\Tm}\,t)}}
\]
where the transport is needed since $\elim_{\Tm}\;t : \Tm^M\;(\elim_{\Ctx}\,\Gamma)\;(\alert{\elim_{\Ty}\;([\sigma]_{\Ty}\,A)})\;t$ but $\blank ,_{\Sub}^M \blank$ expects its second argument to have type $\Tm^M\;(\elim_{\Ctx}\,\Gamma)\;\left(\alert{[\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A)}\right)\;t$.

% Consider eliminating a substitution extension $\sigma, t$ for $\sigma : \Sub\;\Gamma\;\Delta$ and $t : \Tm\;\Gamma\;([\sigma]_{\Ty}\,A)$, i.e.\ 
% \[
%   \elim_{\Sub}(\sigma, t) = (\elim_{\Sub}\,\sigma) ,^M_{\Sub} \; \alert{t^M}.
% \]
% In the QIIT definition, $\elim_{\Tm}\,t$ is exactly $t^M$ and has the type
% \begin{equation} \label{eq:elim-subext}
%   \Tm^M\;\Gamma^M\;(\alert{\elim_{\Ty}\;([\sigma]_{\Ty}\,A)})\;t\judgeq
%   \Tm^M\;\Gamma^M\;\left(\alert{[\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A)}\right)\;t
% \end{equation}
% where the RHS of \eqref{eq:elim-subext} is indeed the type of the second argument for $\blank,^M_{\Sub}\blank$.
% In the QIIRT definition, on the contrary, the interpreted type of $\elim_{\Tm}\;t$ is $\elim_{\Ty}\;([\sigma]_{\Ty}\,A)$, which is not strictly equal to the RHS of \eqref{eq:elim-subext}, so $\elim_{\Sub}(\sigma, t)$ has to be
% \[
%   (\elim_{\Sub}\,\sigma) ,_{\Sub}^M \alert{\transfib{\Tm^M\;(\elim_{\Ctx}\,\Gamma)}{\elim_{\Ty}[]}{\color{black}(\elim_{\Tm}\,t)}}
% \]
% transporting $\elim_{\Tm}\,t$ along the identity proof $\elim_{\Ty}[]$.


\begin{remark} \label{re:method-recursion-IIR}
Note that a simultaneously defined function does not need a corresponding interpretation for Dybjer and Setzer's inductive-recursive types, as their framework targets meta-theoretic types rather than the inductive types being defined.
\end{remark}

\subsection{The standard model} \label{subsec:std-model}
The standard model, justifying the soundness of our definition, is given by the same motives as those for its QIIT counterpart~\cite[Section~4]{Altenkirch2016a}:
\begin{align*}
  \Ctx^M\;\nameless          & \defeq \Set              & \Sub^M\;\Gamma^M\;\Delta^M\;\nameless & \defeq \Gamma^M \to \Delta^M \\
  \Ty^M\;\Gamma^M\;\nameless & \defeq \Gamma^M \to \Set & \Tm^M\;\Gamma^M\;A^M\;\nameless & \defeq (\gamma : \Gamma^M) \to A^M\;\gamma
\end{align*}
%with the additional methods to its QII counterpart:
%\begin{align*}
%  \blank\uparrow^M\blank & \defeq \lam{\sigma^M\,A^M\,\gamma} (\sigma^M\,(\pi_1\,\gamma) , \pi_2\,\gamma) & \\
%                         & : (\sigma^M : \Gamma^M \to \Delta^M) (A^M : \Delta^M \to \Set) \to \Sigma\;\Gamma^M\;(\lam{\gamma}A^M\,(\sigma^M\,\gamma)) \to \Sigma\,\Delta^M\,A^M \\
%  [\blank]_{\Tm}^M\blank & \defeq \lam{\sigma^M\,t^M\,\gamma} (t^M\,(\sigma^M\,\gamma))  \\
%                         & : (\sigma^M : \Gamma^M \to \Delta^M) (t^M : (\delta : \Delta^M) \to A^M\,\delta) \to (\gamma : \Gamma^M) \to A^M\,(\sigma^M\,\gamma)
%\end{align*}
%where $[\blank]_{\Tm}^M\blank$ is the same as the method for the explicit term substitution $[\blank]^M\blank$.
%
We once again refer to our \Agda formalisation for details.
We remark that because our lack of transports in the syntax, many of the identities in the standard model simply hold strictly --- more so than in the QIIT standard model, where an extra step~\cite[Lemma~2.3.5]{UFP2013} is often needed for reasoning about constant transports.

%In the QIIT counterpart standard model, none of identities hold strictly, since their indices always involve equality constructors.
%E.g., the constructor $[\idS]_{\Ty}$ gives rise to
%$[\idS]^M_{\Ty} : [ \idS^M ]^M_{\Ty}\, A^M =^{\Ty^M\;\Gamma^M}_{\alert{[\idS]_{\Ty}}} A^M$
%and the transport along $[\idS]_{\Ty}$ is needed, because $[ \idS^M ]^M_{\Ty}\, A^M$ is indexed by $[\idS]\,A$ instead of~$A$.
%Accordingly, this identity becomes $\lam{\gamma} A^M\,\gamma =_{\alert{[\idS]}}^{\lam{\nameless}\Gamma^M \to \Set} A^M$ in the standard model and needs an extra step~\cite[Lemma~2.3.5]{UFP2013} for reasoning about the constant transport.
%A workaround to avoid constant transports is to define the notion of recursors independent of eliminators and show that each recursor gives rise to an eliminator. 
%
%In contrast, in our QIIR definition, many identities just hold strictly.
%Consider
%\begin{alignat*}{5}
%  [\idS]^M_{\Ty}                   & : [ \idS^M ]^M_{\Ty}\, A^M && = A^M \\
%  \idS{\mathord{\uparrow}}^M & : \idS^M \uparrow^M A^M    && =^{\lam{B^M}\Sub^M\;(\Gamma^M, A^M)\;\Delta^M\;(\idS \uparrow A)}_{\alert{[\idS]^M}} \idS^M
%\end{alignat*}
%where $[\idS]^M_{\Ty}$ does not need a transport and is just an strict equality $(\lam{\gamma} A^M\,\gamma) \judgeq A^M$ in the model by the $\eta$-law for $\Pi$-types.
%Hence, $\idS{\mathord{\uparrow}}^M$ becomes $(\idS^M \uparrow^M A^M) = \idS^M$.
%By definition, it is a strict equality $(\lam{\gamma}(\pi_1\gamma, \pi_2\gamma)) \judgeq (\lam{\gamma}\gamma)$ by the $\eta$-law for $\Sigma$-types.

\subsection{Comparison with type theory as QIIT} \label{subsec:equivalence}
We have used additional rules to enable further reduction which are derivable in the QIIT definition.
Indeed, the QIIRT definition of type theory is equivalent to its QIIT definition, as we can translate every constructor to its corresponding constructor and vice versa.
For comparison, we add a subscript to constructors and types in the QIIRT and QIIT definitions by $\blank_\IR$ and $\blank_\I$, respectively, and write $(\blank)^{\succ}$ and $(\blank)^{\prec}$ for the translation from the QIIRT definition to its QIIT counterpart and the converse, respectively.

The recursor for $(\blank)^{\succ}$ is given straightforwardly: each method $c^M_{\IR}$ is given by the corresponding constructor $c_{\I}$ in the QIIT counterpart.
Additional equality constructors are all derivable in the QIIT definition. 

On the other hand, the converse $(\blank)^{\prec}$ has some choices.
Since in the QIIT definition there is only one term substitution $[\blank]_{\I}\blank$ and lifting $(\blank)^+_{\I}$, we may choose to translate $[\sigma]_{\I} \,t$ to the recursive form $[\sigma^{\prec}]_{\Tm}\,t^{\prec}$ to carry out some computation, or to the constructor form $[\sigma^{\prec}]_{\IR}\,t^{\prec}$ to stay verbatim.
Either choice is possible, but we need to use \cref{prop:correctness-1,prop:correctness-3} to switch from one to the other whenever suitable.
For example, the equality constructor $\mathsf{concat}_{\IR}$ uses the constructor form, so the method $\mathsf{concat}^M_{\I}$ relies on the identity $[ \sigma ]\,t = [\sigma]_{\Tm}\,t$ if the recursive form $[\sigma^{\prec}]_{\Tm}\,t^{\prec}$ is chosen for the translation.

Going back and forth from one definition to the other gives us the equivalences
\begin{restatable}{theorem}{equivalence}
  Type theory defined as a QIIRT and a QIIT are equivalent, i.e.\ 
  \begin{itemize}
    \item $\eqv{\Ctx_{\IR}}{\Ctx_{\I}}$, 
    \item $\eqv{\left((\Gamma : \Ctx_{\IR})\to\Ty_{\IR}\;\Gamma\right)}{\left((\Gamma : \Ctx_{\I})\to\Ty_{\I}\;\Gamma\right)}$,
    \item $\eqv{\left((\Gamma\;\Delta : \Ctx_{\IR}) \to \Sub_{\IR}\;\Gamma\;\Delta\right)}%
               {\left((\Gamma\;\Delta: \Ctx_{\I}) \to \Sub_{\I}\;\Gamma\;\Delta\right)}$, and 
    \item $\eqv{\left((\Gamma : \Ctx_{\IR}) \to (A : \Ty_{\IR}\;\Gamma) \to \Tm_{\IR}\;\Gamma\;A\right)}
               {\left((\Gamma : \Ctx_{\I}) \to (A : \Ty_{\I}\;\Gamma) \to \Tm_{\I}\;\Gamma\;A\right)}$.
  \end{itemize}
\end{restatable}

\section{Formal implementation} \label{sec:formal-implementation}

We have a formal implementation in \Agda, using the options \texttt{-{}-with-K} for the uniqueness of identity proofs, \texttt{-{}-exact-split} to ensure that all function clauses are definitional, and \texttt{-{}-rewriting} with \texttt{-{}-local-confluence-check} \cite{Cockx2020,Cockx2021} to implement definitions by overlapping patterns.
Quotient inductive types are simulated by postulating equations to introduce equality constructors~\cite{Licata2011}, as \textsc{Cubical Agda} does not support user-defined rewrite rules.

\subparagraph*{Implementing overlapping patterns via rewrite rules}
%The mechanism of defining a function by overlapping patterns is only implemented in an outdated experimental fork of \Agda.
To emulate a function by overlapping patterns, we declare each function clause a rewrite and another rewrite to identify the clause with the reflexivity proof.
E.g.,\ $[\blank]_{\Ty}$ up to the first clause $[\idS]_{\Ty}\,A \reduce A$ is defined as
\begin{lstlisting}
postulate
  [_]_      : Sub Γ Δ → Ty Δ → Ty Γ
  [id]      : [ idS ]    A ≡ A
  {-# REWRITE [id]      #-}
  [id]≡refl : [id] {A = A} ≡ refl
  {-# REWRITE [id]=refl #-}
\end{lstlisting}
where \lstinline|[id]≡refl| is used to ensure that \lstinline|[id]| need not be referred.
We also turn on the option \texttt{-{}-local-confluence-check} to check local confluence.


Defining by overlapping patterns is indeed one of the use cases of user-defined rewrite rules discussed by Cockx~\cite{Cockx2020}. 
The caveat, though, is that the termination checker is not imposed, so we have to check the termination informally.

\subparagraph*{Heterogeneous identity}
In our implementation, some statements are proved differently from our presentation. 
We have sometimes used John Major equality~\cite{McBride1999} $x \cong y$  for $A, B : \Set$, and $x : A$ and $y : B$, where dependent congruence rule or dependent identity type are needed.

For instance, in \cref{ex:pi-comp-qiirt}, the identity $\pi_2(\sigma ; \tau) = \pi_2(\sigma; (\pi_1 \tau, \pi_2 \tau)$ could be proved by $\apdfunc f \colon (p : x =^A y) \to f\,x =^{P}_{p} f\,y$ and the equality constructor $\pi\eta : \tau = (\pi_1\tau, \pi_2\tau)$, resulting an additional transport to remove later.
However, as $[\pi_1(\sigma; \tau)]_{\Ty}\,A$ and $[\pi_1(\sigma; (\pi_1\tau, \pi_2\tau))]_{\Ty}\,A$ are strictly equal, the resulting identity is indeed homogeneous.
Hence, we use the heterogeneous congruence $\mathit{hap}_f\colon (p : x \simeq y) \to f\,x\simeq f\,y$ (by \lstinline|hcong|) and switch back to the ordinary identity type $f\,x = f\, y$ (by \lstinline|≅-to-≡|) as their types match.
 
%As shown by McBride, the heterogeneous identity type is equivalent to the ordinary identity type equipped with the principle of uniqueness of identity proofs.

\LT[noinline]{Mention the NbE for SC here?}

\section{Conclusions, and related and future work}\label{sec:conclusion}

We have used QIIRTs and overlapping
patterns to represent type theory in (intensional) type theory. By defining type
substitution recursively with overlapping patterns, we can avoid most
coercions that appear in terms in other formalisations of type
theory in type theory. In other words, we have shown that so-called
`transport hell' can be minimised when formalising type theory in type
theory this way, without hiding details in the formalisation.

%\subsection{Related work}
%\paragraph*{Formalisation of type theory in type theory}

The idea of representing type theory in type theory in a well typed manner goes back to Dybjer~\cite{Dybjer1996} (see also~\cite{Clairambault2014,Castellan2021}). Dybjer's notion of \emph{category with families} can be seen as a semantic structure corresponding closely to the syntax of type theory, and many of the formalisations of type theory in type theory can be understood as capturing the initial category with families via inductive or quotient-inductive types. The equations involved are very similar to the equations described in Martin-L\"of's substitution calculus~\cite{Martin-Lof1992}.

Like us, Danielsson~\cite{Danielsson2006} defines type substitution by a recursive function, while keeping term substitution a constructor. However because he does not use quotients, he also has an explicit term constructor for transporting terms along an inductively defined type of conversion rules, which explicitly contains congruence rules. We are able to remove a lot of the boilerplate by using equality constructors instead. Chapman~\cite{Chapman2009} similarly uses explicit term substitutions and explicit transports along conversion rules, but also uses explicit type substitition in favour of more straightforward foundations.
McBride~\cite{McBride2010} offers another solution which uses an inductive-recursive type to reuse the equality of the metatheory rather than using explicit transports. This works well if the object theory and meta theory are similar, but does not allow to represent equalities that do not hold in the metatheory.

Altenkirch and Kaposi~\cite{Altenkirch2016a} were the first to exploit QIITs to simplify the treatment of computation rules in representations of type theory.% in type theory.
We build heavily on their ideas, but by using Danielsson's~\cite{Danielsson2006} idea of defining type substitution recursively, we are able to remove many explicit transports from the definition, with the result that it is closer to an informal exposition on paper. Such a benefit was also suggested by Kaposi's~\cite{Kaposi2023} work, where simply typed lambda calculus was used as an example. Altenkirch and Kaposi has built on the QIIT representation with great success to derive non-trivial results such as normalisation by evaluation~\cite{Altenkirch2017}, and investigate the metatheory of QIITs themselves, together with Kov\'acs~\cite{Kaposi2019}.

In the future, we hope to settle the foundational status of the
combination of quotient types, inductive-inductive types, and the kind
of generalised inductive-recursive types we have considered here,
including overlapping patterns. In fact, our original motivation for
embarking on this work was seeking examples that could give evidence
that such a combination could be useful.
%
Various schemas for inductive types have been developed in recent
years~\cite{Ghani2017,Kaposi2018,Kovacs2023}, and it seems
promising to see if they can be extended to also handle quotient
inductive-inductive-recursive types. Overlapping patterns are
discussed by Cockx~\cite{Cockx2014}, but we would like to integrate it
with such a schema. Eremondi and Kammar~\cite{Eremondi2025} has
recently given a promising possible direction for overlapping patterns
using sheaf theory.
%\LT{Perhaps also mention that the notion of models might be interesting, but it is out of the scope of this paper.}

%\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}
\bibliography{ref}

\appendix

\section{Complete definitions}\label{appendix:full-def}

\paragraph*{Quotient inductive-inductive-recursive types}
We give the QIIR definition for type theory with a universe of small types, $\Pi$-types, and extensional identity types in one place below.

\subparagraph*{Substitution calculus with a base type $\UU$}
\begin{alignat*}{3}
  \Ctx      & : && \Set                   \\
  \Ty       & : && \Ctx \to \Set          \\
  \Sub      & : && \Ctx \to \Ctx \to \Set \\
  \Tm       & : && (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Set
\end{alignat*}
\begin{alignat*}{5}
  \emptyctx & : && \Ctx \\
  \blank,\blank & : && (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Ctx
\end{alignat*}
\begin{alignat*}{5}
  [\blank]_{\Ty}\blank & : \implicit{\Gamma, \Delta}\; && \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
  \UU     & : \implicit{\Gamma}\; && \Ty\; \Gamma
\end{alignat*}
\begin{alignat*}{5}
  \emptysub & : \implicit{\Gamma} && \Sub\;\Gamma\;\emptyctx \\
  \blank,\blank & : \implicit{\Gamma, \Delta, A} && (\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Gamma\;([ \sigma ]_{\Ty}\,A) \to \Sub\;\Gamma,(\Delta, A) \\
  \idS & : \implicit{\Gamma} && \Sub\;\Gamma\;\Gamma \\
  \blank;\blank & : \implicit{\Gamma, \Delta, \Theta} && \Sub\;\Gamma\;\Delta \to \Sub\;\Delta\;\Theta \to \Sub\;\Gamma\;\Theta \\
  \pi_1 & : \implicit{\Gamma, \Delta, A}\; && \Sub\;\Gamma\;(\Delta, A) \to \Sub\;\Gamma\;\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A}\; && (\sigma : \Sub\;\Gamma\;(\Delta, A)) \to \Tm\;\Gamma\;([ \pi_1\;\sigma ]_{\Ty}\, A) \\
  [\blank] \blank & : \implicit{\Gamma,\Delta, A} && (\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Delta\;A \to \Tm\;\Gamma\;([\sigma]_{\Ty}\, A)
\end{alignat*}
\begin{alignat*}{5}
  & [ \idS ]_{\Ty}\,               && A           && \reduce A \\
  & [ \sigma ; \tau ]_{\Ty}\,      && A           && \reduce [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \\
  & [ \pi_1(\sigma, t) ]_{\Ty}\,   && A           && \reduce [\sigma]_\Ty\,A \\
  & [ \pi_1(\sigma; \tau) ]_{\Ty}\,&& A           && \reduce [\sigma]_\Ty ([\pi_1\tau]_\Ty \,A) \\
  & [ \sigma ]_{\Ty}\,             && \UU         && \reduce \UU
\end{alignat*}
\begin{alignat*}{5}
  ;\text{-}\mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma}\; && {\sigma ; \idS_{\Delta}} && =^{\Sub\;\Gamma\;\Delta} && {\sigma} \\
  ;\text{-}\mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma}\; && {\idS_{\Gamma} ; \sigma} && =^{\Sub\;\Gamma\;\Delta} && {\sigma} \\
  ;\text{-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, \gamma}\; && (\sigma ; \tau) ; \gamma && =^{\Sub\;\Gamma\;\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t}\; &&\sigma ; (\tau , t) && =^{\Sub\;\Gamma\;(\Theta, A)} &&  (\sigma ; \tau) , [ \sigma ] t \\
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_1(\sigma , t)        && =^{\Sub\;\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_2(\sigma , t)        && =^{\Tm\;\Gamma\; A} &&  t \\
  \emptyctx\eta   & : \implicit{\Gamma, \sigma}\; && \sigma                   && =^{\Sub\;\Gamma\;\emptyctx} & \emptysub \\
  \pi\eta         & : \implicit{\Gamma, A, \sigma}\; && \sigma                   && =^{\Sub\;\Gamma\;(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma) \\
  [\idS]          & : \implicit{\Gamma, A, t}\; && {[\idS]\;t}          && =^{\Tm\;\Gamma\;A} && t \\
  [;]             & :\implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t}\; && {[\sigma ; \tau]\;t} && =^{\Tm\;\Gamma\;[\sigma ; \tau] A} && {[ \sigma ]\;[ \tau ]\;t}
\end{alignat*}

\subparagraph*{Universe of small types}
\begin{alignat*}{5}
  [\blank]_{\Tm}\blank            & : \implicit{\Gamma, \Delta, A}\; (\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Delta\;A \to \Tm\;\Gamma\;([\sigma]_{\Ty}\,A) \\ 
 [ \idS ]_{\Tm}\,t                & \reduce t \\
 [ \sigma ; \tau ]_{\Tm}\,t       & \reduce [ \sigma ]_{\Tm}\;([ \tau ]_{\Tm}\;t) \\
 [ \pi_1(\sigma, t) ]_{\Tm}\,t    & \reduce [\sigma]_\Tm\,t \\
 [ \pi_1(\sigma; \tau) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\; ([\pi_1\tau]_\Tm \,t) \\
 [ \sigma ]_{\Tm}\,t              & \reduce [ \sigma ]\,t, \quad \text{otherwise}
\end{alignat*}

\begin{alignat*}{5}
  \El       & : \implicit{\Gamma}\; && \Tm\;\Gamma\;U \to \Ty\;\Gamma
\end{alignat*}

\begin{alignat*}{5}
  [ \sigma ]_{\Ty}\,  && (\El\, u) \reduce \El\,([\sigma]_{\Tm}{u})
\end{alignat*}

\subparagraph*{$\Pi$-types}
\begin{alignat*}{5}
  \blank^+ & : \implicit{\Gamma, \Delta, A}\; (\sigma : \Sub\;\Gamma\;\Delta) \to \Sub\;(\Gamma, [\sigma]_{\Ty}\;A)\;(\Delta, A) \\
  \sigma^+ & \defeq (\pi_1\idS; \sigma), \pi_2\sigma
\end{alignat*}
\begin{alignat*}{5}
  \blank\uparrow\blank & : \implicit{\Gamma, \Delta}\;(\sigma : \Sub\;\Gamma\;\Delta) (A : \Ty\;\Delta) \to \Sub\;(\Gamma, [\sigma]_{\Ty}\;A)\;(\Delta, A) \\
\idS                \uparrow A  & \reduce \idS \\
\sigma ; \tau       \uparrow A  & \reduce (\sigma \uparrow \sub{\tau}{A} ) ; (\tau \uparrow A) \\
\pi_1(\sigma, t)    \uparrow A  & \reduce \sigma \uparrow A \\
\pi_1(\sigma; \tau) \uparrow A  & \reduce \sigma \uparrow (\sub{\pi_1 \tau}{A}) ; (\pi_1 \tau \uparrow A) \\
\sigma              \uparrow A  & \reduce \sigma^+,\quad  \text{otherwiese}
\end{alignat*}
\begin{alignat*}{5}
  \Pi             & : \implicit{\Gamma}\; && (A : \Ty\;\Gamma) \to \Ty\;(\Gamma, A) \to \Ty\;\Gamma \\
  \lambda         &: \implicit{\Gamma, A, B} \; && \Tm\;(\Gamma, A)\;B \to \Tm\;\Gamma(\Pi\,A\,B) \\
  \mathsf{app}    &: \implicit{\Gamma, A, B} \; && \Tm\;\Gamma\;(\Pi\;A\;B) \to \Tm\;(\Gamma, A)\;B
\end{alignat*}
\begin{alignat*}{5}
  [ \sigma ]_{\Ty}\, (\Pi\,A\,B) \reduce \Pi\,(\sub{\sigma}{A})\,(\sub{\sigma\uparrow A}{B})
\end{alignat*}
\begin{alignat*}{5}
  []\lambda       & : \implicit{\Gamma, \Delta, \sigma, A, t}\;&& [ \sigma ] \,(\lambda\,t) && {} =^{\Tm\;\Gamma\;([\sigma]_{\Ty}(\Pi\,A\,B)} {} && \lambda ([\sigma \uparrow A ]\,t)\\
  \Pi\beta        & : \implicit{\Gamma, A, B, t}\; && \mathsf{app}\,(\lambda\,t)            && =^{\Tm\;\Gamma\;A} && t \\
  \Pi\eta         & : \implicit{\Gamma, A, B, t}\; && t                                     && =^{\Tm\;\Gamma\;A} && \lambda(\mathsf{app}\,t)
\end{alignat*}

\subparagraph*{Extensional identity types}

\begin{alignat*}{5}
  \mathsf{Id} & : \implicit{\Gamma} && (a : \Tm\;\Gamma\;\UU) (t : \Tm\;\Gamma\;(\El\,a)(u : \Tm\;\Gamma\;(\El\,a)) \to \Ty\;\Gamma \\
  \nameless & : && [ \sigma ]_{\Ty}\;(\mathsf{Id}\;a\;t\;u) \reduce \mathsf{Id}\;([\sigma]_{\Tm}\,a)\;([\sigma]_{\Tm}\,t)\;([\sigma]_{\Tm}\,u) \\
  \mathsf{refl}   & : \implicit{\Gamma, a, t}\;&&\Tm\;\Gamma\;(\mathsf{Id}\;a\;t\;t) \\
  []\mathsf{refl} & : \implicit{\Gamma, a, t}\;&& [\sigma]\,(\mathsf{refl}\;t) =^{\Tm\;\Gamma\;([\sigma](\mathsf{Id}\,a\,t\,t))} \mathsf{refl}([ \sigma ]_{\Tm}\,t) \\
  \mathsf{reflect} & : \implicit{\Gamma, a, t, u}\;&& \Tm\;\Gamma\;(\idtype[a]{t}{u}) \to t =^{\Tm\;\Gamma\;(\El\,a)} u
\end{alignat*}

\paragraph*{Elimination principles for type theories as QIIRTs}

\subparagraph*{Motives}
\begin{align*}
  \Ctx^M & : \Ctx \to \Set &
  \Sub^M & : \implicit{\Gamma, \Delta}\,\Ctx^M\;\Gamma \to \Ctx^M\;\Delta \to \Sub\;\Gamma\;\Delta \to \Set \\
  \Ty^M  & : \implicit{\Gamma}\,\Ctx^M\;\Gamma \to \Ty\;\Gamma \to \Set &
  \Tm^M  & : \implicit{\Gamma, A}\; (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Tm\;\Gamma\;A \to \Set
\end{align*}

\subparagraph*{Methods}
Note that implicitly quantified variables which would be otherwise declared inside $\implicit{\dots}$ are omitted below.
Each variable $\mathsf{c}^M$ with the superscript $(\blank)^M$ is always indexed by $\mathsf{c}$ in addition to other indices.

\subparagraph*{Substitution calculus with a base type $\UU$}
\begin{alignat*}{10}
  \emptyctx_{\Ctx}^M     & : \Ctx^M\;\emptyctx \\
  \blank,_{\Ctx}^M\blank & : (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Ctx^M\;(\Gamma, A) \\
  [\blank]_{\Ty}^M\blank & : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma \to \Ty^M\;\Delta^M\;A \to \Ty^M\;\Gamma^M\;([\sigma]_{\Ty}\,A) \\
  \UU^M                  & : \Ty^M\;\Gamma^M\;\UU \\
  \emptysub_{\Sub}^M     & : \Sub^M\;\Gamma^M\;\emptyctx_{\Ctx}^M\;\cdot \\
  \blank,_{\Sub}^M\blank & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Gamma^M\;([\sigma^M]^M_{\Ty}\,A^M)\;t \to \Sub^M\;\Gamma^M\;(\Delta^M ,^M_{\Ctx} A^M)\;(\sigma, t) \\
  \idS^M                 & : \Sub^M\;\Gamma^M\;\Gamma^M\;\idS \\
  \blank;^M\blank        & : (\sigma^M : \Sub^M\;\Gamma\;\Delta^M\;\sigma) \to (\tau^M : \Sub^M\;\Delta^M\;\Theta^M\;\tau) \to \Sub^M\;\Gamma^M\;\Delta^M\;(\sigma ; \tau) \\
  \pi_1^M                & : \Sub^M\;\Gamma^M\;(\Delta^M ,_{\Ctx}^M A^M)\;\sigma \to \Sub^M\;\Gamma^M\;\Delta^M\;(\pi_1\sigma) \\
  \pi_2^M                & : (\sigma^M : \Sub^M\;\Gamma^M\;(\Delta^M ,_{\Ctx}^M A^M)\;\sigma) \to \Tm^M\;\Gamma^M\;([ \pi_1^M\,\sigma^M ]^M_{\Ty}\;A^M)\;(\pi_2\,\sigma) \\
  [\blank]^M\blank       & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)\;([\sigma]\;t)
\end{alignat*}

\begin{alignat*}{5}
  [\idS]_{\Ty}^M      & : [ \idS^M ]^M_{\Ty}                             && \;A^M =^{\Ty^M\,\Gamma^M}\; && A^M \\
  [;]_{\Ty}^M         & : [ \sigma^M ;^M \tau^M ]^M_{\Ty}                && \;A^M =^{\Ty^M\,\Gamma^M}\; && [\sigma^M]^M_{\Ty}\,([\tau^M]^M_{\Ty}\,A^M) \\
  [\pi_1,]^M_{\Ty}    & : [ \pi_1^M\,(\sigma^M ,^M_{\Sub} t^M) ]^M_{\Ty} && \;A^M =^{\Ty^M\,\Gamma^M} \; && [\sigma^M]^M_{\Ty}\,A^M \\
  [\pi_1;]^M_{\Ty}    & : [ \pi_1^M\,(\sigma^M ;^M \tau^M) ]^M_{\Ty}     && \;A^M =^{\Ty^M\,\Gamma^M} \; && [\sigma^M]^M_{\Ty}\left([ \pi_1^M\,\tau^M]^M_{\Ty}\,A^M\right) \\
  []\UU^M             & : [ \sigma^M ]^M_{\Ty}                           && \;\UU^M =^{\Ty^M\,\Gamma^M\,\UU}      {} && \UU^M
\end{alignat*}


\begin{alignat*}{5}
  ;\text{-}\textsf{idr}^M   & : \sigma^M ;^M \idS^M && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{;\text{-}\mathsf{idr}}} && \sigma^M \\
  ;\text{-}\textsf{idl}^M   & : \idS^M ;^M \sigma^M && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{;\text{-}\mathsf{idl}}} && \sigma^M \\
  ;\text{-}\textsf{assoc}^M & : (\sigma^M ;^M \tau^M) ;^M \gamma^M   && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{;\text{-}\mathsf{assoc}}} && \sigma^M ;^M (\tau^M ;^M \gamma^M) \\
  \mathsf{concat}^M         & : \sigma^M ;^M (\tau^M ,_{\Sub}^M t^M) && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{\mathsf{concat}}} && (\sigma^M ;^M \tau^M) ,_{\Sub}^M \alert{\transfib{}{([;]^M)^{-1}}{\color{black}[\sigma^M]_{\Ty}^M\,t^M}} \\
  \pi_1\beta^M              & : \pi_1^M (\sigma^M ,^M_{\Sub} t^M)    && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{\pi_1\beta}}      && \sigma^M \\
  \pi_2\beta^M              & : \pi_2^M (\sigma^M ,^M_{\Sub} t^M)    && =^{\Tm^M\,\Gamma^M}_{\alert{[\pi_1,]^M, \pi_2\beta}}       && t^M \\
  \cdot\eta^M               & : \sigma^M                             && =^{\Sub^M\,\Gamma^M\,\emptyctx^M_{\Ctx}}_{\alert{\cdot\eta}}  && \emptysub_{\Sub}^M \\
  \pi\eta^M                 & : \sigma^M                             && =^{\Sub^M\,\Gamma^M\,(\Delta^M ,^M_{\Ctx} A^M)}_{\alert{\pi\eta}} {} && \pi_1^M \sigma^M ,_{\Sub}^M \pi_2^M \sigma^M \\
  [\idS]^M                  & : [ \idS ]^M\,t^M                      && =^{\Tm^M\,\Gamma^M}_{\alert{[\idS]^M_{\Ty}, [\idS]}} && t^M \\
  [;]^M                     & : [ \sigma^M ;^M \tau^M ]^M\,t^M       && =^{\Tm^M\,\Gamma^M}_{\alert{[;]^M_{\Ty}, [;]}} && [\sigma^M]^M\,([\tau^M]^M\,t^M) 
\end{alignat*}

\subparagraph*{Universe of small types}
\begin{alignat*}{10}
  [\blank]_{\Tm}^M\blank & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)([\sigma]_{\Tm}\,t) \\
  \El^M                  & : \Tm^M\;\Gamma^M\;\UU^M\;u \to \Ty^M\;\Gamma^M\;(\El\,u)
\end{alignat*}

\begin{alignat*}{5}
  [\idS]_{\Tm}^M      & : [\idS^M]^M_{\Tm}                               && \;t^M =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[\idS]^M_{\Ty}}} && \; t^M \\
  [;]^M_{\Tm}         & : [ \sigma^M ;^M \tau^M ]^M_{\Tm}                && \;t^M =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[;]^M_{\Ty}}} && [ \sigma^M ]^M\; \left([ \tau^M ]^M_{\Tm}\,t^M\right) \\
  [\pi_1,]^M_{\Tm}    & : [\pi_1^M (\sigma^M ,_{\Sub}^M u^M) ]^M_{\Tm}   && \;t^M =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[\pi_1,]^M_{\Ty}}} && [\sigma^M]_{\Tm}^M\;t^M \\
  [\pi_1;]^M_{\Tm}    & : [\pi_1^M (\sigma^M ;^M \tau^M) ]^M_{\Tm}       && \;t^M =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[\pi_1;]^M_{\Ty}}} && [\sigma^M]_{\Tm}^M\;\left([\pi_1^M\,\tau^M]^M_{\Tm}\;t^M\right) \\
  [\emptysub]^M_{\Tm} & : [\emptysub^M_{\Sub}]^M_{\Tm}                   && \;t^M = %^{\Tm^M\,\Gamma^M\;([\emptysub_{\Sub}^M]^M_{\Ty}\,A^M)\,([\emptysub]_{\Tm}\,t)}
                      [ \emptysub^M_{\Sub} ]^M  && t^M \\
  [,]_{\Tm}^M         & : [ \sigma^M ,_{\Sub}^M u^M ]^M_{\Tm}            && \;t^M = %^{\Tm^M\,\Gamma^M\;([\sigma^M ,_{\Sub}^M t ]^M_{\Ty}\,A^M)\,([\sigma , t]_{\Tm}\,t)}
                      [ \sigma^M ,_{\Sub}^M u^M ]^M && t^M \\
  [\pi_1\idS]^M_{\Tm} & : [ \pi_1^M\,\idS^M ]^M_{\Tm}                    && \;t^M = %^{\Tm^M\,(\Gamma^M ,^M_{\Ctx} A^M)\,([\pi_1^M\,\idS^M ]^M_{\Ty})\,A^M)\;([\pi_1\idS]_{\Tm}\,t)}{}
                      [ \pi_1^M\,\idS^M ]^M && t^M \\
  [\pi_1\pi_1]^M_{\Tm}& : [ \pi_1^M\,(\pi_1^M\,\sigma^M) ]^M_{\Tm}       && \;t^M = %^{\Tm^M\,\Gamma^M\,([\pi_1^M\,(\pi_1^1\,\sigma^M)]^M_{\Ty}\,A)\;([\pi_1(\pi_1\,\sigma)]_{\Tm}\,t)}
                      [ \pi_1^M\,(\pi_1^M\,\sigma^M) ]^M && t^M
\end{alignat*}

\begin{alignat*}{5}
  []\El^M & : [ \sigma^M ]^M_{\Ty}\;(\El^M\;u^M)   && =^{\Ty^M\,\Gamma^M\,(\El\,u)} {} && \El^M\,(\alert{\transfib{}{[]\UU^M}{\color{black}[ \sigma^M ]^M_{\Tm}\,u^M}}
\end{alignat*}



\subparagraph*{$\Pi$-types}
\begin{alignat*}{5}
  (\blank)^{+M} & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Sub^M\;(\Gamma^M ,_{\Ctx}^M ([ \sigma^M ]^M\;A^M]))\;(\Delta^M ,_{\Ctx}^M A^M)\;(\sigma^+) \\
  (\sigma^M)^{+M} & \defeq (\pi_1^M \idS^M ;^M \sigma^M) ,_{\Sub}^M \alert{\transfib{\lam{A^M}\Tm^M\;\Gamma^M\;A^M\;\pi_2\idS}{([;]^M)^{-1}}{\color{black}\pi_2^M \idS^M}}
\end{alignat*}

\begin{alignat*}{10}
  \blank\uparrow^M\blank & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to (A^M : \Ty^M\Delta^M\;A) \to \Sub^M\;(\Gamma^M, [\sigma^M]_{\Ty}^M\,A^M)\;(\Delta^M, A^M)\;(\sigma \uparrow A) \\
  \Pi^M                  & : (A^M : \Ty^M\;\Gamma^M\;A) \to \Ty^M\;(\Gamma^M ,_{\Ctx}^M A^M)\;B \to \Ty^M\;\Gamma^M\;(\Pi\,A\,B)  \\
  \lambda^M              & : \Tm^M\;(\Gamma^M ,_{\Ctx}^M A^M)\;B^M\;t \to \Tm^M\;\Gamma^M\;(\Pi^M\;A^M\;B^M)\;(\lambda\,t) \\
  \mathsf{app}^M         & : \Tm^M\;\Gamma^M\;(\Pi^M\,A^M\,B^M)\;t \to \Tm^M\;(\Gamma^M ,_{\Ctx}^M A^M)\;B^M\;(\mathsf{app}\,t)
\end{alignat*}


\begin{alignat*}{5}
  \idS\mathord{\uparrow}^M      & : \idS^M              && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\idS}_{\alert{[\idS]^M_{\Ty}}} {} && \idS^M \\
  \mathord{;\uparrow}^M         & : (\sigma^M ; \tau^M) && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\nameless}_{\alert{[;]^M_{\Ty}}} \\
                                &&& (\sigma^M \uparrow^M [ \tau^M ]^M_{\Ty} \,A^M) ;^M (\tau^M \uparrow^M A^M)  \\
  \mathord{\pi_1,\uparrow}^M    & : \pi_1^M(\sigma^M ,^M_{\Sub} t^M) && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\nameless}_{\alert{[\pi_1,]^M_{\Ty}}}            {} && \sigma^M \uparrow^M  A^M \\
  \mathord{\pi_1;\uparrow}^M    & : \pi_1^M(\sigma^M ;^M \tau^M)     && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\nameless}_{\alert{[\pi_1;]^M_{\Ty}}} {} \\
                                &&& (\sigma^M \uparrow^M  [\pi_1^M\tau^M]^M_{\Ty}\,A^M);^M (\pi_1^M\tau^M \uparrow^M A^M) \\
  \mathord{\emptysub^M_{\Sub}\uparrow}^M & : \emptysub^M_{\Sub} && \uparrow^M A^M = (\emptysub^M_{\Sub})^{+M} \\
  ,\mathord{\uparrow}^M & : (\sigma^M ,_{\Sub}^M t^M)  && \uparrow^M A^M = (\sigma^M ,_{\Sub}^M t^M)^{+M} \\
  \mathord{\pi_1\idS\uparrow}^M & : (\pi_1^M\,\idS^M) && \uparrow^M A^M = (\pi_1^M\,\idS^M)^{+M} \\
  \mathord{\pi_1\pi_1\uparrow}^M & : (\pi_1^M\,(\pi_1^M\,\sigma^M)) && \uparrow^M A^M = (\pi_1^M\,(\pi_1^M\,\sigma^M))^{+M}
\end{alignat*}

\begin{alignat*}{5}
  []\Pi^M         & : [ \sigma^M ]^M_{\Ty} \;(\Pi^M\;A^M\;B^M)  && =^{\Ty^M\,\Gamma^M\,([\sigma]_{\Ty} (\Pi\,A\,B))} && \Pi^M\;([ \sigma^M ]^M_{\Ty}\;A^M)\;([ \sigma^M ]^M_{\Ty}\;B^M) \\
  []\lambda^M     & : [ \sigma^M ]^M\;(\lambda^M\;t^M)          && =^{\Tm^M\,\Gamma^M}_{\alert{[]\Pi^M, []\lambda}} && \lambda^M\;([ \sigma^M \uparrow^M A^M ]^M\;t^M) \\
  \Pi\beta^M      & : \mathsf{app}^M\;(\lambda^M\;t^M)          && =^{\Tm^M\,(\Gamma^M,_{\Ctx}^M A^M)\,B^M}_{\alert{\Pi\beta}}      && t^M  \\
  \Pi\eta^M       & : \lambda^M\;(\mathsf{app}^M\;t^M)          && =^{\Tm^M\,\Gamma^M\,(\Pi\,A^M\,B^M)}_{\alert{\Pi\eta}}           && t^M 
\end{alignat*}

\subparagraph*{Extensional identity types}
\begin{alignat*}{10}
  \mathsf{Id}^M          & : (a^M : \Tm^M\;\Gamma^M\;\UU^M\;a) \to \Tm^M\;\Gamma^M\;(\El^M\,a^M)\;t \to \Tm^M\;\Gamma^M\;(\El^M\,a^M)\;u \to \Ty^M\;\Gamma^M\;(\mathsf{Id}\;a\;t\;u)  \\
  \mathsf{refl}^M        & : (t^M : \Tm^M\;\Gamma^M\;(\El^M\,a^M)\;t) \to \Tm^M\;\Gamma^M\;(\mathsf{Id}^M\;a^M\;t^M\;t^M)\;(\mathsf{refl}\;t) 
\end{alignat*}

\begin{alignat*}{5}
  []\mathsf{Id}^M    :{} & [ \sigma^M ]^M_{\Ty} (\mathsf{Id}^M\;a^M\;t^M\;u^M) =^{\Ty^M\,\Gamma^M\,([\sigma]_{\Ty}(\mathsf{Id}\,a\,t\,u))} \\
                      & \mathsf{Id}^M\; (\transfib{}{[]\UU^M}{[ \sigma^M ]^M_{\Tm}\,a^M})\;
                  (\transfib{}{[]\El^M}{[ \sigma^M ]^M_{\Tm}\,t^M})\;
                  (\transfib{}{[]\El^M}{[ \sigma^M ]^M_{\Tm}\,u^M}) \\
  []\mathsf{refl}    :{} & [ \sigma^M ]^M\;(\mathsf{refl}^M\;t^M) =^{\Tm^M\;\Gamma^M}_{\alert{[]\mathsf{Id}^M, []\mathsf{refl}}} \\
                      & \mathsf{refl}^M\;(\transfib{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,\nameless}{[]\El^M}{[\sigma^M]^M_{\Tm} \,t^M}) \\
  \mathsf{reflect}^M :{} & \Tm^M\;\Gamma^M\;(\mathsf{Id}^M\;a^M\;t^M\;u^M)\;p \to t^M =^{\Tm^M\;\Gamma^M\;A^M}_{\alert{\mathsf{reflect}\;p}} u^M
\end{alignat*}


\section{Omitted proofs}\label{appendix:proofs}

\propConfluenceTwo*
\begin{proof}
  In addition to previous cases in the proof of \cref{prop:local-confluence-1}, consider terms 
  \[
    [\idS]_{\Ty}\;(\El\,u), \qquad [\sigma;\tau]_{\Ty}\;(\El\,u), \qquad [\pi_1(\sigma, t)]_{\Ty}\;(\El\,u), \qquad\text{and}\qquad [\pi_1(\sigma; \tau)]_{\Ty}\;(\El\,u)
  \]
  which reduce to the following terms
  \[
    \El\,u, \qquad \El([\sigma]_{\Tm}\,[\tau]_{\Tm}\,u), \qquad \El([\sigma]_{\Tm}\,u), \qquad\text{and}\qquad
    \El([\sigma]_{\Tm}\,[\pi_1\tau]_{\Tm}\,u)
  \]
  respectively, no matter which function clause of $[\blank]_{\Ty}\blank$ is used.
  Therefore, type substitution is locally confluent.
\end{proof}

\propCorrectness*
\begin{proof}
  We show this statement by induction on $\sigma$. Since we are proving a propositional equality, and we are assuming UIP, all equality constructors are automatically respected, so we only need to worry about the point constructors.
  \begin{enumerate}
    \item For the identity substitution $\idS$, we have $[\idS]t = t \judgeq [\idS]_{\Tm} t$ by definition.
    \item For a composite substitution $\sigma; \tau$, we have
      \begin{align*}
        [\sigma;\tau]t & = [\sigma]\,([\tau] t)            && \text{by $[;]t$} \\
%                       & = [\sigma]\,([\tau]_{\Tm}\,t)       && \text{by the induction hypothesis $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                       & = [\sigma]_{\Tm}\,([\tau]_{\Tm}\,t) && \text{by the induction hypothesis (twice)} \\ %$[\sigma]u = [\sigma]_{\Tm}\,u$ for any $u$} \\
                       & \judgeq [\sigma;\tau]_{\Tm}\,t && \text{by definition.}
      \end{align*}
    \item For $\pi_1(\sigma, t)$, we have
      \begin{align*}
        [\pi_1(\sigma, t)]t & = [\sigma] t               && \text{by $\pi_1\beta$} \\
                            & = [\sigma]_{\Tm} \,t       && \text{by the induction hypothesis} \\ % $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                            & \judgeq [\pi_1(\sigma, t)]_{\Tm}\,t && \text{by definition.}
      \end{align*}
    %\item For $\pi_1(\sigma; \tau)$, it is proved similarly as the previous case.
    \item For the remaining cases, $[\sigma]_{\Tm} t$ is equal to $[\sigma]\,t$ strictly.
  \end{enumerate}
  Hence, we conclude that $[\blank]_{\Tm}\blank$ is propositionally equal to $[\blank]\blank$.
\end{proof}

\propCoherence*
\begin{proof}
  By \cref{re:coherence-proof}, for type substitution, we only have to consider the following cases 
  \begin{align*}
    [\sigma; (\tau, t)]_{\Ty} \;A    & = [(\sigma;\tau), [\sigma]\, t]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\emptyctx]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\pi_1\sigma, \pi_2\sigma]_{\Ty}\;A
  \end{align*}
  while other cases hold strictly.
  Again, for each case, we prove them by induction on $A$ and consider the case $A \defeq \El\,u$ only which is added to the definition of $[\blank]_{\Ty}\blank$ in this section. 
  However, all cases follow easily from \cref{prop:correctness-1}.
  For example, consider the first case:
  \begin{align*}
    [\sigma; (\tau, t)]_{\Ty}(\El\,u) & \judgeq \El([\sigma; (\tau, t)]_{\Tm}\,u) && \text{by \eqref{eq:def-type-subst-7}} \\
                                      & = \El( [\sigma; (\tau, t)]\,u)            && \text{by \cref{prop:correctness-1}} \\
                                      & = \El( [\sigma; \tau, [\sigma]t)]\,u)     && \text{by $\mathsf{concat}$} \\
                                      & = \El( [\sigma; \tau, [\sigma]t)]_{\Tm}\,u) && \text{by \cref{prop:correctness-1}} \\
                                      & \judgeq [\sigma; \tau, [\sigma]t)]_{\Ty}\left(\El\,u\right) && \text{by \eqref{eq:def-type-subst-7} }
  \end{align*}
  The remaining two cases are omitted.

  As for term substitution $[\blank]_{\Tm}\blank$, each case follows from \cref{prop:correctness-1} in conjunction with the congruence rule for the identity type.
\end{proof}

\propConfluenceThree*
\begin{proof}
  In addition to previous cases in \cref{prop:local-confluence-1,prop:local-confluence-2}, consider
  \begin{align*}
    [\idS]_{\Ty}\;(\Pi\;A\;B) && [\sigma;\tau]_{\Ty}\;(\Pi\;A\;B) && [\pi_1(\sigma, t)]_{\Ty}\;(\Pi\;A\;B) && [\pi_1(\sigma; \tau)]_{\Ty}\;(\Pi\;A\;B).
  \end{align*}
  Each of them reduces to the following terms after applying clauses of $\blank\uparrow\blank$ and $[\blank]_{\Ty}\blank$:
  \begin{align*}
    & \Pi\;A\;B                && \Pi\;([\sigma]_{\Ty}\,[\tau]_{\Ty}\,A)\;([\sigma \uparrow [\tau]\,A ]_{\Ty}\,[\tau \uparrow A ]_{\Ty}\,B) \\
    & \Pi\;([\sigma]_{\Ty}\;A)([\sigma \uparrow A]_{\Ty}\;B) && \Pi\;([\sigma]_{\Ty}\,[\pi_1\tau]_{\Ty}\,A)\;([\sigma \uparrow [\pi_1\tau]_{\Ty}\,[\pi_1\tau \uparrow A]_{\Ty}\,B)
  \end{align*}
  respectively.
  Hence, the type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
\end{proof}

\propCorrectnessTwo*
\begin{proof}
  We prove the statement by induction on $\sigma$ with \cref{lem:lifting}.
  Every case follows from equational reasoning straightforwardly.
  For example, if $\sigma$ is a composite $\sigma;\tau$, we have
  \begin{align*}
    (\sigma;\tau) \uparrow A & \judgeq (\sigma \uparrow [\tau]\,A);(\tau \uparrow A) && \text{by definition} \\
                             & = \sigma^+;\tau^+                                     && \text{by induction hypothesis} \\ 
                             & = (\sigma;\tau)^+                                     && \text{by \cref{lem:lifting}.} 
  \end{align*}
  Other cases follow similarly.
\end{proof}

\propCoherenceUparrow*
\begin{proof}
  These two identities follow from \cref{prop:correctness-2,prop:correctness-3} easily with the heterogeneous identity (see \cref{sec:meta}).
\end{proof}

\coherenceTel*
\begin{proof}
  \Fredrik{TODO: spell out all cases here}
  The proposition is easy to prove for the following equality
  constructors, since the lifting and substitution operations compute
  independently for these cases:
  \[
    \mathsf{idr} : \sigma;\idS = \sigma, \quad
    \mathsf{idl} : \idS;\sigma = \sigma, \quad\text{and}\quad
    \textnormal{;-}\mathsf{assoc} : (\sigma;\tau);\gamma = \sigma; (\tau; \gamma),
  \]
  Take $\mathsf{idr}$ as an example, we can see 
  \begin{align*}
    (\sigma; \idS) \upuparrows \Xi & \judgeq (\sigma \upuparrows [\idS]_{\Tel} \Xi) ; (\idS \upuparrows \Xi) \\
                                   & \judgeq (\sigma \upuparrows \Xi) ; \idS \\
                                   & = \sigma \upuparrows \Xi
  \end{align*}
  where the last identity follows from $\mathsf{idr}:(\sigma \upuparrows \Xi) ; \idS = \sigma \upuparrows \Xi$.

  For other two equality constructors, the arguments follow similarly.

The second set of equality constructors are more involved, as we have to prove the coherence for the lifting and substitution operations altogether mutually:
  \LT[noinline]{Josh Ko suggests us to follow the proof structure in our formal implementation.}
  For the following equality constructors $p : \sigma = \tau$
  \begin{alignat*}{5}
    \pi_1\beta    & : \pi_1(\sigma, t)  && = \sigma \qquad\qquad & \mathsf{concat} & : \sigma; (\tau, t) && = (\sigma;\tau), [\sigma]\, t \\
    \emptyctx\eta & : \sigma            && = \emptyctx & \pi\eta & : \sigma && = \pi_1\sigma, \pi_2\sigma
  \end{alignat*}
   the identities
  \begin{align*}
  [\sigma]_{\Tel}\,\Xi & = [\tau]_{\Tel}\,\Xi 
                         & [\sigma \upuparrows \Xi ]_{\Ty}\,A & =^{\lam{\gamma}\Ty\;(\Gamma \dplus [\gamma]_{\Tel}\Xi)}_{\alert{p}} [\tau \upuparrows \Xi ]_{\Ty}\,A \\
  \sigma \upuparrows \Xi & =^{\lam{\gamma}\Sub\;(\Gamma\dplus [\gamma]_{\Tel}\Xi)\;(\Delta\dplus\Xi)}_{\alert{p}} \tau \upuparrows \Xi
%    &
%  [\sigma \upuparrows \Xi ]_{\Tm}\,t & =^{\lam{\gamma}\Tm\;(\Gamma \dplus [\gamma]_{\Tel}\Xi)\;([\gamma \upuparrows \Xi]_{\Ty} A)}_{\alert{p}} [\tau \upuparrows \Xi ]_{\Tm}\,t
  \end{align*}
  hold for any telescope $\Xi : \Tel\,\Delta$ and type $A : \Ty\;(\Delta\dplus \Xi)$.
  We show the statement for $\pi_1\beta: \pi_1(\sigma, t) = t$ and the other three cases follow similarly.

  First, we prove the coherence for $[\blank]_{\Ty}\,A$ by induction on $A$ and the coherence for the other two identities $[\blank]_{\Tel}\, \Xi$ and $\blank \upuparrows \Xi$ by induction on $\Xi$.
  \begin{enumerate}
    \item Consider the following cases for $[\sigma\upuparrows\Xi]_{\Ty}\,A = [\tau \upuparrows \xi]_{\Ty}\,A$ by induction on $A$.
      \begin{description}
        \item[$A$ is $\UU$:] By definition
          \[
            [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,\UU_{\Delta\dplus \Xi} \judgeq \UU_{\Gamma \dplus [\pi_1(\sigma, t)]_{\Tel}\,\Xi} \quad\text{and}\quad [\sigma\upuparrows \Xi]_{\Ty}\,\UU_{\Delta\dplus \Xi} \judgeq \UU_{\Gamma \dplus [\sigma]_{\Tel}\,\Xi}
          \]
          By assumption, $[\pi_1(\sigma, t)]_{\Tel}\,\Xi = [ \sigma]_{\Tel}\,\Xi$ and by congruence $\Gamma \dplus [\pi_1(\sigma, t)]_{\Tel}\,\Xi = \Gamma \dplus [ \sigma]_{\Tel}\,\Xi$ holds.
          Then, $\UU_{\Gamma \dplus [\pi_1(\sigma, t)]_{\Tel}\,\Xi} \simeq \UU_{\Gamma \dplus [\sigma]_{\Tel}\,\Xi}$ holds by congruence for $\UU$.
          \LT{Justify the use of congruence rule for QIIT, e.g. $\transfib{\Ty}{p}{\UU_{\Gamma}} = \UU_{\Delta}$ for $p : \Gamma = \Delta$}

        \item[$A$ is $\El\,u$:]
          Similar to \cref{prop:coherence-2}, we use \cref{prop:correctness-3} and the congruence law for $[\blank]\,u$ to derive the desired identity.

        \item[$A$ is $\Pi\,B\,C$:]
          Note that one of the induction hypothesises is
          \[
            [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,C = [\sigma \upuparrows \Xi]_{\Ty}\,C
          \]
          for \emph{arbitrary} $\Xi$, so we can apply the induction hypothesis to $B$ and $C$ below:
          \begin{align*}
            & [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,(\Pi\,B\,C) \\
            \judgeq{} & \Pi\,([\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,B)\,([(\pi_1(\sigma, t) \upuparrows \Xi) \uparrow B]\,C) && \text{by the definition of $[\blank]_{\Ty}(\Pi\,B\,C)$} \\
            \judgeq{} & \Pi\,([\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,B)\,([(\pi_1(\sigma, t) \upuparrows (\Xi, B)]\,C) && \text{by the definition of $\upuparrows$} \\
            ={}       & \Pi\,([\sigma \upuparrows \Xi]_{\Ty}\,B)\,([\sigma \upuparrows (\Xi, B)]\,C) && \text{by induction hypothesises} \\
            \judgeq{} & \Pi\,([\sigma \upuparrows \Xi]_{\Ty}\,B)\,([(\sigma \upuparrows \Xi) \uparrow B]\,C) && \text{by the definition of $\upuparrows$} \\
            \judgeq{} & [\sigma\upuparrows \Xi]_{\Ty}\,(\Pi\,B\,C) && \text{by the definition of $[\blank]_{\Ty}(\Pi\,B\,C)$.}
          \end{align*}
      \end{description}
    \item By induction on $\Xi$, consider following cases for $[\pi_1(\sigma, t)]_{\Tel}\,\Xi = [\sigma]_{\Tel}\,\Xi$. 
      \begin{description}
        \item[$\Xi$ is the empty telescope $\emptytel$:] By definition, $[\pi_1(\sigma, t)]_{\Tel}\,\emptytel \judgeq \emptytel \judgeq [\sigma]_{\Tel}\,\emptytel$.
        \item[$\Xi$ is the telescope extension $\Xi, A$:] 
          \begin{align*}
            [\pi_1(\sigma, t)]_{\Tel}\,(\Xi, A) & \judgeq [\pi_1(\sigma, t)]_{\Tel}\,\Xi, [\pi_1(\sigma, t) \upuparrows \Xi]_{\Ty}\,A && \text{by definition} \\
                                                & = [\sigma]_{\Tel}\,\Xi, [\sigma \upuparrows \Xi]_{\Ty}\,A \\
                                                & \judgeq [\sigma]_{\Tel}(\Xi, A) && \text{by definition}
          \end{align*}
      \end{description}
    \item By induction on $\Xi$, consider the following cases for $\pi_1(\sigma, t) \upuparrows \Xi = \sigma \upuparrows\,\Xi$.
      \begin{description}
        \item[$\Xi$ is the empty telescope $\emptytel$:] $\pi_1(\sigma, t) \upuparrows \emptytel \judgeq \pi_1(\sigma, t) = \sigma \judgeq \sigma \upuparrows \emptytel$ by definition and the equality constructor.
        \item[$\Xi$ is the telescope extension $\Xi, A$:] 
          \begin{align*}
            \pi_1(\sigma, t) \upuparrows (\Xi, A) & \judgeq (\pi_1(\sigma, t) \upuparrows \Xi) \uparrow A \\
                                                  & =^{} (\pi_1(\sigma, t) \upuparrows \Xi)^{+} \\
                                                  & =^{\lam{\gamma}\Sub\,(\Gamma\dplus[\gamma]_{\Tel}\,\Xi, [\gamma \upuparrows \Xi]_{\Ty}\,A)\,(\Delta \dplus \Xi, A)}_{p} (\sigma\upuparrows \Xi)^{+} \\
                                                  & = (\sigma \upuparrows \Xi) \uparrow A \\
                                                  & \judgeq \sigma \upuparrows (\Xi , A)
          \end{align*}
      \end{description}
  \end{enumerate}
\end{proof}

\propProvableFunc*
\begin{proof}
  TODO
\end{proof}

\equivalence*
\begin{proof}
  TODO
\end{proof}

\end{document}
