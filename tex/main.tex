\documentclass[a4paper,UKenglish,numberwithinsect,cleveref,thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}

\title{Type theories as quotient inductive-recursive types}
\author{Liang-Ting Chen\footnote{Corresponding author; authors are listed in alphabetical order.}}{Institute of Information Science, Academia Sinica, Taiwan \and \url{http://l-tchen.github.io}}{ltchen@iis.sinica.edu.tw}{https://orcid.org/0000-0002-3250-1331}{The National Science and Technology Council of Taiwan under grant NSTC 114-2222-E-001-001-MY3.}
\author{Fredrik Nordvall Forsberg}{Department of Computer and Information Sciences, University of Strathclyde, UK \and \url{https://fredriknf.com}}{fredrik.nordvall-forsberg@strath.ac.uk}{https://orcid.org/0000-0001-6157-9288}{The Engineering and Physical Sciences Research Council [EP/Y000455/1].}
\author{Tzu-Chun Tsai}{Institute of Information Science, Academia Sinica, Taiwan}{gene0905@icloud.com}{}{The National Science and Technology Council of Taiwan under grant NSTC 112-2221-E-001-003-MY3.}
\authorrunning{L.-T.~Chen, F.~Nordvall Forsberg, and T.-C.~Tsai}
\Copyright{Liang-Ting Chen, Fredrik Nordvall Forsberg, and Tzu-Chun Tsai}
\ccsdesc[500]{Theory of computation~Type theory}
\keywords{inductive-inductive types, quotient inductive types, inductive-recursive types, substitution calculus, category with families, type theory in type theory.}
\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{Formal Agda development: \url{https://github.com/L-TChen/TTasQIIRT}.}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional
\acknowledgements{We'd like to thank Hsiang-Shang Ko for useful discussion.}%optional

\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{YYY}
\EventNoEds{1}
\EventLongTitle{10th International Conference on Formal Structures for Computation and Deduction (FSCD 2025)}
\EventShortTitle{FSCD 2025}
\EventAcronym{FSCD}
\EventYear{2025}
\EventDate{July 14--20, 2025}
\EventLocation{Birmingham, United Kingdom}
\EventLogo{}
\SeriesVolume{XX}
\ArticleNo{XX}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage{float}
\usepackage{manfnt}
\usepackage{mathpartir}
\newcommand{\danger}{\marginpar[\hfill\dbend]{\dbend\hfill}}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},color={pink},#1]{#2}}
\newcommand{\Gene}[2][]{\todo[inline,author={Gene},caption={},#1]{#2}}
\newcommand{\Fredrik}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}
\lstset{
    breaklines=true,
    breakatwhitespace=true,
    literate=%
      {≡}{$\equiv$}1
      {Γ}{$\Gamma$}1
      {Δ}{$\Delta$}1 
      {→}{$\to$}1
      {≅}{$\cong$}1
}

\input{macro.tex}


\begin{document}

\maketitle

\begin{abstract}
  Defining type theory in type theory is a long-standing benchmark for the strength and expressivity of type theory and proof assistants.
  Altenkirch and Kaposi used quotient inductive-inductive types to elegantly represent exactly the well-typed terms of type theory in intensional type theory, with the price to be paid that terms frequently contain transports along equality constructors.
  As a result, proofs need to painstakingly account for coercions alongside the interesting part.
  This %mess
  has been dubbed `transport hell', but is typically suppressed in informal presentation for clarity, hiding the gap between the intention and the formalisation.
  In this paper, we aim to shorten this gap, using quotient inductive-inductive-recursive types and definitions by overlapping patterns, reducing the use of transports.
  As a case study, we investigate type theory with a universe and $\Pi$-types, and compare our development with one using quotient inductive-inductive types.
\end{abstract}

\section{Introduction} \label{sec:intro}

Metaprogramming and mechanised metatheory in a type-theoretic proof assistant relies on having an internal representation of type theory within type theory itself.
%
In the spirit of type theory, we would like to represent well typed terms only --- this has technical advantages, such as theorem statements not having to deal with impossible cases, or separately having to prove wellformedness lemmas.
%
Doing this effectively seems to require sophisticated features of the host type theory, most notably advanced inductive definitions.
%
For example, inductive families~\cite{Dybjer1994} can be used to represent the simply typed $\lambda$-calculus~\cite{Altenkirch1999}, while some kind of simultaneous definitions such as inductive-recursive~\cite{Dybjer2000} or inductive-inductive~\cite{Nordvall-Forsberg2014} definitions are used for dependent type theory~\cite{Danielsson2006,Chapman2009}.
%
This is not just a matter of pure strength, but also expressivity and convenience: while it is known how to reduce inductive-inductive definitions to inductive families in principle~\cite{Kaposi2020a}, the resulting development would be considerably harder to work with, most likely exhausting the resources of both the proof assistant and its user.

Altenkirch and Kaposi~\cite{Altenkirch2016a} showed that by employing \emph{quotient inductive-inductive types} (QIITs)~\cite{Altenkirch2018}, the internal representation of well typed terms could be significantly simplified, since equality constructors can be used to represent equations such as $\beta$- and $\eta$-equality.
%
Yet, there is a general phenomenon, called `transport hell', when working with QIITs: to make use of equalities in later constructors and when using eliminators, equalities need to be transported across,
leading to intricate higher-dimensional equations between equations.

A typical workaround in practice \cite{Kaposi2019,Kaposi2024a} is to add equality constructors as rewrite rules~\cite{Cockx2021,Cockx2020} after an inductive definition.
%
As the host theory is assumed to satisfy the uniqueness of identity proof and function extensionality, this workaround can be justified by conservativity of equality reflection over intensional type theory~\cite{Hofmann1996,Winterhalter2019,Kapulkin2025}.
%
However, this workaround is computationally ill-behaved, as confluence does not hold in general.
Also, the presentation often differs from the actual definition in type theory.
%
Any method that reduces the friction introduced by equality constructors without compromising on computational properties and the gap between formalisation and presentation seem worth exploring.
%

In this paper, we show that the development can be streamlined by combining quotient inductive-inductive types and inductive-recursive types, called \emph{quotient inductive-inductive-recursive types} (QIIRTs).
%
The basic idea, following a suggestion by Kaposi~\cite{Kaposi2023} and precursors by Dybjer~\cite{Dybjer1996} and Danielsson~\cite{Danielsson2006}, is to replace the inductively defined action of a substitution on a type with a recursive definition, which computes.
%
Our development also makes use of another feature not usually found in standard presentations of type theory: pattern matching definitions with overlapping patterns.
%
This is helpful to avoid transport hell in the form of equations that do not reduce due to the standard translation of pattern matching to case trees~\cite{Cockx2017}.
%
As a result, many equations will hold strictly, and we can avoid the use of transport in the definition of type theory itself (which does not seem possible with QIITs alone).
%

%However, we found that using quotient inductive-inductive-recursive types alone were not sufficient for a smooth development.
%%
%%Not only do we want the action of substitutions on types to compute strictly, but we also want as many equations to hold strictly as possible:
%%
%%on the one hand, we want substitutions to distribute over type formers, but on the other hand we want substitutions to satisfy composition and unit laws of the category of context and substitutions up to strict equality.
%%
%Instead, we also needed to make use of functions defined by overlapping patterns.
%%
%In a proof assistant such as Agda, this can be emulated by Agda's experimental support for rewrite rules, but with an additional proof burden on the user to show (informally) that their use is justified meta-theoretically.
%%
%To get some help with this task by Agda's confluence checker, it is often necessary to needlessly complicate a definition to convince the checker that the proposed rewrite rules are indeed confluent.

%
We emphasise that, following a fine tradition of previous attempts to represent type theory in type theory~\cite{Danielsson2006,Chapman2009,Altenkirch2016a}, we are making use of type-theoretic features that are, so far, not yet well understood or foundationally well motivated.
Nevertheless, the proof assistant \Agda can be convinced to accept our formal implementation, using user-defined rewrite rules~\cite{Cockx2020,Cockx2021}.
Indeed, we also see this paper as a case study to motivate further developments for quotient inductive-inductive-recursive types and overlapping patterns.

\subparagraph*{Contributions}
This paper explores the use of QIIRTs and definitions by overlapping patterns to define type theories in intensional type theory. Our contributions are:
\begin{itemize}
  \item We give definitions of the parallel substitution calculus and type theories with a universe and $\Pi$-types as a QIIRT (\cref{sec:QIIRTs}).
  \item We show how elimination principles for reasoning about the type theory can be derived, and use it to construct its standard model (\cref{sec:models}).
  \item We compare our definition to definitions using quotient inductive-inductive types, and prove that the two definitions are actually equivalent (\cref{thm:equivalence}) in type theory.
\end{itemize}

%\subparagraph*{Plan of the paper}
%In the rest of the paper, we introduce the metatheory in \cref{sec:meta}.
%Then, we develop type theories formulated as QIIRTs in \cref{sec:QIIRTs}, follo%wed by their elimination principles and usage in \cref{sec:models}.
%We outline the \Agda formal implementation in \cref{sec:formal-implementation}, and we conclude with related and future work in \cref{sec:conclusion}.

\section{Notation and metatheory} \label{sec:meta}

We work in intensional Martin-L\"of type theory with uniqueness of identity proofs. In \cref{sec:models,sec:formal-implementation}, we also assume function extensionality and $\eta$-rules for $\Pi$-types and $\Sigma$-types.
%
We mostly follow the notational conventions of the HoTT book~\cite{UFP2013} (even if we do not assume the univalence axiom), except that we write dependent function types using \Agda notation $(x : A) \to B\,x$.
%
We are further inspired by \Agda in writing $\implicit{x}\;B\,x$ for $(x : A) \to B\,x$ when $x$ is treated as an `implicit' argument which should be clear from the context.
%We write $\Set_i$ for the hierarchy of universes with the level index $i$ suppressed.
We write $\Set$ for the universe of types (suppressing to mention a hierarchy of universes $\Set_i$).

We write $x \jdeq y$ for strict (definitional) equality, $x =^{A} y$ for the identity type stating that elements $x : A$ and $y : A$ of a type $A$ are equal, and $\dpath{P}{p}{t}{u}$ for the `dependent' identity type where $P : A \to \Set$, $t : P\,x$, $u : P\,y$ and $p : x =^A y$. One possible realisation of this type is as $t =^{P}_{p} u \defeq \transfib{P}{p}{t} =^{P\,y} u$, where $\transfibf{P} : (p : x =^A y) \to P\,x \to P\,y$ is the operation to transport values in the type family $P$ along an equality proof.
%

We have implemented our definitions and proofs in \Agda; see \cref{sec:formal-implementation} for details.
However, some statements are metatheoretical and thus not checked in \Agda. %, while others are only partially checked by \Agda, as proof obligations are given manually. %for postulated equality constructors.
We have marked such `informal' proofs with the symbol \resizebox*{!}{\baselineskip}{\textdbend}.

\subsection{Inductive-recursive types}
An inductive type $A$, such as the type of natural numbers $A = \mathbb{N}$, allows functions out of the type $f : A \to X$ to be defined using an elimination rule which says that $f$ is defined by its values $f(\cc_i\,x)$ on all of the constructors $\cc_i$ of~$A$.
%For example, a function $f: \mathbb{N} \to X$ is given by the values $f(0)$ and $f(\suc\,n)$, where the latter might refer to the already computed value $f(n)$.
%
The type is first defined inductively by listing its constructors, and then recursive functions can be defined out of it.

In contrast, an inductive-recursive type (IRT), introduced by Dybjer~\cite{Dybjer2000} and studied by Dybjer and Setzer~\cite{Dybjer1999,Dybjer2003}, is an inductive type $A$ defined \emph{simultaneously} with a recursively defined function $F : A \to D$ to some fixed (possibly large) type $D$.
The prototypical example is Tarski universe: a type $U$ of codes for small types is defined with a `decoding' function $T : U \to \Set$ which maps each code to the type it represents. Crucially, the code
\[
  \pi : (a : U) \to (T\,a \to U) \to U
  \quad\text{with}\quad T(\pi(a, b)) \defeq (x : T\,a) \to T\,(b\, x)
\]
for dependent function types makes sense only because we have access to the function $T$.
%

An IRT $(A, F)$ comes with an elimination rule that allows to define a dependent function  $f : (x : A) \to P\,x$ by giving values $f(\cc_i\,\overrightarrow{x})$ on all of the constructors $\cc_i$ of $A$, but the recursive function $F : A \to D$ is \emph{not} defined using this elimination rule, but part of the definition of the type itself.
%
In particular, the elimination rule can be used to define endofunctions on $A$, but the recursive function  $F : A \to D$ must target a pre-existing type $D$.
%
In this work, we will consider an extension of \emph{generalised} IRTs, where $F : A \to A$ is also allowed.
%
Such IRTs are accepted in \Agda and were previously used~\cite{Danielsson2006} to represent type theory in type theory.
%
%Their general metatheory would be interesting future work.

%\LT{Mention that the recursion part of induction-recursion are already not defined by elimination rule.}


\subsection{Quotient inductive-inductive and quotient inductive-recursive types}
% \subsection{Quotient inductive(-inductive)-recursive types}

Quotient inductive types (QITs) are a special case of higher inductive types~\cite{Lumsdaine2020}, where constructors can introduce not only new elements but also new equalities between the introduced elements.
%
%Since we assume the uniqueness of identity proofs, all QITs are implicitly truncated to be sets in the sense of homotopy type theory.
%
For example, the type $\JList{A}$ of \emph{join lists} can be given below
%\begin{figure}[b]
\begin{mathpar}
  \Jnil : \implicit{A}\; \JList{A} \and
  \Jsing{\blank} : \implicit{A}\; A \to \JList{A} \and
  \Jconcat{\blank}{\blank} : \implicit{A}\; \JList{A} \to \JList{A} \to \JList{A} \and
  \mathsf{idr} : \implicit{\ell}\; (\Jconcat{\ell}{\Jnil}) =^{\JList{A}} \ell \and
  \mathsf{idl} : \implicit{\ell}\; (\Jconcat{\Jnil}{\ell}) =^{\JList{A}} \ell \and
  \mathsf{assoc} : \implicit{\ell_0, \ell_1, \ell_2}\; \Jconcat{(\Jconcat{\ell_0}{\ell_1})}{\ell_2} =^{\JList{A}} \Jconcat{\ell_0}{(\Jconcat{\ell_1}{\ell_2})}
\end{mathpar}
%\begin{minipage}{.6\textwidth}
%\begin{alignat*}{3}
%  \Jnil                    & : \implicit{A}\;      && \JList{A} \\
%  \Jsing{\blank}           & : \implicit{A}\;      && A \to \JList{A} \\
%  \Jconcat{\blank}{\blank} & : \implicit{A}\;      && \JList{A} \to \JList{A} \to \JList{A}
%\end{alignat*}
%\end{minipage}
%\begin{minipage}{.4\textwidth}
%\begin{alignat*}{3}
%\end{alignat*}
%\end{minipage}
%\caption{The quotient inductive type of join lists}
%\label{fig:QIT-join-list}
%\end{figure}
%\vskip\belowdisplayskip\noindent
A quotient inductive-inductive type~\cite{Altenkirch2018} (QIIT) further allows the simultaneous definition of a type $A$ and a type family $B : A \to \Set$ defined inductively.
% --- this is different from an inductive-recursive definition of $A$ and $F : A \to D$, where $F$ is defined recursively.
%; indeed, inductive-inductive definitions only make sense when $D = \Set$.
The metatheory of QIITs has been extensively studied by Altenkirch et al.~\cite{Kaposi2018,Kaposi2019,Kovacs2020}.

We can also define join lists as a quotient inductive-\emph{recursive} type, as follows: the type $\JList{A}$ is defined simultaneously with a recursive function $\flatten : \implicit{A}\;\JList{A} \to \List{A}$ which flattens a join list into an ordinary list and replaces equality constructors $\mathsf{idl}$, $\mathsf{idr}$ and $\mathsf{assoc}$ by a single constructor
\[
  \mathsf{nf} : \implicit{A}\;(\ell, \ell' : \JList{A}) \to \flatten\,\ell =^{\mathsf{List}\,A} \flatten\,\ell' \to \ell =^{\JList{A}} \ell'.
\]
This constructor states that join lists are equal as soon as their flattenings are equal. For $\flatten$ to be well defined, it needs to respect the $\mathsf{nf}$ constructor, but this is a tautology: if $\ell =^{\JList{A}} \ell'$ because $\flatten\,\ell =^{\mathsf{List}\,A} \flatten\,\ell'$, then obviously $\flatten\,\ell =^{\mathsf{List}\,A} \flatten\,\ell'$.
%In this work, we will consider quotient inductive-inductive-recursive types, generalising QIITs and QITs.

%Shulman~\cite{Shulman2014} considered combining higher inductive types and inductive-recursive types, but the foundational status of this combination is underdeveloped. We will also make use of such a combination, which gives additional motivation to study its metatheory in future work.


\subsection{Definitions by overlapping patterns} \label{sec:meta:overlapping}
In a proof assistant such as \Agda, functions are defined using pattern matching and elaborated into case trees, which correspond to the eliminator, following a \emph{first-match} semantics~\cite{Cockx2020a} and employing termination checking.
%This elaboration offers conventional notation, while making computational behaviour opaque.
% and favouring asymmetric definitions.
For example, the two definitions of addition $+$ and $+'$
%
%\begin{figure}[b]%
\begin{minipage}{.48\textwidth}
  \begin{alignat*}{5}
%    \blank  & + \blank     && : \N \to \N \to \N \\
    0       &  + m         && = m  \\
  n         &  + 0         && = m  \\
  (\suc\;n) &  + m         && = \suc\;(n + m) \\
  n         &  + (\suc\;m) && = \suc\;(n + m)
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
%  \blank         & +'\blank     && : \N \to \N \to \N \\
  0              & +' m         && \defeq m  \\
  (\suc\;n)      & +' 0         && \defeq \suc\;n \\
  (\suc\;n)      & +' (\suc\;m) && \defeq \suc\;(n +' \suc\;m)
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip\noindent
%\caption{Two seemingly different definitions of addition}
%\label{fig:additions}
%\end{figure}
are the same after elaboration in \Agda: eliminating the first argument of $+$ distinguishes $0$ and $\suc\;n$ and refines the second and the third clauses into clauses of $+'$, making the fourth clause useless.
Each clause of $+'$ is strict while clauses of $+$ are not necessarily strict.
%This semantics for function definitions decides how definitions reduce and therefore how identities are proved.

Cockx~\cite{Cockx2014} explores an alternative semantics for pattern matching, where all clauses are strict, even in the presence of \emph{overlapping patterns}.
Thus, when a function $f$ is defined with overlapping patterns, the notation $f\;\overrightarrow{p_i} \reduce t_i$ is used to emphasize its reduction behaviour.
Under this semantics, each clause of $+$ is strictly equal to its right-hand side. %, also allowing the symmetry addition to be proved commutative directly by induction on $n$ and $m$.

A key requirement for definitions with overlapping patterns is that, in addition to termination and completeness, any overlapping clauses must eventually compute to the same term, i.e.\ the definition must be confluent.
Cockx shows that if a definition of $f$ is
\begin{enumerate}
  \item \emph{structurally recursive}~\cite{Abel2002}, i.e.\ arguments of recursive calls are structurally smaller, and
  \item \emph{locally confluent}, i.e.\ for any two function clauses $f\;\overrightarrow{p_1} \reduce t_1$ and $f\;\overrightarrow{p_2} \reduce t_2$ with a most general unifer $\sigma$ for $\overrightarrow{p_1}$ and $\overrightarrow{p_2}$, the terms $\sigma t_1$ and $\sigma t_2$ have the same normal form, 
\end{enumerate}
then $f$ is confluent --- essentially a variant of Newman's Lemma~\cite{Newman1942}.
We call a diagram $\sigma t_2 \Leftarrow f\,(\sigma\overrightarrow{p_1}) \Rightarrow \sigma t_1$ used in the analysis of local confluence a \emph{local peak}.

In this work, we will consider inductive types defined simultaneously with recursive functions using overlapping patterns.
Note that in the schema of IRTs these simultaneously defined functions are already not given by using elimination rules.

\section{Type theories as quotient inductive-inductive-recursive types} \label{sec:QIIRTs}

We begin by recalling the definition of the substitution calculus~\cite{Martin-Lof1992} as a QIIT, emphasising how the use of transports in its very definition complicates formal reasoning.
We then introduce its QIIRT counterpart (\cref{subsec:SC-QIIRT}) which shortens the gap between formal and informal reasoning, and develop a type theory with a universe (\cref{subsec:SC+U}) of small types, $\Pi$-types (\cref{subsec:SC+U+Pi}), and other type formers (\cref{subsec:SC+U+Pi+more}).

\subsection{Substitution calculus as a quotient inductive-inductive type} \label{subsec:SC-QIIT}

Substitution calculus has a type $\Ctx$ of contexts, a type $\Ty\,\Gamma$ of types in context $\Gamma : \Ctx$, a type $\Sub\;\Gamma\;\Delta$ of substitutions from context $\Gamma$ to context $\Delta$, and a type $\Tm\;\Gamma\;A$ of $A$-typed terms in $\Gamma$. 
This amounts to the following type families, mutually inductively defined:
\begin{align*}
  \Ctx   & : \Set                   & \Sub   & : \Ctx \to \Ctx \to \Set \\
  \Ty    & : \Ctx \to \Set          & \Tm    & : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Set
\end{align*}
$\Ctx$ has two constructors: $\emptyctx$ for the empty context, and $\blank,\blank$ for context extension, typed as
\[
  \emptyctx : \Ctx
  \qquad\qquad
  \blank,\blank : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Ctx.
\]
Note that a context extension $\Gamma , A$ is only wellformed if $A : \Ty\;\Gamma$, ensuring overall wellformedness of contexts, but requiring contexts and types to be defined simultaneously.

A substitution $\sigma : \Sub\;\Gamma\;\Delta$ acts on types $A : \Ty\;\Delta$ over $\Delta$ to `pull them back' to types $\sub{A}{\sigma} : \Ty\;\Gamma$ over $\Gamma$. That is, the action of type substitution can be seen as a constructor
\begin{alignat*}{3}
  \sub{\blank}{\blank} &: \implicit{\Gamma, \Delta} \; \Ty\;\Delta \to \Sub\;\Gamma\;\Delta \to \Ty\;\Gamma .
\end{alignat*}
%
Since $\Ty$ is inductively defined, we add a base case $\UU : \implicit{\Gamma} \Ty\,\Gamma$ to ensure that $\Ty\;\Gamma$ is not empty.
%for every $\Gamma$:
%
%If we were defining the notion of cwfs, type substitution would be enough for $\Ty$.
%For our inductive definition (i.e.\ the initial cwf), however, we need a base case in $\Ty\;\Gamma$, otherwise the type $\Ty$ would be empty as well as other types.
%Hence another constructor is introduced:
%\begin{alignat*}{3}
%  \UU & : \implicit{\Gamma} & \Ty\, \Gamma.
%\end{alignat*}
For now, $\UU$ serves as a constant, but we will reuse $\UU$ for the type of small types later.

Substitutions from $\Gamma$ to $\Delta = \emptyctx, A_1, \ldots, A_n$ can be understood intuitively as lists of terms $t_i : A_i$ in context $\Gamma$ for each type $A_i$ in $\Delta$: we have the empty substitution $\emptysub$, and substitution extensions $\sigma, t$ which substitutes the most recently bound variable by the term~$t$:
\[
  \emptysub : \implicit{\Gamma}\;\Sub\;\Gamma\;\emptyctx
  \qquad\qquad
  \blank,\blank : \implicit{\Gamma, \Delta, A}\; (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\;\Gamma\;(\sub{A}{\sigma}) \to \Sub\;\Gamma\;(\Delta, A).
\]
Note that the type substitution $\sub{A}{\sigma}$ is needed, because $A$ is well-formed in context $\Delta$ rather than in $\Gamma$.
We also ask for identity substitutions $\idS$ and compositions $\sigma;\tau$.
%because the substitution calculus is supposed to be the initial \emph{category} with families:
\[
  \idS : \implicit{\Gamma}\; \Sub\;\Gamma\;\Gamma
  \qquad\qquad \blank;\blank : \implicit{\Gamma, \Delta, \Theta}\;\Sub\;\Gamma\;\Delta \to \Sub\;\Delta\;\Theta \to \Sub\;\Gamma\;\Theta.
\]
These need to satisfy laws, which we will introduce later as equality constructors.
Context extension is characterised by its projections, which forgets and picks out the most recently substituted term respectively:
%Context comprehension is given by projections from \emph{non-empty} substitutions $\sigma : \Sub\;\Gamma\;(\Delta, A)$ for its \emph{tail} and its \emph{head}:
\begin{alignat*}{3}
  \pi_1 & : \implicit{\Gamma, \Delta, A}\;\Sub\;\Gamma\;(\Delta, A) \to \Sub\;\Gamma\;\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\;\Gamma\;(\Delta, A)) \to \Tm\;\Gamma\;(\sub{A}{\pi_1\,\sigma})
\end{alignat*}
%
Again, a type substitution $\sub{A}{\pi_1\,\sigma}$ is needed for~$\pi_2$, because $A$ is well-formed in context $\Delta$ instead of $\Gamma$.
Finally, we have term substitution, which given $\sigma : \Sub\;\Gamma\;\Delta$ turns terms in $\Delta$ to terms in $\Gamma$, appropriately preserving the type, which is also substituted:
\begin{alignat*}{3}
  \sub{\blank}{\blank} & : \implicit{\Gamma,\Delta, A}\;\Tm\;\Delta\;A \to (\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Gamma\;(\sub{A}{\sigma}).
\end{alignat*}
%Note that $\sub{\blank}{\blank}$ is overloaded for type and term substitution.

The structural rules for type substitution are stipulated by following equality constructors:
\begin{alignat*}{9}
  [\idS]_{\Ty} &: \implicit{\Gamma, A} \; && \sub{A}{\idS} && =^{\Ty\,\Gamma} A
  \qquad\qquad
  [;]_{\Ty}  : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A}\; \sub{A}{\sigma ; \tau} =^{\Ty\,\Gamma} \sub{\sub{A}{\tau}}{\sigma}
  \\
  []\UU &: \implicit{\Gamma, \Delta, \sigma} \; && \sub{\UU}{\sigma} && =^{\Ty\,\Gamma} \UU
\end{alignat*}
%
%\begin{alignat*}{3}
%  [\idS]_{\Ty} & : \implicit{\Gamma, A}                               && \sub{A}{\idS}           && =^{\Ty\,\Gamma}\;A \\
%  [;]_{\Ty}    & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A}\;&& \sub{A}{\sigma ; \tau}  && =^{\Ty\,\Gamma}\; \sub{(\sub{A}{\tau})}{\sigma} \\
%  []\UU      & : \implicit{\Gamma, \Delta, \sigma}                    && \sub{\UU}{\sigma}        && =^{\Ty\,\Gamma}\;\UU
%\end{alignat*}

The codomain $\Delta$ of a substitution $\sigma:\Sub\;\Gamma\;\Delta$ also tells the number of terms in $\sigma$, giving rise to two $\eta$-laws --- one for $\Delta$ being empty, and one for $\Delta$ being non-empty:
\[
  \emptyctx\eta : \implicit{\Gamma, A, \sigma}\; \sigma        =^{\Sub\,\Gamma\,\emptyctx} \; \emptysub
  \qquad\qquad
  \pi\eta       : \implicit{\Gamma, \Delta, \sigma}\; \sigma   =^{\Sub\,\Gamma\,(\Delta, A)} (\pi_1 \sigma, \pi_2 \sigma).
\]
%
The laws for substitution composition are stated using equality constructors, where, for the first time, we see the use of $\transp$ for both sides of the equation to have the same type.
\begin{align*}
  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma}\; {\sigma ; \idS_{\Delta}} =^{\Sub\,\Gamma\,\Delta} {\sigma}
                                                                                    \qquad\qquad
  \mathsf{idl}    : \implicit{\Gamma, \Delta, \sigma}\; {\idS_{\Gamma} ; \sigma} =^{\Sub\,\Gamma\,\Delta} {\sigma} \\
  \text{;-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \Xi, \sigma, \tau, \gamma}\; (\sigma ; \tau) ; \gamma =^{\Sub\,\Gamma\,\Theta} \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} \; \sigma ; (\tau , t) =^{\Sub\,\Gamma\,(\Theta, A)} \; (\sigma ; \tau) , \alert{\transfib{\Tm\,\Gamma}{[;]_{\Ty}^{-1}}{\color{black}\sub{t}{\sigma}}}
\end{align*}
%\begin{alignat*}{5}
%  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma} && {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
%  \mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma} && {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
%  \text{;-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \Xi, \sigma, \tau, \gamma}\; && (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
%  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} \; &%& \sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} \; &&  (\sigma ; \tau) , \alert{\transfib{\Tm\,\Gamma}{[;]_{\Ty}^{-1}}{\color{black}\sub{t}{\sigma}}}
%\end{alignat*}
%
Composition of substitutions $\blank;\blank$ acts like list concatenation, so
we would expect $\sigma; (\tau, t)$ to be the same thing as $(\sigma; \tau), \sub{t}{\sigma}$. However $\sub{t}{\sigma}$ is of type $\Tm\;\Gamma\;(\sub{\sub{A}{\tau}}{\sigma})$, but the extension $(\sigma; \tau), \sub{t}{\sigma}$ requires $\sub{t}{\sigma}$ to have type $\Tm\;\Gamma\;(\sub{A}{\sigma; \tau})$ instead. Of course, we have an equality constructor $[;]_{\Ty}^{-1}\colon \sub{\sub{A}{\tau}}{\sigma} = \sub{A}{\sigma;\tau}$ which we can transport along to fix up the equation.

%$\sigma; (\tau, t)$ is intuitively equal to $(\sigma; \tau), [\sigma]\,t$ whereas the term $t$ is of type $\Tm\;\Delta\;([\tau]\;A)$. 
%However, by the type of substitution extension, $[\sigma]\,t$ requires to be of type $\Tm\;\Gamma\;([\sigma; \tau]\,A)$ instead, so we have to transport $[\sigma]\,t$ explicitly along $[;]_{\Ty}^{-1}\colon [\sigma]\,[\tau]\;A = [\sigma;\tau]\,A$ to obtain a term of type $\Tm\;\Gamma\;([\sigma;\tau]\;A)$.

We would expect the first and second projections of $(\sigma, t)$ to be $\sigma$ and $t$ respectively,
\[
  \pi_1\beta : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; \pi_1(\sigma , t)        =^{\Sub\,\Gamma,\Delta} \sigma
  \qquad
  \pi_2\beta : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; \pi_2(\sigma , t) =^{\Tm\,\Gamma\,(\sub{A}{\blank})}_{\alert{\pi_1\beta}} t,
\]
%\begin{alignat*}{5}
%  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_1%(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
%  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_2%(\sigma , t)        && =^{\Tm\,\Gamma\,(\sub{A}{\blank})}_{\alert{\pi_1\beta}} &&  t, 
%\end{alignat*}
but again, note that the type of $\pi_2\beta$ only makes sense because we can transport along $\pi_1\beta$ to make sure both sides of the equation have the same type: $\pi_2(\sigma, t)$ is an habitant of $\Tm\;\Gamma\;(\sub{A}{\pi_1\,(\sigma, t)})$ instead of $\Tm\;\Gamma\;(\sub{A}{\sigma})$.
%whereas $\pi_2(\sigma, t)$ is an habitant of $\Tm\;\Gamma\;([\pi_1\,(\sigma, t)]\,A)$ instead of $\Tm\;\Gamma\;([\sigma]\,A)$ on the right-hand side. 
%Therefore, we have to transport $\pi_2(\sigma, t)$ along $\pi_1\beta$, so the above equality constructor is, in fact, $\transfib{\Tm\;\Gamma\;([\blank]\,A)}{\pi_1\beta}{\pi_2(\sigma, t)} =^{\Tm\;\Gamma\;([\sigma]\,A)} t$.
%
Similarly, for term substitution, terms are transported along the corresponding rules:
\[
  [\idS]_{\Tm} : \implicit{\Gamma, A, t}\; {\sub{t}{\idS}} =^{\Tm\;\Gamma}_{\alert{[\idS]_\Ty}} t
  \qquad\qquad
  [;]_{\Tm}    : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t}\; {\sub{t}{\sigma ; \tau}} =^{\Tm\;\Gamma}_{\alert{[;]_{\Ty}}}{\sub{\sub{t}{\tau}}{\sigma}}
\]
%equivalent to the following (homogeneous) identities
%\[
%  \transfib{\Tm\;\Gamma}{[\idS]_{\Ty}}{[\idS]\,t} =^{\Tm\,\Gamma\,A} t
%  \quad\text{and}\quad
%  \transfib{\Tm\;\Gamma}{[;]_{\Ty}}{[\sigma;\tau]\,t} =^{\Tm\,\Gamma\,([\sigma]\,[\tau]A)} [\sigma]\,[\tau]\,t
%\]
%respectively.
Constructors introduced so far complete the inductive definition of the substitution calculus.

The use of transports in the formal definition fixes type mismatches but hinders equational reasoning about these terms, even for simple facts such as the one below.
\begin{example}\label{ex:pi2-comp}
  Given any substitution $\sigma : \Sub\;\Gamma\; \Delta$ and a non-empty substitution $\tau : \Sub\;\Delta\;(\Theta, A)$ for any $A : \Ty\,\Theta$, the first term of the composite $(\sigma; \tau)$ should intuitively be equal to the first term of $\tau$ after applying the substitution $\sigma$, i.e.\ the identity
  \[
    \pi_2\,(\sigma ; \tau) = \sub{(\pi_2\,\tau)}{\sigma}
  \]
  apparently holds and can be checked by a back-of-the-envelope calculation
  \begin{equation} \label{eq:pi2-comp-proof}
    \pi_2\,(\sigma ; \tau) 
    = \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))
    = \pi_2\,(\sigma;\pi_1\,\tau, \sub{(\pi_2\,\tau)}{\sigma})
    = \sub{(\pi_2\,\tau)}{\sigma}.
  \end{equation}
  Yet, the above identity does not even make sense, since their types do not match --- the left-hand side is a term of type $\sub{A}{\pi_1\,(\sigma;\tau)}$, but the other is $\sub{\sub{A}{\pi_1\,\tau}}{\sigma}$.
  Alas, instead, we have to write $\pi_2\,(\sigma ; \tau) =^{\Tm\,\Gamma}_{p} \sub{(\pi_2\,\tau)}{\sigma}$ for some $p: \sub{A}{\pi_1(\sigma; \tau)} = \sub{\sub{A}{\pi_1\tau}}{\sigma}$ or, equivalently
  \begin{equation}\label{eq:pi2-comp-real-proof}
    (\sub{A}{\pi_1(\sigma; \tau)}, \pi_2(\sigma; \tau)) =^{(A : \Ty\,\Gamma) \times (\Tm \Gamma A)} (\sub{\sub{A}{\pi_1\,\tau}}{\sigma}, \sub{(\pi_2\,\tau)}{\sigma})
  \end{equation}
  as inhabitants of a $\Sigma$-type, so we can reason about term equalities along with type equalities.
  Moreover, in~\eqref{eq:pi2-comp-proof} we have used the rule $\mathsf{concat}$ which introduced another transported term, so we will have to remove that $\transp$ to derive the right-hand side.

  To better illustrate the annoyance, note that \eqref{eq:pi2-comp-real-proof} can be proved by following equations:
  \begin{alignat*}{3}
         & (\sub{A}{\pi_1(\sigma; \tau)}                    &&, \pi_2\,(\sigma ; \tau)) \\
    = {} & (\sub{A}{\pi_1(\sigma; (\pi_1\tau , \pi_2\tau))} &&, \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))) \\
    = {} & (\sub{A}{\pi_1(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}\sub{(\pi_2\;\tau)}{\sigma}})} &&, \pi_2\,(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}\sub{(\pi_2\;\tau)}{\sigma}})) \\
    = {} & (\sub{A}{\sigma;\pi_1\,\tau} &&, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}\sub{(\pi_2\;\tau)}{\sigma}})) \nonumber \\
    = {} & (\sub{\sub{A}{\pi_1\tau}}{\sigma} &&, \sub{(\pi_2\,\tau)}{\sigma}). \nonumber
  \end{alignat*}
  The first three equations corresponding to \eqref{eq:pi2-comp-proof} follow with Lemma~2.3.4 in \cite{UFP2013}, while the last has nothing to do with substitution calculus but the path lifting property (\cite[Lemma~2.3.2]{UFP2013}).
\end{example}

\subsection{Substitution calculus as a quotient inductive-inductive-recursive type} \label{subsec:SC-QIIRT}

To retain the intuitive way of reasoning such as in equation \eqref{eq:pi2-comp-proof} \emph{formally}, we would like to make type substitution rules strict, since the root cause is that type substitution does not compute as a constructor, leading to type mismatches occurring with substitution.

One possibility is to define the substitution calculus as a QIIRT, where type substitution is defined by recursion, and hence computes.
%Now that $[ \idS ]_{\Ty}\;A = A$ and $[ \sigma ; \tau ]_{\Ty}\;A = [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A)$ do not make $[\blank]_{\Ty}\blank$ a (total) function, we may be tempted to define it by
%\begin{alignat*}{3}
%[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
%[ \sigma ]_{\Ty}\;\UU & = \UU
%\end{alignat*}
Note that this does not follow the schema of inductive-recursive definitions given by Dybjer and Setzer~\cite{Dybjer1999}, since the codomain of the recursive function is the inductively defined typed itself.
%Nevertheless, $[\idS]_{\Ty}\,A$ and $[\sigma; \tau]_{\Ty}\,A$ do not reduce to~$A$ and~$[\sigma]_{\Ty}\,[\tau]_{\Ty}\,A$ respectively, even though they are provable.
Since we want type substitution to both act structurally on types and commute with identities and composition, we could try to define $\subTy{\blank}{\blank} : \implicit{\Gamma, \Delta} \; \Ty\;\Delta \to \Sub\;\Gamma\;\Delta \to \Ty\;\Gamma$ recursively as follows:
\begin{alignat}{3}
%\subTy{\blank}{\blank} &: \implicit{\Gamma, \Delta} \; \Ty\;\Delta \to \Sub\;\Gamma\;\Delta \to \Ty\;\Gamma \nonumber \\
\subTy{\UU}{\sigma}         & \defid \UU                                   \label{eq:type-sub-at2-1} \\
\subTy{A}{\idS}             & \defid A                                     \label{eq:type-sub-at2-2} \\
\subTy{A}{\sigma ; \tau}    & \defid \subTy{\subTy{A}{\tau}}{\sigma} \label{eq:type-sub-at2-3}
\end{alignat}
As explained in \cref{sec:meta:overlapping}, this definition does \emph{not} reduce \eqref{eq:type-sub-at2-2} or \eqref{eq:type-sub-at2-3} \emph{strictly}, and \eqref{eq:type-sub-at2-2} or \eqref{eq:type-sub-at2-3} will fire only if we know that $A$ is not $\UU$.
%In the above definition, only the eliminator for $\Ty\;\Delta$ will be considered using the first-match semantics, which amounts to the following definition:
%\begin{alignat*}{3}
%[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
%[ \sigma ]_{\Ty}\;\UU  & \reduce \UU
%\end{alignat*}
%where $\reduce$ is used to emphasise the reduction (which entails the strict equality): we have done nothing different from our first attempt! 
%As a result, neither  are strict.
We may swap \eqref{eq:type-sub-at2-1} with \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} to make \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} strict, but then \eqref{eq:type-sub-at2-1} will be elaborated to 
\[
\subTy{\UU}{\emptysub}         \judgeq \UU, \qquad
\subTy{\UU}{\sigma, t}         \judgeq \UU, \qquad\text{and}\qquad 
\subTy{\UU}{\pi_1\,\sigma}     \judgeq \UU,
\]
Thus in this case we have again lost the desired strict identity $\subTy{\UU}{\sigma} \equiv \UU$.
%
%making $[\sigma]\;\UU = \UU$ propositional instead.
%Not being able to reduce $[ \sigma ]_{\Ty}\;\UU$ to $\UU$ would make our later extension with a type $\El\,a$ for $a : \Tm\;\Gamma\;\UU$ require another transport in the definition.
%Likewise, for any extension with a type former such as $\Pi$-types, structural rules would still be propositional.
%That is, using the standard semantics of function definition, we are not able to make type substitution strict for \emph{both} $\Sub\;\Gamma\;\Delta$ and $\Ty\;\Delta$ at the same time.

To ensure that type substitution is strict for all clauses,
we turn to a definition by overlapping patterns %(\cref{sec:meta:overlapping})
instead. % to make each clause strict.
In addition, we can include other derived rules such as $\subTy{A}{\pi_1(\sigma, t)} = \subTy{A}{\sigma}$ as long as they are locally confluent and terminating.
We end up with the following definition for type substitution $\subTy{\blank}{\blank} : \implicit{\Gamma, \Delta} \; \Ty\,\Delta \to \Sub\,\Gamma\,\Delta \to \Ty\,\Gamma$:
\begin{alignat}{3}
% \subTy{\blank}{\blank}            &: \implicit{\Gamma, \Delta} \; \Ty\,\Delta \to \Sub\,\Gamma\,\Delta \to \Ty\,\Gamma \nonumber \\
\subTy{A}{\idS}                & \reduce A \label{eq:def-type-subst-1}\\
\subTy{A}{\sigma ; \tau}       & \reduce \subTy{\subTy{A}{\tau}}{\sigma} \label{eq:def-type-subst-2}\\
\subTy{A}{\pi_1(\sigma, t)}    & \reduce \subTy{A}{\sigma} \label{eq:def-type-subst-3} \\
\subTy{A}{\pi_1(\sigma; \tau)} & \reduce \subTy{\subTy{A}{\pi_1\tau}}{\sigma} \label{eq:def-type-subst-4} \\
\subTy{\UU}{\sigma}            & \reduce \UU                                   \label{eq:def-type-subst-5}
\end{alignat}
We first check that this definition of type substitution is confluent.
%
\begin{proposition}\label{prop:local-confluence-1}
  Type substitution $\subTy{\blank}{\blank}$ is terminating and locally confluent.
  \danger
\end{proposition}
\begin{proof}
  Termination is clear, since all recursive calls are on structurally smaller arguments~\cite{Abel2002}.
  For local confluence, we consider each combination of \eqref{eq:def-type-subst-5} with \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4},
  \[
    \subTy{\UU}{\idS} \qquad \subTy{\UU}{\sigma;\tau}, \qquad \subTy{\UU}{\pi_1(\sigma, t)}, \qquad\text{and}\qquad \subTy{\UU}{\pi_1(\sigma; \tau)}
  \]
  and show that each local peak results in $\UU$ using any applicable rules.
  %
  For example, $\subTy{\UU}{\sigma;\tau} \reduce \subTy{(\subTy{\UU}{\tau})}{\sigma} \reduce \subTy{\UU}{\sigma} \reduce \UU$ using \eqref{eq:def-type-subst-2} as the first reduction and $\subTy{\UU}{\sigma;\tau} \reduce \UU$ using \eqref{eq:def-type-subst-5} as the first reduction.
  It is easy to see that other local peaks reduce to the same term.
\end{proof}

With this definition of type substitution, other equality constructors can be introduced without any $\transp$, and we can give the updated constructors the types below.
\begin{alignat*}{5}
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t}\; &&\sigma ; (\tau , t) {} && =^{\Sub\,\Gamma\,(\Theta, A)} {} &&  (\sigma ; \tau), \sub{t}{\sigma} \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)          {} && =^{\Tm\,\Gamma\, (\subTy{A}{\sigma})} {} &&  t \\
  [\idS]         & : \implicit{\Gamma, A, t} && {\sub{t}{\idS}}          && =^{\Tm\,\Gamma\,A}      {} && t \\
  [;]            & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t}  && {\sub{t}{\sigma ; \tau}} && =^{\Tm\,\Gamma\,(\subTy{A}{\sigma ; \tau})} {} && {\sub{\sub{t}{\tau}}{\sigma}}
\end{alignat*}

We revisit \cref{ex:pi2-comp} to demonstrate the pragmatic benefit of QIIRTs over QIITs.
\begin{example} \label{ex:pi-comp-qiirt}
  Now, the equation $\pi_2\,(\sigma; \tau) = \sub{(\pi_2\,\tau)}{\sigma}$ can be formally stated without any transport: the type of the term on the left is $\subTy{A}{\pi_1(\sigma;\tau)}$ which is strictly equal to the type $\subTy{(\subTy{A}{\pi_1\tau})}{\sigma}$ of the term on the right.
  Moreover, the first components in each step of the proof of \eqref{eq:pi2-comp-real-proof}, are strictly equal because of \eqref{eq:def-type-subst-3} and \eqref{eq:def-type-subst-4}.
  Consequently, the back-of-the-envelope calculation~\eqref{eq:pi2-comp-proof} is \emph{formally correct}.
\end{example}

However, we still have a little bit more work to do before we can declare victory: as we are defining a function on a quotient inductive type, we have to prove that $\subTy{\blank}{\blank}$ is coherent, i.e., that it respects all equality constructors.
%\LT[noinline]{Should we mention any general condition for coherence?}
%\Fredrik[noinline]{Is there one?}
%\LT[noinline]{I think Cubical Agda has sort of conditions? (Cubical Agda does not support rewriting)}
\begin{proposition}\label{prop:coherence-1}
  For every equality constructor $\cc : \sigma = \tau$, we have $\subTy{A}{\sigma} = \subTy{A}{\tau}$.
  \danger
\end{proposition}
\begin{proof}
  The equality constructors $[\idS]_T$, $[;]_T$, and $[]\UU$ turn into definitional equalities for type substitution, so it remains to show that the following identities
  \begin{align*}
    \subTy{A}{\sigma;\idS}          & = \subTy{A}{\sigma},
                                    & \subTy{A}{\idS;\sigma}          & = \subTy{A}{\sigma},
                                     & \subTy{A}{(\sigma;\tau);\gamma} & = \subTy{A}{\sigma; (\tau; \gamma)}, \\
    \subTy{A}{\pi_1(\sigma, t)}      & = \subTy{A}{\sigma}, \\
    \subTy{A}{\sigma; (\tau, t)}    & = \subTy{A}{(\sigma;\tau), \sub{t}{\sigma}},
                                     & \subTy{A}{\sigma}               & = \subTy{A}{\emptyctx},
                                     & \subTy{A}{\sigma}               & = \subTy{A}{\pi_1\sigma, \pi_2\sigma}
  \end{align*}
  hold propositionally.
  The first two identities of the first row hold strictly by \eqref{eq:def-type-subst-1} and \eqref{eq:def-type-subst-2}, while both sides of the third reduce to $\subTy{\subTy{\subTy{A}{\gamma}}{\tau}}{\sigma}$ by \eqref{eq:def-type-subst-2}.
  %
  The second row is clause \eqref{eq:def-type-subst-3} of the definition of $\subTy{\blank}{\blank}$.
  %
  We show the remaining cases by induction on $A$.
  However, $\UU$ is the only constructor for $\Ty\;\Gamma$ and each of the identities with $A \judgeq \UU$ reduce to $\UU$.
\end{proof}
\begin{remark}\label{re:coherence-proof}
  In the above proof the first four identities hold strictly by \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4}, while the last three follow from \eqref{eq:def-type-subst-5} by induction on $A$.
  As we add other type formers, the first four identities will always hold, but the last three will depend on how type substitution is defined.
\end{remark}

\subsection{Adding a universe} \label{subsec:SC+U}
Now we extend substitution calculus with an empty universe $\UU$ of small types~$\El\,u$.
In a QIIT definition \cite{Altenkirch2016a}, this extension adds the following constructors
\begin{alignat*}{3}
  \El   & : \implicit{\Gamma} && \Tm\,\Gamma\;\UU \to \Ty\,\Gamma \\
  []\El & : \implicit{\Gamma, \Delta, \sigma, u} && \sub{(\El\, u)}{\sigma} =^{\Ty\;\Gamma} \El\,(\alert{\transfib{\Tm\;\Gamma}{[]\UU}{\color{black}\sub{u}{\sigma}}})
\end{alignat*}
%as the type $\UU$ of universe and its structural rule $[]\UU$ have been added to avoid a trivial inductive type.
The type substitution $\sub{(\El\,u)}{\sigma}$ is, informally, the type of the term substitution $\sub{u}{\sigma}$ for $u : \Tm\;\Delta\;\UU$, and the transport is needed to coerce $\sub{u}{\sigma} : \Tm\;\Gamma\;(\sub{\UU}{\sigma})$ into $\Tm\;\Gamma\;\UU$.
%
In our QIIR definition, $\transfib{\Tm\;\Gamma}{[]\UU}{\blank}$ is no longer needed, since $[]\UU$ becomes strict. 
Likewise, the equality constructor $[]\El$ may be replaced by the reduction
\begin{alignat*}{3}
  \subTy{(\El\, u)}{\sigma} & \reduce \El\,(\sub{u}{\sigma})
\end{alignat*}
Yet, this naive change breaks local confluence!
The problem is that there is now additional interaction between types and terms.
% Observe that
The local peak
\(
  \El\,u \Leftarrow \subTy{(\El\,u)}{\idS} \reduce \El(\sub{u}{\idS})
\)
cannot reduce to the same term, since the term substitution $\sub{u}{\idS}$ is merely a constructor.
%

To repair local confluence, we add a simultaneously defined term substitution function $\subTm{\blank}{\blank} : \implicit{\Gamma, \Delta, A}\;\Tm\,\Delta\,A \to (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,(\subTy{A}{\sigma})$, different from the constructor $\sub{\blank}{\blank}$, with the following reductions:
\begin{alignat*}{3}
%  \subTm{\blank}{\blank} & : \implicit{\Gamma, \Delta, A}\;\Tm\,\Delta\,A \to (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,(\subTy{A}{\sigma}) \\
\subTm{t}{\idS}          & \reduce t \\
\subTm{t}{\sigma ; \tau} & \reduce \subTm{\subTm{t}{\tau}}{\sigma} \\
\subTm{t}{\pi_1(\sigma, s)} & \reduce \subTm{t}{\sigma} \\
\subTm{t}{\pi_1(\sigma; \tau)} & \reduce \subTm{\subTm{t}{\pi_1\tau}}{\sigma} \\
\subTm{t}{\sigma}        & \reduce \sub{t}{\sigma}, \quad \text{otherwise}
\end{alignat*}
This reduces substitutions that occur in \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4} recursively so that the reduction can be propagated from types to terms.
The remaining `default' cases reduce to the constructor $\sub{t}{\sigma}$.
Note that $\subTm{\blank}{\blank}$ can be defined with the standard first-match pattern matching semantics, since there are no overlapping patterns.
\begin{remark}
  The function $\subTm{\blank}{\blank}$ can be understood as a \emph{smart constructor} for the explicit term substitution $\sub{\blank}{\blank}$, a well-known idiom in functional programming: the function $\subTm{\blank}{\blank}$ computes certain cases away, but mostly reduces to the non-smart constructor $\sub{\blank}{\blank}$.
\end{remark}

The equality constructor $[]\El$ is now accordingly replaced by the reduction
\begin{align}
  \subTy{(\El\, u)}{\sigma} & \reduce \El\,(\subTm{u}{\sigma}) \label{eq:def-type-subst-7}
\end{align}
to retain the local confluence for type substitution. The proof is similar to the proof of \cref{prop:local-confluence-1}, and can be found in \cref{appendix:proofs}.
%\begin{proposition}[Termination]
%  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
%  \danger
%\end{proposition}
%\begin{proof}
%  Again, each recursive call is on a structurally smaller term~\cite{Abel2002}.
%\end{proof}
\begin{restatable}{proposition}{propConfluenceTwo}\label{prop:local-confluence-2}
  \danger
  Type substitution $\subTy{\blank}{\blank}$ is terminating and locally confluent.
\end{restatable}

We also have to show that the recursive substitution $\subTm{\blank}{\blank}$ is propositionally equal to the explicit substitution $\sub{\blank}{\blank}$, so they can be used together consistently.


\begin{restatable}{proposition}{propCorrectness}\label{prop:correctness-1}
  For any $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Tm\;\Delta\;A$, we have $\sub{t}{\sigma} = \subTm{t}{\sigma}$.
\end{restatable}

Finally, we have to show that both $\subTy{\blank}{\blank}$ and $\subTm{\blank}{\blank}$ are coherent.
%
\begin{restatable}{proposition}{propCoherence}\label{prop:coherence-2}
  For every equality constructor $\cc : \sigma =^{\Sub\;\Gamma\;\Delta} \tau$, the identities
  \danger
    $\subTy{A}{\sigma} = \subTy{A}{\tau}$
    and
    $\subTm{t}{\sigma} = \subTm{t}{\tau}$
  hold for any type $A$ and any term $t$.
\end{restatable}

\begin{remark}
We have seen that a naive addition of a universe breaks the local confluence of type substitution defined in \cref{subsec:SC-QIIRT}, because the newly added function clause interacts with existing clauses.
In general, every term that occurs on the right-hand side of a clause needs to propagate the reduction to allow a confluent term to exist, and this propagation can be achieved by turning a constructor involving a substitution into a recursive function.
\end{remark}

\subsection{Adding \texorpdfstring{$\Pi$}{Π}-types} \label{subsec:SC+U+Pi}

We extend the type theory in \cref{subsec:SC+U} with $\Pi$-types, i.e.\ dependent function types. % --- the context of the codomain is extended with the domain type.
For a QIIT definition~\cite{Altenkirch2016a}, this amounts to adding the following constructors for the type formation rule and the term introduction/elimination rules
\begin{alignat*}{3}
  \Pi     &: \implicit{\Gamma}           \; && (A : \Ty\,\Gamma) \to \Ty\,(\Gamma, A) \to \Ty\,\Gamma \\
  \lambda &: \implicit{\Gamma, A, B}     \; && \Tm\;(\Gamma, A)\;B \to \Tm\,\Gamma\,(\Pi\;A\;B) \\
  \mathsf{app} &: \implicit{\Gamma, A, B}\; && \Tm\;\Gamma\;(\Pi\;A\;B) \to \Tm\;(\Gamma, A)\;B
\end{alignat*}
the computation rules
\[
  \Pi\beta           : \implicit{\Gamma, A, B, t}\; \mathsf{app}\,(\lambda\,t) =^{\Tm\;\Gamma\;A} t
  \qquad\qquad
  \Pi\eta            : \implicit{\Gamma, A, B, t}\; t                         =^{\Tm\;\Gamma\;A} \lambda(\mathsf{app}\,t)
\]
%\begin{alignat*}{5}
%  \Pi\beta           & : \implicit{\Gamma, A, B, t}\; && \mathsf{app}\,(\lambda\,t) && =^{\Tm\;\Gamma\;A} && t \\
%  \Pi\eta            & : \implicit{\Gamma, A, B, t}\; && t                      %    && =^{\Tm\;\Gamma\;A} && \lambda(\mathsf{app}\,t)
%\end{alignat*}
and the structural rules for substitution
\begin{alignat}{5}
  []\Pi              & : \implicit{\Gamma, \Delta, \sigma, A, B}\;    && \sub{(\Pi\;A\;B)}{\sigma} && =^{\Ty\;\Gamma} && \Pi\,(\sub{A}{\sigma})\,(\sub{B}{\sigma\uparrow A}) \label{eq:def-type-subst-8} \\
  \mathsf{[]\lambda} & : \implicit{\Gamma, \Delta, \sigma, A, B, t}\; && \sub{(\lambda\,t)}{\sigma} && =^{\Tm\,\Gamma}_{\alert{[]\Pi}} && \lambda\,(\sub{t}{\sigma \uparrow A}) \nonumber
\end{alignat}
where $\sigma \uparrow A$ is the \emph{lifting}  of $\sigma$ by a type $A$ defined as $(\pi_1\idS; \sigma, \alert{\transfib{\Tm\;\Gamma}{[;]_{\Ty}}{\color{black}\pi_2\idS}})$. 

For our QIIR definition, %$\sigma\uparrow A$ and $[]\lambda$ do not need a transport since $[;]_T$ and $[]\Pi$ are strict.
we do not need any transport since $[;]_{\Ty}$ and $[]\Pi$ are strict.
However, once again, adding \eqref{eq:def-type-subst-8} directly to the type substitution $\subTy{\blank}{\blank}$ breaks local confluence, because the reduction gets stuck upon the lifting $\sigma \uparrow A$.
For example, $\subTy{(\Pi\;A\;B)}{\idS}$ reduces to $\Pi\;A\;(\subTy{B}{\idS \uparrow A})$ where $\idS \uparrow A$ is propositionally but not strictly equal to $\idS$, so the local peak $\Pi\;A\;B \Leftarrow \subTy{(\Pi\;A\;B)}{\idS} \reduce \Pi\;A\;(\subTy{B}{\idS \uparrow A})$ cannot be joined. 

To retain the local confluence, we turn $\sigma \uparrow A$ into a simultaneously defined function:
\begin{alignat}{3}
  \blank\uparrow \blank & : \implicit{\Gamma, \Delta}\; (\sigma : \Sub\,\Gamma,\Delta) (A : \Ty\,\Delta) \to \Sub\,(\Gamma, \subTy{A}{\sigma})\, (\Delta, A) \label{eq:type-of-lifting} \\
\idS                \uparrow A & \reduce \idS \nonumber \\
(\sigma ; \tau)     \uparrow A & \reduce (\sigma \uparrow \subTy{\tau}{A} ) ; (\tau \uparrow A) \nonumber \\
\pi_1(\sigma, t)    \uparrow A & \reduce \sigma \uparrow A \nonumber \\
\pi_1(\sigma; \tau) \uparrow A & \reduce (\sigma \uparrow \subTy{\pi_1 \tau}{A}) ; (\pi_1 \tau \uparrow A)\nonumber \\
\sigma              \uparrow A & \reduce \sigma^+ , \quad \text{otherwise} \nonumber
\end{alignat}
where $\sigma^+ \defeq (\pi_1\idS ; \sigma), \pi_2\idS$.
Then, we add another clause for type substitution
\begin{equation*}
  \subTy{(\Pi\,A\,B)}{\sigma} \reduce \Pi\,(\subTy{A}{\sigma})\,(\subTy{B}{\sigma\uparrow A}) %\label{eq:def-type-subst-9}
\end{equation*}
and an equality constructor for term substitution without transport:
\begin{alignat}{5}
  \mathsf{[]\lambda} :{} & \sub{(\lambda\,t)}{\sigma} && =^{\Tm\,\Gamma\,(\subTy{(\Pi\,A\,B)}{\sigma})} && \lambda\,(\sub{t}{\sigma \uparrow A}) \nonumber
\end{alignat}

\begin{restatable}{proposition}{propConfluenceThree}\label{prop:local-confluence-3}
  Type substitution $\subTy{\blank}{\blank}$ is terminating and locally confluent.
    \danger
\end{restatable}

The lifting $\sigma^+$ interacts well with identities and composition.
For comparision, the reader is invited to prove the corresponding QIIT version with transports of the following lemma.
%
\begin{restatable}{lemma}{lemIdentities}\label{lem:lifting}
  For all contexts $\Gamma$, $\Delta$, $\Theta$, types $A : \Ty\,\Theta$ and substitutions $\sigma : \Sub\,\Gamma\,\Delta$ and $\tau : \Sub\,\Delta\,\Theta$, we have $\idS^+ =^{\Sub\;(\Theta, A)\;(\Theta, A)} \idS$ and $(\sigma; \tau)^+     =^{\Sub\;(\Gamma, \subTy{A}{\sigma; \tau})\;(\Theta, A)} \sigma^+ ; \tau^+$.
\end{restatable}

Using this lemma, we can show that the lifted substitution $\sigma \uparrow A$ agrees propositionally with its `default' reduction $\sigma^+$.

\begin{restatable}{proposition}{propCorrectnessTwo}\label{prop:correctness-2}
    For every $\sigma : \Sub\;\Gamma\;\Delta$, and $A : \Ty\;\Delta$, we have
    $\sigma \uparrow A = \sigma^+$.
\end{restatable}

As we are working with a different type theory from \cref{subsec:SC+U}, we  have to again prove the identity $\sub{t}{\sigma} = \subTm{t}{\sigma}$, but the same argument still applies:
\begin{restatable}{proposition}{propCorrectnessThree}\label{prop:correctness-3}
  For every $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Ty\;\Delta\;A$, we have $\sub{t}{\sigma} = \subTm{t}{\sigma}$.
\end{restatable}

Finally, we show that these simultaneously defined functions are coherent.
\begin{restatable}{proposition}{propCoherenceUparrow} %[Coherence]
  For every equality constructor $\cc : \sigma =^{\Sub\;\Gamma\;\Delta} \tau$ and  any type $A$ and term $t$,   \danger we have
  $\sigma \uparrow A =^{\Sub\;(\Gamma, \subTy{A}{\blank})\;(\Delta, A)}_{\alert{\cc}} \tau \uparrow A$
      and
      $\subTm{t}{\sigma} =^{\Tm\;\Gamma\;(\subTy{A}{\blank})}_{\alert{\cc}} \subTm{t}{\tau}$.
    \end{restatable}

\subsubsection*{Multiple lifting and the coherence of type substitution}

We also need to prove coherence of type substitution, i.e., for every equality constructor $\cc : \sigma = \tau$, we have $\subTy{A}{\sigma} = \subTy{A}{\tau}$ .
To do this, we need to generalise the desired identity to account for liftings, since a naive induction does not work: for example, on $\Pi$-types, we have
\[
  \subTy{(\Pi\;A\;B)}{\sigma} = \Pi\;(\subTy{A}{\sigma})\;(\subTy{B}{\sigma\uparrow A}) \qquad
  \subTy{(\Pi\;A\;B)}{\tau} = \Pi\;(\subTy{A}{\tau})\;(\subTy{B}{\tau\uparrow A})
\]
but the induction hypothesis does not give us $\subTy{B}{\sigma\uparrow A} = \subTy{B}{\tau\uparrow A}$.
Instead, we define the \emph{multiple lifting} $\sigma \upuparrows \Xi$ by a telescope $\Xi = A_1, \dots, A_n$, given by multiple applications of lifting $\sigma \uparrow A_1 \uparrow \dots \uparrow A_n$.
For each constructor $\cc : \sigma = \tau$, we then show %the identity
$\subTy{A}{\sigma \mathop{\upuparrows} \Xi} = \subTy{A}{\tau \mathop{\upuparrows} \Xi}$
for arbitrary $\Xi$, subsuming the special case $\subTy{A}{\sigma} = \subTy{A}{\tau}$ when $\Xi$ is empty.

The type of telescopes $\Tel : \Ctx \to \Set$ over a `base' context $\Gamma$ are defined inductive-recursively together with a concatenation $\blank \dplus\blank : (\Gamma : \Ctx) \to \Tel\;\Gamma \to \Ctx$ as follows.
\begin{alignat*}{9}
  \emptytel          & : \implicit{\Gamma}\; && \Tel\;\Gamma \qquad 
                     && \Gamma && \dplus \emptytel && \reduce \Gamma \\
  \blank,\blank      & : \implicit{\Gamma}\; && (\Xi : \Tel\;\Gamma) \to \Ty\;(\Gamma \dplus \Xi) \to \Tel\;\Gamma\qquad
                     && \Gamma && \dplus (\Xi, A)  && \reduce (\Gamma \dplus \Xi) , A
\end{alignat*}
Equipped with telescopes, we can now generalise single lifting with type \eqref{eq:type-of-lifting} to multiple lifting with type
\[
\blank\upuparrows \blank : (\sigma : \Sub\;\Gamma\;\Delta) \to (\Xi : \Tel\;\Delta)
\to \Sub\;(\Gamma \dplus \subTel{\Xi}{\sigma})\;(\Delta \dplus \Xi)
\]
which asks for telescope substitution $\subTel{\blank}{\blank} :  \Tel\;\Delta \to \Sub\;\Gamma\;\Delta \to \Tel\;\Gamma$ defined mutually:
\begin{alignat*}{9}
  \subTel{\emptytel}{\sigma} & {} \reduce \emptytel \qquad
                             && \sigma \upuparrows \emptytel && \reduce \sigma \\
  \subTel{(\Xi, A)}{\sigma}  & {} \reduce \subTel{\Xi}{\sigma}, \subTy{A}{\sigma \upuparrows \Xi} \qquad\qquad
                             && \sigma \upuparrows (\Xi, A)  && \reduce (\sigma \upuparrows \Xi) \uparrow A
\end{alignat*}
%\begin{minipage}{.6\textwidth}
%\begin{alignat*}{5}
%  \subTel{\emptytel}{\sigma} & {} \reduce \emptytel \\
%  \subTel{(\Xi, A)}{\sigma}  & {} \reduce \subTel{\Xi}{\sigma}, \subTy{A}{\sigma \upuparrows \Xi}
%\end{alignat*}
%\end{minipage}
%\begin{minipage}{.4\textwidth}
%\begin{alignat*}{5}
%  & \sigma \upuparrows \emptytel && \reduce \sigma \\
%  & \sigma \upuparrows (\Xi, A)  && \reduce (\sigma \upuparrows \Xi) \uparrow A
%\end{alignat*}
%\end{minipage}
%\vskip\belowdisplayskip

To prove the coherence property for the multiple lifting, we would need the properties $\idS_\Gamma \upuparrows \Xi = \idS_{\Gamma \dplus  \Xi}$ and $(\sigma; \tau) \upuparrows \Xi = (\sigma\upuparrows \subTel{\Xi}{\tau}); (\tau \upuparrows \Xi)$, similar to \cref{lem:lifting}, but these identities cannot be typed: the type of $\idS_{\Gamma} \upuparrows \Xi$ is $\Sub\;(\Gamma \dplus \subTel{\Xi}{\idS})\;(\Gamma \dplus \Xi)$ while the type of $\idS$ on the RHS is $\Sub\;(\Gamma \dplus \Xi)\;(\Gamma \dplus \Xi)$; similarly for the substitution composition.
%
Instead of resorting to \transp, we can also turn telescope substitution $\subTel{\blank}{\blank}$ and the multiple lifting into definitions by overlapping patterns by adding the following clauses:
\begin{alignat*}{9}
  \subTel{\Xi}{\idS}          & \reduce \Xi\qquad\qquad
                              && \idS          && \upuparrows \Xi && \reduce \idS \\
  \subTel{\Xi}{\sigma ; \tau} & \reduce \subTel{\subTel{\Xi}{\tau}}{\sigma} \qquad\qquad
                              && (\sigma;\tau) && \upuparrows \Xi && \reduce (\sigma \upuparrows \subTel{\Xi}{\tau}) ; (\tau \upuparrows \Xi)
\end{alignat*}
%\begin{minipage}{.5\textwidth}
%\begin{alignat*}{3}
%  \subTel{\Xi}{\idS}          & \reduce \Xi \\
%  \subTel{\Xi}{\sigma ; \tau} & \reduce \subTel{\subTel{\Xi}{\tau}}{\sigma}
%\end{alignat*}
%\end{minipage}
%\begin{minipage}{.5\textwidth}
%\begin{alignat*}{5}
%  & \idS          && \upuparrows \Xi && \reduce \idS \\
%  & (\sigma;\tau) && \upuparrows \Xi && \reduce (\sigma \upuparrows \subTel{\Xi}{\tau}) ; (\tau \upuparrows \Xi)
%\end{alignat*}
%\end{minipage}\vskip\belowdisplayskip\noindent
%whose confluence property is easy to see.

Of course, we also have to prove coherence for the newly introduced recursive functions to verify that they are well defined.

\begin{restatable}%[{Coherence for $[\blank]_{\Tel}$ and $\blank\upuparrows\blank$}]
{proposition}{coherenceTel}
  For every equality constructor $\cc : \sigma = \tau$ and telescope $\Xi$, we have
  \danger
  \begin{align*}
    \subTel{\Xi}{\sigma} & = \subTel{\Xi}{\tau}
                         && \sigma \upuparrows \Xi =^{\Sub\;(\Gamma\dplus \subTel{\Xi}{\blank})\;(\Delta\dplus\Xi)}_{\alert{\cc}} \tau \upuparrows \Xi \\
    \subTy{A}{\sigma \upuparrows \Xi} & =^{\Ty\;(\Gamma \dplus \subTel{\Xi}{\blank})}_{\alert{\cc}} \subTy{A}{\tau \upuparrows \Xi}.
  \end{align*}
\end{restatable}

As promised, by instantiating $\Xi$ to be empty, we also get coherence for $\subTy{\blank}{\blank}$.

\begin{corollary}
  We have $\subTy{A}{\sigma} = \subTy{A}{\tau}$ for every equality constructor $\cc : \sigma = \tau$.
  \danger
\end{corollary}

Finally, we note that for $t : \Tm\,\Gamma\,(\Pi\,A\,B)$ and $u : \Tm\,\Gamma\,A$, also `ordinary' application
$t \mathop{\$} u \defeq \subTm{(\mathsf{app}\,t)}{\idS , t}$ of type $\Tm\,\Gamma\,(\sub{B}{\idS , t})$ can be defined without any transport. This is in contrast to the QIIT situation, where ordinary application is defined as $t \mathop{\$} u \defeq \sub{(\mathsf{app}\,t)}{\idS, \alert{\transfib{\Tm\;\Gamma}{[\idS]_{\Ty}^{-1}}{\color{black}t}}}$.
%
%\begin{alignat*}{3}
%  \left<\blank\right> & : \implicit{\Gamma, A} \Tm\;\Gamma\;A \to \Sub\;\Gamma\;(\Gamma, A) \\
%  \left< t \right>    & \defeq (\idS , t),
%\end{alignat*}
%used to define the ordinal application: $t \mathop{\$} u \defeq [ \left< u \right> ]_{\Tm} (\mathsf{app}\,t)$, 
%can be introduced without any transport, which is $(\idS, \alert{\transfib{\Tm\;\Gamma}{[id]_T^{-1}}{\color{black}t}})$ in its QII definition.
Similarly, the structural rule for substitution on $\mathsf{app}$
\[
  \sub{(\mathsf{app}\;t)}{\sigma \uparrow A} \overset{\Pi\beta^{-1}}{=}
  \mathsf{app}\,\lambda(\sub{(\mathsf{app}\;t)}{\sigma \uparrow A}) \overset{[]\lambda^{-1}}{=}
  \mathsf{app}\,\left(\sub{(\lambda\,(\mathsf{app}\,t))}{\sigma}\right) \overset{\Pi\eta^{-1}}{=}
  \mathsf{app}\,(\sub{t}{\sigma})
\]
%\begin{align*}
%  \sub{(\mathsf{app}\;t)}{\sigma \uparrow A} & = \mathsf{app}\,\lambda(\sub{(\mathsf{app}\;t)}{\sigma \uparrow A}) && \text{by $\Pi\beta^{-1}$} \\
%                                              & = \mathsf{app}\,\left(\sub{(\lambda\,(\mathsf{app}\,t))}{\sigma}\right) && \text{by $[]\lambda^{-1}$} \\
%                                              & = \mathsf{app}\,(\sub{t}{\sigma}) && \text{by $\Pi\eta^{-1}$.}
%\end{align*}
can be derived without transport, since \eqref{eq:def-type-subst-8} is now strict.

\subsection{Adding other type formers} \label{subsec:SC+U+Pi+more}

We can add extensional identity types, a hierarchy of Coquand universes~\cite{Coquand2018}, and a unit type with an eta law, all without any additional difficulty. In particular, all these additions can be done without introducing any transports in the syntax. However, adding an inductive type such as the Booleans does introduce a little bit of friction; let us see why.
We introduce the type $\bool : \implicit{\Gamma}\;\Ty\;\Gamma$ itself, its constructors $\btrue, \bfalse : \implicit{\Gamma}\;\Tm\;\Gamma\;\bool$ and its elimination principle:
%
\begin{alignat*}{3}
  \belim &: \implicit{\Gamma} \; && (P : \Ty\;(\Gamma , \bool)) \to \Tm\;\Gamma\;(\subTy{P}{\instSub{\bfalse}}) \to \Tm\;\Gamma\;(\subTy{P}{\instSub{\btrue}}) \\
  &&& \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad \to (b : \Tm\;\Gamma\;\bool) \to \Tm\;\Gamma\;(\subTy{P}{\instSub{b}})
\end{alignat*}
%
where $\instSub{t} \defeq (\idS, t) : \Sub\;\Gamma\;(\Gamma, A)$ is the substitution that substitutes $t : A$ for the top variable and leaves all other variables in place. We can add the expected computation rules 
%
%\begin{alignat*}{5}
%  \bool\beta_{\bfalse}           & : \implicit{\Gamma, P, f, t}\; && \belim\,P\,f\,t\,\bfalse && =^{\Tm\;\Gamma\;(\subTy{P}{\instSub{\bfalse}})} {} && f \\
%  \bool\beta_{\btrue}           & : \implicit{\Gamma, P, f, t}\; && \belim\,P\,f\,t\,\btrue && =^{\Tm\;\Gamma\;(\subTy{P}{\instSub{\btrue}})} {} && t
%\end{alignat*}
%
as constructors, e.g.\ $ \bool\beta_{\bfalse} : \implicit{\Gamma, P, f, t}\; \belim\,P\,f\,t\,\bfalse = f$, and the structural rule for type substitution as another straightforward clause
$\subTy{\bool}{\sigma} \reduce \bool$,
but when we try to add the structural rule for term substitution applied to the eliminator, we end up with the following
%
\begin{alignat*}{5}
  []\belim & : \implicit{\Gamma, \sigma, P, f, t, b}\; \sub{(\belim\,P\,f\,t\,b)}{\sigma} \\
           & =^{\Tm\,\Gamma}_{\alert{p\,b}} \belim\,(\sub{P}{\sigma^+})\;(\alert{\transfib{\Tm\,\Gamma}{p\,\bfalse}{\textcolor{black}{\sub{f}{\sigma}}}})\;(\alert{\transfib{\Tm\,\Gamma}{p\,\btrue}{\textcolor{black}{\sub{t}{\sigma}}}})\; (\sub{b}{\sigma})
\end{alignat*}
where the proof $p\,x : \subTy{P}{\instSub{\sub{x}{\sigma}} ; \sigma^+} = \subTy{P}{\sigma ; \instSub{x}}$ is needed to line up the types. Even though this is an equation between type substitutions, which we could hope make compute, there is no obvious way to direct the equation, and simply adding it as a reduction leads to confluence problems. Hence, we do not know how to get rid of these transports.

%\LT{%
%\begin{enumerate}
%  \item Discuss the extensional identity type.
%  \item Discuss Coquand universes.
%  \item Discuss the unit type.
%  \item Discuss the Boolean type.
%  % \item Discuss the type of natural numbers.
%\end{enumerate}
%}

\section{The elimination principle and models} \label{sec:models}

We show how to eliminate out of our QIIRT definition of type theory,
use the eliminator to construct a `standard' model,
and compare our QIIRT definition with its QIIT counterpart.

\subsection{The elimination principle} \label{subsec:eliminator}

To eliminate $\Ctx$, $\Ty\,\Gamma$, $\Sub\;\Gamma\;\Delta$, and $\Tm\,\Gamma\,A$, we have to specify \emph{motive} type families
\begin{align*}
  \Ctx^M & : \Ctx \to \Set &
  \Sub^M & : \implicit{\Gamma, \Delta}\,\Ctx^M\;\Gamma \to \Ctx^M\;\Delta \to \Sub\;\Gamma\;\Delta \to \Set \\
  \Ty^M  & : \implicit{\Gamma}\,\Ctx^M\;\Gamma \to \Ty\;\Gamma \to \Set & 
  \Tm^M  & : \implicit{\Gamma, A}\; (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Tm\;\Gamma\;A \to \Set
\end{align*}
to act as the target types for the elimination principle:
\begin{alignat*}{10}
  \elim_{\Ctx} & : (\Gamma : \Ctx)   && \to \Ctx^M\;\Gamma &
  \elim_{\Sub} & : (\sigma : \Sub\;\Gamma\;\Delta) && \to \Sub^M\; && (\elim_{\Ctx}\,\Gamma)\;(\elim_{\Ctx}\;\Delta)\;&&\sigma \\
  \elim_{\Ty}  & : (A : \Ty\;\Gamma) && \to \Ty^M\;(\elim_{\Ctx}\,\Gamma)\;A \quad
               & \elim_{\Tm}  & : (t : \Tm\;\Gamma\;A) && \to \Tm^M\; && (\elim_{\Ctx}\,\Gamma)\;(\elim_{\Ty}\,A)\;&&t.
\end{alignat*}
Each constructor $\cc$ should be interpreted by a corresponding \emph{method} $\cc^M$ indexed by it, e.g.,
\begin{alignat*}{3}
%  \emptyctx_{\Ctx}^M     & :                    && \Ctx^M\;\emptyctx \\
  \blank,_{\Ctx}^M\blank & : \implicit{\Gamma, A}\; && (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Ctx^M\;(\Gamma, A) %\\
%  \UU^M & : \implicit{\dots} && \Ty^M\;\Gamma^M\;\UU \\
%  \emptysub_{\Sub}^M     & : \implicit{\dots}   && \Sub^M\;\Gamma^M\;\emptyctx_{\Ctx}^M\;\cdot \\
%  \blank,_{\Sub}^M\blank & : \implicit{\dots}   && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Gamma^M\;([\sigma^M]^M_{\Ty}\,A^M)\;t \to \Sub^M\;\Gamma^M\;(\Delta^M ,^M_{\Ctx} A^M)\;(\sigma, t) \\
%  \idS^M          & : \implicit{\dots} && \Sub^M\;\Gamma^M\;\Gamma^M\;\idS \\
%  [\blank]^M\blank & : \implicit{\dots} && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)([\sigma]\,t)
\end{alignat*}
and simultaneously defined functions are also interpreted by corresponding functions, e.g.,
\begin{alignat*}{3}
  \blank[\blank]_{\Ty}^M & : \implicit{\Gamma, \Gamma^M,\Delta, \Delta^M, \sigma, A} \; && \Ty^M\;\Delta^M\;A \to \Sub^M\;\Gamma^M\;\Delta^M\;\sigma \to \Ty^M\;\Gamma^M\;(\subTy{A}{\sigma}) %\\
%  [\blank]_{\Tm}^M\blank & : \implicit{\dots} && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Delta^M\;A^M\;t \to \Tm^M\;\Gamma^M\;([\sigma^M]_{\Ty}^M\,A^M)([\sigma]_{\Tm}\,t) %\\
%  \blank\uparrow^M\blank & : \implicit{\dots} \; && (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to (A^M : \Ty^M\Delta^M\;A) \to
%    \Sub^M\;(\Gamma^M, [\sigma^M]_{\Ty}^M\,A^M)\;(\Delta^M, A^M)
\end{alignat*}
subject to the identities corresponding to equality constructors and function clauses, e.g.,
\begin{alignat*}{5}
  [\idS]_{\Ty}^M & : \implicit{\Gamma, \Gamma^M, A, A^M}\; && \subTyM{A^M}{\idS^M} && =^{\Ty^M\,\Gamma^M\,A}\;&& A^M %\\
  %[;]_{\Ty}^M    & : \implicit{\dots}   && [ \sigma^M ;^M \tau^M ]^M_{\Ty} \;A^M && =^{\Ty^M\,\Gamma^M}\; && [\sigma^M]^M_{\Ty}\,([\tau^M]^M_{\Ty}\,A^M) \\
  %[\idS]_{\Tm}^M & : \implicit{\Gamma^M, t, t^M}   && [\idS^M]^M_{\Tm}\;t^M && =^{\lam{A^M}\Tm^M\;\Gamma^M\;A^M\;t}_{\alert{[\idS]^M_{\Ty}}} && \; t^M
\end{alignat*}
%
The elimination principle says that there are functions $\elim_{\Ctx}$, $\elim_{\Sub}$, $\elim_{\Ty}$ and $\elim_{\Tm}$ as soon as motives and methods are given.
When the motive families are constant, we call the principle a \emph{recursion principle} instead.
We refer to \cref{appendix:full-def} and our \Agda development for the full definition of the elimination principle.
%We also have omitted the list of implicitly quantified variables: each variable $A$ implicitly quantified in a constructor $c$ has accordingly an $A$-indexed variable $A^M$ in $c^M$. 
%%
%
%\begin{definition}
%  An \emph{eliminator} for the QIIR definition of type theory is a tuple of motives and methods above.
%  A \emph{recursor} is an eliminator whereas motives are constants over syntaxes.
%\end{definition}
%

\begin{remark}
  To state the methods, we cannot avoid using transports in identities that would need transports in its QIIT definition of a type theory --- for example, we have
  \[
    [\idS]_{\Tm}^M : \implicit{\Gamma, \Gamma^M, t, t^M} \;\subTmM{t^M}{\idS^M} =^{\Tm^M\,\Gamma^M\,\blank\,t}_{\alert{[\idS]^M_{\Ty}}} \; t^M
  \]
  since identities occurring in a method %(e.g.\ $[\idS]_{\Ty}^M$)
  are propositional just like equality constructors in its QIIT definition.
  However, in the elimination principle for the QIIT definition, the situation is even worse, as we in general need yet another layer of transports for the methods to typecheck over the QIIT constructors.

  % : the above identity $[\idS]_{\Ty}^M$ already requires $\alert{\transfib{\Ty^M\;\Gamma^M}{[\idS]_{\Ty}}{\color{black}[\idS^M]_{\Ty}^M\,A^M}}$ to coerce its type $\Ty^M\;\Gamma^M\;([\idS]\,A)$ to $\Ty^M\;\Gamma^M\;A$ to match the index $A$ of $A^M$, which are not needed in our QIIR definition.
%That is, the eliminator for the QIIR definition requires fewer transports than its QII counterpart.
\end{remark}

The elimination principle computes by recursively interpreting each constructor using the corresponding method. For example, we have
\begin{alignat*}{5}
%  \elim_{\Ctx}\;\emptyctx   & \reduce \emptyctx_{\Ctx}                                    && : \Ctx^M\;\emptyctx  \\
  \elim_{\Ctx}\;(\Gamma, A) & \reduce (\elim_{\Ctx}\,\Gamma),_{\Ctx}^{M} (\elim_{\Ty}\,A) . && %\\
%  \elim_{\Ty}\;\UU          & \reduce \UU^M && :\Ty^M\;\Gamma^M\;\UU \\
%  \elim_{\Sub}\;\emptysub   & \reduce \emptysub^M_{\Sub} &&: \Sub^M\;\Gamma^M\;\emptyctx^M_{\Ctx}\;\emptyctx \\
%                            & \vdots
\end{alignat*}
%
Interestingly, a key difference compared to its QIIT counterpart is that $\subTy{\blank}{\blank}$, $\subTm{\blank}{\blank}$, and $\blank\uparrow\blank$ are functions rather than (formed by) constructors, meaning they cannot be eliminated inductively but instead become propositional identities.
%type substitution $[\blank]\blank$ was a constructor and $[\sigma]\,A$ was eliminated to $[\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A)$; similarly for term substitution.
\begin{restatable}{proposition}{propProvableFunc}\label{prop:provable-function-clauses}
  Given the motives and the methods, we can prove
\begin{alignat*}{5}
  \elim_{\Ty}[] & : \elim_{\Ty}\,(\subTy{A}{\sigma}) && = && \subTyM{(\elim_{\Ty}\,A)}{\elim_{\Sub}\,\sigma} \\
  \elim_{\Tm}[] & : \elim_{\Tm}\,(\subTm{t}{\sigma}) && =^{\Tm^M\,\Gamma^M\,\blank\,t}_{\alert{\elim_{\Ty}[]}} {} && \subTmM{(\elim_{\Tm}\,t)}{\elim_{\Sub}\,\sigma} \\
  \elim_{\Sub}[] & : \elim_{\Sub}(\sigma\uparrow A) && =^{\Sub^M\,(\Gamma^M,^M \blank)\,(\Delta^M, A^M)\,(\sigma \uparrow A)}_{\alert{\elim_{\Ty}[]}} {} && (\elim_{\Sub} \sigma) \uparrow^M (\elim_{\Ty}\,A)
\end{alignat*}
\end{restatable}

These identities are needed for the computation rules where strict identities are used in syntax.
For example, for $\sigma : \Sub\;\Gamma\;\Delta$ and $t : \Tm\;\Gamma\;(\subTy{A}{\sigma})$, we have 
\[
  \elim_{\Sub}(\sigma, t) = (\elim_{\Sub}\,\sigma) ,_{\Sub}^M \alert{\transfib{\Tm^M\;(\elim_{\Ctx}\,\Gamma)}{\elim_{\Ty}[]}{\color{black}(\elim_{\Tm}\,t)}}
\]
where the transport is needed since $\elim_{\Tm}\;t : \Tm^M\;(\elim_{\Ctx}\,\Gamma)\;(\alert{\elim_{\Ty}\;(\subTy{A}{\sigma})})\;t$ but $\blank ,_{\Sub}^M \blank$ expects its second argument to have type $\Tm^M\;(\elim_{\Ctx}\,\Gamma)\;\left(\alert{\subTyM{(\elim_{\Ty}\,A)}{\elim_{\Sub}\,\sigma}}\right)\;t$.

% Consider eliminating a substitution extension $\sigma, t$ for $\sigma : \Sub\;\Gamma\;\Delta$ and $t : \Tm\;\Gamma\;([\sigma]_{\Ty}\,A)$, i.e.\ 
% \[
%   \elim_{\Sub}(\sigma, t) = (\elim_{\Sub}\,\sigma) ,^M_{\Sub} \; \alert{t^M}.
% \]
% In the QIIT definition, $\elim_{\Tm}\,t$ is exactly $t^M$ and has the type
% \begin{equation} \label{eq:elim-subext}
%   \Tm^M\;\Gamma^M\;(\alert{\elim_{\Ty}\;([\sigma]_{\Ty}\,A)})\;t\judgeq
%   \Tm^M\;\Gamma^M\;\left(\alert{[\elim_{\Sub}\,\sigma]^M_{\Ty}\,(\elim_{\Ty}\,A)}\right)\;t
% \end{equation}
% where the RHS of \eqref{eq:elim-subext} is indeed the type of the second argument for $\blank,^M_{\Sub}\blank$.
% In the QIIRT definition, on the contrary, the interpreted type of $\elim_{\Tm}\;t$ is $\elim_{\Ty}\;([\sigma]_{\Ty}\,A)$, which is not strictly equal to the RHS of \eqref{eq:elim-subext}, so $\elim_{\Sub}(\sigma, t)$ has to be
% \[
%   (\elim_{\Sub}\,\sigma) ,_{\Sub}^M \alert{\transfib{\Tm^M\;(\elim_{\Ctx}\,\Gamma)}{\elim_{\Ty}[]}{\color{black}(\elim_{\Tm}\,t)}}
% \]
% transporting $\elim_{\Tm}\,t$ along the identity proof $\elim_{\Ty}[]$.

\begin{remark} \label{re:method-recursion-IIR}
Note that a simultaneously defined function does not need a corresponding interpretation for Dybjer and Setzer's inductive-recursive types~\cite{Dybjer1999}, as their framework targets pre-existing types rather than the inductive types being defined.
\end{remark}

\subsection{The standard model} \label{subsec:std-model}
The standard model, justifying the soundness of our definition, is given by the same motives as those for its QIIT counterpart~\cite[Section~4]{Altenkirch2016a}:
\begin{align*}
  \Ctx^M\;\nameless          & \defeq \Set              & \Sub^M\;\Gamma^M\;\Delta^M\;\nameless & \defeq \Gamma^M \to \Delta^M \\
  \Ty^M\;\Gamma^M\;\nameless & \defeq \Gamma^M \to \Set & \Tm^M\;\Gamma^M\;A^M\;\nameless & \defeq (\gamma : \Gamma^M) \to A^M\;\gamma
\end{align*}
%with the additional methods to its QII counterpart:
%\begin{align*}
%  \blank\uparrow^M\blank & \defeq \lam{\sigma^M\,A^M\,\gamma} (\sigma^M\,(\pi_1\,\gamma) , \pi_2\,\gamma) & \\
%                         & : (\sigma^M : \Gamma^M \to \Delta^M) (A^M : \Delta^M \to \Set) \to \Sigma\;\Gamma^M\;(\lam{\gamma}A^M\,(\sigma^M\,\gamma)) \to \Sigma\,\Delta^M\,A^M \\
%  [\blank]_{\Tm}^M\blank & \defeq \lam{\sigma^M\,t^M\,\gamma} (t^M\,(\sigma^M\,\gamma))  \\
%                         & : (\sigma^M : \Gamma^M \to \Delta^M) (t^M : (\delta : \Delta^M) \to A^M\,\delta) \to (\gamma : \Gamma^M) \to A^M\,(\sigma^M\,\gamma)
%\end{align*}
%where $[\blank]_{\Tm}^M\blank$ is the same as the method for the explicit term substitution $[\blank]^M\blank$.
%
See our \Agda formalisation for details.
Because of the lack of transports in the syntax, many identities in the standard model hold strictly --- more so than in the QIIT standard model, where an extra step~\cite[Lemma~2.3.5]{UFP2013} is needed for reasoning about constant transports.

%In the QIIT counterpart standard model, none of identities hold strictly, since their indices always involve equality constructors.
%E.g., the constructor $[\idS]_{\Ty}$ gives rise to
%$[\idS]^M_{\Ty} : [ \idS^M ]^M_{\Ty}\, A^M =^{\Ty^M\;\Gamma^M}_{\alert{[\idS]_{\Ty}}} A^M$
%and the transport along $[\idS]_{\Ty}$ is needed, because $[ \idS^M ]^M_{\Ty}\, A^M$ is indexed by $[\idS]\,A$ instead of~$A$.
%Accordingly, this identity becomes $\lam{\gamma} A^M\,\gamma =_{\alert{[\idS]}}^{\lam{\nameless}\Gamma^M \to \Set} A^M$ in the standard model and needs an extra step~\cite[Lemma~2.3.5]{UFP2013} for reasoning about the constant transport.
%A workaround to avoid constant transports is to define the notion of recursors independent of eliminators and show that each recursor gives rise to an eliminator. 
%
%In contrast, in our QIIR definition, many identities just hold strictly.
%Consider
%\begin{alignat*}{5}
%  [\idS]^M_{\Ty}                   & : [ \idS^M ]^M_{\Ty}\, A^M && = A^M \\
%  \idS{\mathord{\uparrow}}^M & : \idS^M \uparrow^M A^M    && =^{\lam{B^M}\Sub^M\;(\Gamma^M, A^M)\;\Delta^M\;(\idS \uparrow A)}_{\alert{[\idS]^M}} \idS^M
%\end{alignat*}
%where $[\idS]^M_{\Ty}$ does not need a transport and is just an strict equality $(\lam{\gamma} A^M\,\gamma) \judgeq A^M$ in the model by the $\eta$-law for $\Pi$-types.
%Hence, $\idS{\mathord{\uparrow}}^M$ becomes $(\idS^M \uparrow^M A^M) = \idS^M$.
%By definition, it is a strict equality $(\lam{\gamma}(\pi_1\gamma, \pi_2\gamma)) \judgeq (\lam{\gamma}\gamma)$ by the $\eta$-law for $\Sigma$-types.

\subsection{Comparison with type theory as QIIT} \label{subsec:equivalence}
Our additional rules, enabling further reduction, are derivable in the QIIT definition.
Indeed, the QIIRT definition of type theory is equivalent to its QIIT definition, as we can translate each constructor to its corresponding constructor and vice versa.
For comparison, we add a subscript to constructors and types in the QIIRT and QIIT definitions by $\blank_\IR$ and $\blank_\I$, respectively, and write $(\blank)^{\succ}$ and $(\blank)^{\prec}$ for the translation from the QIIRT definition to its QIIT counterpart and the converse, respectively.
%
The definition of $(\blank)^{\succ}$ is given straightforwardly: each method $c^M_{\IR}$ is given by the corresponding constructor $c_{\I}$ in the QIIT counterpart.
The additional equality constructors are all derivable in the QIIT definition. 

On the other hand, the converse $(\blank)^{\prec}$ has some choices.
Since in the QIIT definition there is only one term substitution $\sub{\blank}{\blank}_{\I}$ and lifting $(\blank)^+_{\I}$, we may choose to translate $\sub{t}{\sigma}_{\I}$ to the recursive form $\subTm{t^{\prec}}{\sigma^{\prec}}$ to carry out some computation, or to the constructor form $\sub{t^{\prec}}{\sigma^{\prec}}_{\IR}$ to stay verbatim.
Either choice is possible, but we need to use \cref{prop:correctness-1,prop:correctness-3} to switch from one to the other whenever suitable.
For example, the equality constructor $\mathsf{concat}_{\IR}$ uses the constructor form, so the method $\mathsf{concat}^M_{\I}$ relies on the identity $\sub{t}{\sigma} = \subTm{t}{\sigma}$ if the recursive form $\subTm{t^{\prec}}{\sigma^{\prec}}$ is chosen for $(\sub{t}{\sigma}_{\I})^{\prec}$.
%
% Going back and forth from one definition to the other gives us the equivalences:
%The equivalence can be summed up as follows:
%
\begin{restatable}{theorem}{equivalence}\label{thm:equivalence}
  Type theory defined as a QIIRT and a QIIT are equivalent, i.e.\ 
  \begin{itemize}
    \item $\eqv{\Ctx_{\IR}}{\Ctx_{\I}}$, 
    \item $\eqv{\left((\Gamma : \Ctx_{\IR})\to\Ty_{\IR}\;\Gamma\right)}{\left((\Gamma : \Ctx_{\I})\to\Ty_{\I}\;\Gamma\right)}$,
    \item $\eqv{\left((\Gamma\;\Delta : \Ctx_{\IR}) \to \Sub_{\IR}\;\Gamma\;\Delta\right)}%
               {\left((\Gamma\;\Delta: \Ctx_{\I}) \to \Sub_{\I}\;\Gamma\;\Delta\right)}$, and 
    \item $\eqv{\left((\Gamma : \Ctx_{\IR}) \to (A : \Ty_{\IR}\;\Gamma) \to \Tm_{\IR}\;\Gamma\;A\right)}
               {\left((\Gamma : \Ctx_{\I}) \to (A : \Ty_{\I}\;\Gamma) \to \Tm_{\I}\;\Gamma\;A\right)}$.
  \end{itemize}
\end{restatable}

\section{Formal implementation} \label{sec:formal-implementation}

Our formal \Agda implementation uses the options \texttt{-{}-with-K} (for uniqueness of identity proofs), \texttt{-{}-exact-split} (to ensure that function clauses are definitional), and \texttt{-{}-rewriting} with \texttt{-{}-local-confluence-check} \cite{Cockx2020,Cockx2021} (to implement definitions by overlapping patterns).
Quotient inductive types are simulated by postulating equations for equality constructors~\cite{Licata2011}. %We do not use \textsc{Cubical Agda}, since it does not support user-defined rewrite rules.

\subparagraph*{Implementing overlapping patterns via rewrite rules}
%The mechanism of defining a function by overlapping patterns is only implemented in an outdated experimental fork of \Agda.
To emulate a function by overlapping patterns, we declare each function clause a rewrite, together with another rewrite to identify the witness as the reflexivity proof $\mathsf{refl}$.
For example, the first few clauses for type substitution (written $[\sigma]_{\Ty}\,A$ rather than $\subTy{A}{\sigma}$ in the formalisation) are defined as
\begin{lstlisting}
postulate
  [_]_      : Sub Γ Δ → Ty Δ → Ty Γ
  [id]      : [ idS ]    A ≡ A
  {-# REWRITE [id]      #-}
  [id]≡refl : [id] {A = A} ≡ refl
  {-# REWRITE [id]=refl #-}
\end{lstlisting}
where \lstinline|[id]≡refl| ensures that \lstinline|[id]| disappears in transports.
We also turn on the option \texttt{-{}-local-confluence-check}  to check local confluence.
%
Overlapping patterns is indeed one of the use cases of user-defined rewrite rules discussed by Cockx~\cite{Cockx2020}.
The caveat, though, is that the termination checking is not imposed, so we need to check termination informally.

%\subparagraph*{Heterogeneous identity}
%In our implementation, some statements are proved differently from our presentation. 
%We have sometimes used John Major equality~\cite{McBride1999} $x \cong y$  for $A, B : \Set$, and $x : A$ and $y : B$, where dependent congruence rule or dependent identity type are needed.
%
%For instance, in \cref{ex:pi-comp-qiirt}, the identity $\pi_2(\sigma ; \tau) = \pi_2(\sigma; (\pi_1 \tau, \pi_2 \tau)$ could be proved by $\apdfunc f \colon (p : x =^A y) \to f\,x =^{P}_{p} f\,y$ and the equality constructor $\pi\eta : \tau = (\pi_1\tau, \pi_2\tau)$, resulting an additional transport to remove later.
%However, as $\subTy{A}{\pi_1(\sigma; \tau)}$ and $\subTy{A}{\pi_1(\sigma; (\pi_1\tau, \pi_2\tau))}$ are strictly equal, the resulting identity is indeed homogeneous.
%Hence, we use the heterogeneous congruence $\mathit{hap}_f\colon (p : x \simeq y) \to f\,x\simeq f\,y$ (by \lstinline|hcong|) and switch back to the ordinary identity type $f\,x = f\, y$ (by \lstinline|≅-to-≡|) as their types match.
% 
%%As shown by McBride, the heterogeneous identity type is equivalent to the ordinary identity type equipped with the principle of uniqueness of identity proofs.
%
%\LT[noinline]{Mention the NbE for SC here?}

\section{Conclusions, and related and future work}\label{sec:conclusion}

We have used QIIRTs and overlapping
patterns to represent type theory in intensional type theory. By defining type
substitution recursively with overlapping patterns, we can avoid most
coercions that appear in terms in other formalisations of type
theory in type theory. That is, we have shown that so-called
`transport hell' can be minimised when formalising type theory in type
theory this way, without hiding details in the formalisation.

%\subsection{Related work}
%\paragraph*{Formalisation of type theory in type theory}

The idea of representing type theory in type theory in a well typed manner goes back to Dybjer~\cite{Dybjer1996} (see also~\cite{Clairambault2014,Castellan2021}). Dybjer's notion of \emph{category with families} can be seen as a semantic structure corresponding closely to the syntax of type theory, and many of the formalisations of type theory in type theory can be understood as capturing the initial category with families via inductive or quotient-inductive types. The equations involved are very similar to the equations described in Martin-L\"of's substitution calculus~\cite{Martin-Lof1992}.

Like us, Danielsson~\cite{Danielsson2006} defines type substitution by a recursive function, while keeping term substitution a constructor. However he does not use quotients, so he also has an explicit term constructor for transporting terms along an inductively defined type of conversion rules, which explicitly contains congruence rules. We are able to remove a lot of the boilerplate by using equality constructors instead. Chapman~\cite{Chapman2009} similarly uses explicit term substitutions and explicit transports along conversion rules, but also uses explicit type substitition in favour of more straightforward foundations.
McBride~\cite{McBride2010} offers another solution which uses an inductive-recursive type to reuse the equality of the metatheory rather than using explicit transports. This works well if the object theory and meta theory are similar, but does not allow to represent equalities that do not hold in the metatheory.

Altenkirch and Kaposi~\cite{Altenkirch2016a} were the first to exploit QIITs to simplify the treatment of computation rules in representations of type theory. % in type theory.
We build heavily on their ideas, but by using Danielsson's~\cite{Danielsson2006} idea of defining type substitution recursively, we are able to remove many explicit transports from the definition, with the result that it is closer to an informal exposition on paper. Such a benefit was also suggested by Kaposi~\cite{Kaposi2023}, who used the simply typed $\lambda$-calculus as an example. Altenkirch and Kaposi have built on the QIIT representation with great success to derive non-trivial results such as normalisation by evaluation~\cite{Altenkirch2017}, and used it to investigate the metatheory of QIITs themselves, together with Kov\'acs~\cite{Kaposi2019}.

In the future, we hope to settle the foundational status of the
combination of quotient types, inductive-inductive types, and the kind
of generalised inductive-recursive types we have considered here,
including overlapping patterns. In fact, our original motivation for
embarking on this work was seeking examples that could give evidence
that such a combination could be useful.
%
Various schemas for inductive types have been developed in recent
years~\cite{Ghani2017,Kaposi2018,Kovacs2023}, and it seems
promising to see if they can be extended to also handle QIIRTs.
Overlapping patterns are
discussed by Cockx~\cite{Cockx2014}, but we would like to integrate it
with such a schema. Eremondi and Kammar~\cite{Eremondi2025} has
recently given a promising direction for overlapping patterns
using sheaf theory.
%\LT{Perhaps also mention that the notion of models might be interesting, but it is out of the scope of this paper.}

%\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}
\bibliography{ref}

\appendix

\section{Complete definitions}\label{appendix:full-def}

\paragraph*{Quotient inductive-inductive-recursive types}
We give the QIIRTs for type theories with a universe of small types, $\Pi$-types, and extensional identity types in one place below.

\subparagraph*{Substitution calculus with a base type $\UU$}
\begin{alignat*}{3}
  \Ctx      & : && \Set                   \\
  \Ty       & : && \Ctx \to \Set          \\
  \Sub      & : && \Ctx \to \Ctx \to \Set \\
  \Tm       & : && (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Set
\end{alignat*}
\begin{alignat*}{5}
  \emptyctx & : && \Ctx \\
  \blank,\blank & : && (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Ctx
\end{alignat*}
\begin{alignat*}{5}
\subTy{\blank}{\blank} & : \implicit{\Gamma, \Delta}\; && \Ty\;\Delta \to \Sub\;\Gamma\;\Delta \to \Ty\;\Gamma \\
  \UU     & : \implicit{\Gamma}\; && \Ty\; \Gamma
\end{alignat*}
\begin{alignat*}{5}
  \emptysub & : \implicit{\Gamma} && \Sub\;\Gamma\;\emptyctx \\
  \blank,\blank & : \implicit{\Gamma, \Delta, A} && (\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Gamma\;(\subTy{A}{\sigma}) \to \Sub\;\Gamma\,(\Delta, A) \\
  \idS & : \implicit{\Gamma} && \Sub\;\Gamma\;\Gamma \\
  \blank;\blank & : \implicit{\Gamma, \Delta, \Theta} && \Sub\;\Gamma\;\Delta \to \Sub\;\Delta\;\Theta \to \Sub\;\Gamma\;\Theta \\
  \pi_1 & : \implicit{\Gamma, \Delta, A}\; && \Sub\;\Gamma\;(\Delta, A) \to \Sub\;\Gamma\;\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A}\; && (\sigma : \Sub\;\Gamma\;(\Delta, A)) \to \Tm\;\Gamma\;(\subTy{A}{\pi_1\;\sigma}) \\
  \sub{\blank}{\blank} & : \implicit{\Gamma,\Delta, A} && \Tm\;\Delta\;A \to (\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Gamma\;(\subTy{A}{\sigma})
\end{alignat*}
\begin{alignat*}{3}
  & \subTy{A}{\idS}           && \reduce A \\
  & \subTy{A}{\sigma ; \tau}  && \reduce \subTy{\subTy{A}{\tau}}{\sigma} \\
  & \subTy{A}{\pi_1(\sigma, t)} && \reduce \subTy{A}{\sigma} \\
  & \subTy{A}{\pi_1(\sigma; \tau)} && \reduce \subTy{\subTy{A}{\pi_1\tau}}{\sigma} \\
  & \subTy{\UU}{\sigma} && \reduce \UU
\end{alignat*}
\begin{alignat*}{5}
  ;\text{-}\mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma}\; && {\sigma ; \idS_{\Delta}} && =^{\Sub\;\Gamma\;\Delta} && {\sigma} \\
  ;\text{-}\mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma}\; && {\idS_{\Gamma} ; \sigma} && =^{\Sub\;\Gamma\;\Delta} && {\sigma} \\
  ;\text{-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, \gamma}\; && (\sigma ; \tau) ; \gamma && =^{\Sub\;\Gamma\;\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t}\; &&\sigma ; (\tau , t) && =^{\Sub\;\Gamma\;(\Theta, A)} &&  (\sigma ; \tau) , \sub{t}{\sigma} \\
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_1(\sigma , t)        && =^{\Sub\;\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t}\; && \pi_2(\sigma , t)        && =^{\Tm\;\Gamma\; A} &&  t \\
  \emptyctx\eta   & : \implicit{\Gamma, \sigma}\; && \sigma                   && =^{\Sub\;\Gamma\;\emptyctx} & \emptysub \\
  \pi\eta         & : \implicit{\Gamma, A, \sigma}\; && \sigma                   && =^{\Sub\;\Gamma\;(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma) \\
  [\idS]         & : \implicit{\Gamma, A, t}\; && {\sub{t}{\idS}}          && =^{\Tm\;\Gamma\;A} && t \\
  [;]            & :\implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t}\; && {\sub{t}{\sigma ; \tau}} && =^{\Tm\;\Gamma\;\subTy{A}{\sigma ; \tau}} && {\sub{(\sub{t}{\tau})}{\sigma}}
\end{alignat*}

\subparagraph*{Universe of small types}
\begin{alignat*}{5}
  \subTm{\blank}{\blank}        & : \implicit{\Gamma, \Delta, A}\; \Tm\;\Delta\;A \to (\sigma : \Sub\;\Gamma\;\Delta) \to  \Tm\;\Gamma\;(\subTy{A}{\sigma}) \\
 \subTm{t}{\idS}                & \reduce t \\
 \subTm{t}{\sigma ; \tau}       & \reduce \subTm{\subTm{t}{\tau}}{\sigma} \\
 \subTm{t}{\pi_1(\sigma, s)}    & \reduce \subTm{t}{\sigma} \\
 \subTm{t}{\pi_1(\sigma; \tau)} & \reduce \subTm{\subTm{t}{\pi_1\tau}}{\sigma} \\
 \subTm{t}{\sigma}              & \reduce \sub{t}{\sigma}, \quad \text{otherwise}
\end{alignat*}
%
\begin{alignat*}{5}
  \El       & : \implicit{\Gamma}\; && \Tm\;\Gamma\;U \to \Ty\;\Gamma
\end{alignat*}
%
\begin{alignat*}{3}
  \subTy{(\El\, u)}{\sigma} \reduce \El\,(\subTm{u}{\sigma})
\end{alignat*}

\subparagraph*{$\Pi$-types}
\begin{alignat*}{5}
  \blank^+ & : \implicit{\Gamma, \Delta, A}\; (\sigma : \Sub\;\Gamma\;\Delta) \to \Sub\;(\Gamma, \subTy{A}{\sigma})\;(\Delta, A) \\
  \sigma^+ & \defeq (\pi_1\idS; \sigma), \pi_2\sigma
\end{alignat*}
\begin{alignat*}{5}
  \blank\uparrow\blank & : \implicit{\Gamma, \Delta}\;(\sigma : \Sub\;\Gamma\;\Delta) (A : \Ty\;\Delta) \to \Sub\;(\Gamma, \subTy{A}{\sigma})\;(\Delta, A) \\
\idS                \uparrow A  & \reduce \idS \\
\sigma ; \tau       \uparrow A  & \reduce (\sigma \uparrow \subTy{A}{\tau}) ; (\tau \uparrow A) \\
\pi_1(\sigma, t)    \uparrow A  & \reduce \sigma \uparrow A \\
\pi_1(\sigma; \tau) \uparrow A  & \reduce (\sigma \uparrow \subTy{A}{\pi_1 \tau}) ; (\pi_1 \tau \uparrow A) \\
\sigma              \uparrow A  & \reduce \sigma^+,\quad  \text{otherwise}
\end{alignat*}
\begin{alignat*}{5}
  \Pi             & : \implicit{\Gamma}\; && (A : \Ty\;\Gamma) \to \Ty\;(\Gamma, A) \to \Ty\;\Gamma \\
  \lambda         &: \implicit{\Gamma, A, B} \; && \Tm\;(\Gamma, A)\;B \to \Tm\;\Gamma(\Pi\,A\,B) \\
  \mathsf{app}    &: \implicit{\Gamma, A, B} \; && \Tm\;\Gamma\;(\Pi\;A\;B) \to \Tm\;(\Gamma, A)\;B
\end{alignat*}
\begin{alignat*}{3}
  & \subTy{(\Pi\,A\,B)}{\sigma}       && {} \reduce {} && \Pi\,(\subTy{A}{\sigma})\,(\subTy{B}{\sigma\uparrow A})
\end{alignat*}
\begin{alignat*}{5}
  []\lambda       & : \implicit{\Gamma, \Delta, \sigma, A, t}\;&& \sub{(\lambda\,t)}{\sigma} && {} =^{\Tm\,\Gamma\,(\subTy{(\Pi\,A\,B)}{\sigma})} {} && \lambda (\sub{t}{\sigma \uparrow A}) \\
  \Pi\beta        & : \implicit{\Gamma, A, B, t}\; && \mathsf{app}\,(\lambda\,t)            && =^{\Tm\,(\Gamma, A)\,B} && t \\
  \Pi\eta         & : \implicit{\Gamma, A, B, t}\; && t                                     && =^{\Tm\,\Gamma\,(\Pi\,A\,B)} && \lambda(\mathsf{app}\,t)
\end{alignat*}

\subparagraph*{Extensional identity types}

\begin{alignat*}{5}
  \mathsf{Id} & : \implicit{\Gamma}\; && (a : \Tm\;\Gamma\;\UU) \to \Tm\;\Gamma\;(\El\,a) \to \Tm\;\Gamma\;(\El\,a) \to \Ty\;\Gamma
\end{alignat*}
\begin{alignat*}{5}
  \subTy{(\mathsf{Id}\;a\;t\;u)}{\sigma} \reduce \mathsf{Id}\,(\subTm{a}{\sigma})\,(\subTm{t}{\sigma})\,(\subTm{u}{\sigma})
\end{alignat*}
\begin{alignat*}{5}
  \mathsf{refl} & : \implicit{\Gamma, a}\;&&(t : \Tm\;\Gamma\;(\El\,a)) \to \Tm\;\Gamma\;(\mathsf{Id}\,a\,t\,t) \\
  []\mathsf{refl} & : \implicit{\Gamma, a, t}\;&& \sub{(\mathsf{refl}\;t)}{\sigma} =^{\Tm\;\Gamma\;(\subTy{(\mathsf{Id}\,a\,t\,t)}{\sigma})} \mathsf{refl}(\sub{t}{\sigma}) \\
  \mathsf{reflect} & : \implicit{\Gamma, a, t, u}\;&& \Tm\;\Gamma\;(\mathsf{Id}\,a\,t\,u) \to t =^{\Tm\;\Gamma\;(\El\,a)} u
\end{alignat*}

\paragraph*{Elimination principles for type theories as QIIRTs}

\subparagraph*{Motives}
\begin{align*}
  \Ctx^M & : \Ctx \to \Set &
  \Sub^M & : \implicit{\Gamma, \Delta}\,\Ctx^M\;\Gamma \to \Ctx^M\;\Delta \to \Sub\;\Gamma\;\Delta \to \Set \\
  \Ty^M  & : \implicit{\Gamma}\,\Ctx^M\;\Gamma \to \Ty\;\Gamma \to \Set &
  \Tm^M  & : \implicit{\Gamma, A}\; (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Tm\;\Gamma\;A \to \Set
\end{align*}

\subparagraph*{Methods}
Note that implicitly quantified variables which would be otherwise declared inside $\implicit{\dots}$ are omitted below.
Each variable $\cc^M$ with the superscript $(\blank)^M$ is always indexed by $\cc$ in addition to other indices.

\subparagraph*{Substitution calculus with a base type $\UU$}
\begin{alignat*}{10}
  \emptyctx_{\Ctx}^M        & : \Ctx^M\;\emptyctx \\
  \blank,_{\Ctx}^M\blank    & : (\Gamma^M : \Ctx^M\;\Gamma) \to \Ty^M\;\Gamma^M\;A \to \Ctx^M\;(\Gamma, A) \\
  \subTyM{\blank}{\blank} & : \Ty^M\;\Delta^M\;A \to \Sub^M\;\Gamma^M\;\Delta^M\;\sigma \to \Ty^M\;\Gamma^M\;(\subTy{A}{\sigma}) \\
  \UU^M                  & : \Ty^M\;\Gamma^M\;\UU \\
  \emptysub_{\Sub}^M     & : \Sub^M\;\Gamma^M\;\emptyctx_{\Ctx}^M\;\cdot \\
  \blank,_{\Sub}^M\blank & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Gamma^M\;(\subTyM{A^M}{\sigma^M})\;t \to \Sub^M\;\Gamma^M\;(\Delta^M ,^M_{\Ctx} A^M)\;(\sigma, t) \\
  \idS^M                 & : \Sub^M\;\Gamma^M\;\Gamma^M\;\idS \\
  \blank;^M\blank        & : (\sigma^M : \Sub^M\;\Gamma\;\Delta^M\;\sigma) \to (\tau^M : \Sub^M\;\Delta^M\;\Theta^M\;\tau) \to \Sub^M\;\Gamma^M\;\Delta^M\;(\sigma ; \tau) \\
  \pi_1^M                & : \Sub^M\;\Gamma^M\;(\Delta^M ,_{\Ctx}^M A^M)\;\sigma \to \Sub^M\;\Gamma^M\;\Delta^M\;(\pi_1\sigma) \\
  \pi_2^M                & : (\sigma^M : \Sub^M\;\Gamma^M\;(\Delta^M ,_{\Ctx}^M A^M)\;\sigma) \to \Tm^M\;\Gamma^M\;(\subTyM{A^M}{\pi_1^M\,\sigma^M})\;(\pi_2\,\sigma) \\
  \subM{\blank}{\blank}  & : \Tm^M\;\Delta^M\;A^M\;t \to (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Gamma^M\;(\subTyM{A^M}{\sigma^M})\;(\sub{t}{\sigma} )
\end{alignat*}

\begin{alignat*}{5}
  [\idS]_{\Ty}^M      & : \subTyM{A^M}{\idS^M}                             && = A^M \\
  [;]_{\Ty}^M         & : \subTyM{A^M}{\sigma^M ;^M \tau^M}                && = \subTyM{\subTyM{A^M}{\tau^M}}{\sigma^M} \\
  [\pi_1,]^M_{\Ty}    & : \subTyM{A^M}{\pi_1^M\,(\sigma^M ,^M_{\Sub} t^M)} && = \subTyM{A^M}{\sigma^M} \\
  [\pi_1;]^M_{\Ty}    & : \subTyM{A^M}{\pi_1^M\,(\sigma^M ;^M \tau^M)}     && = \subTyM{\subTyM{A^M}{\pi_1^M\,\tau^M}}{\sigma^M} \\
  []\UU^M             & : \subTyM{\UU^M}{\sigma^M}                         && = \UU^M
\end{alignat*}


\begin{alignat*}{5}
  ;\text{-}\textsf{idr}^M   & : \sigma^M ;^M \idS^M && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{;\text{-}\mathsf{idr}}} && \sigma^M \\
  ;\text{-}\textsf{idl}^M   & : \idS^M ;^M \sigma^M && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{;\text{-}\mathsf{idl}}} && \sigma^M \\
  ;\text{-}\textsf{assoc}^M & : (\sigma^M ;^M \tau^M) ;^M \gamma^M   && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{;\text{-}\mathsf{assoc}}} && \sigma^M ;^M (\tau^M ;^M \gamma^M) \\
  \mathsf{concat}^M         & : \sigma^M ;^M (\tau^M ,_{\Sub}^M t^M) && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{\mathsf{concat}}} && (\sigma^M ;^M \tau^M) ,_{\Sub}^M \alert{\transfib{}{([;]^M_{\Ty})^{-1}}{\color{black} \subM{t^M}{\sigma^M}}} \\
  \pi_1\beta^M              & : \pi_1^M (\sigma^M ,^M_{\Sub} t^M)    && =^{\Sub^M\,\Gamma^M\,\Delta^M}_{\alert{\pi_1\beta}}      && \sigma^M \\
  \pi_2\beta^M              & : \pi_2^M (\sigma^M ,^M_{\Sub} t^M)    && =^{\Tm^M\,\Gamma^M}_{\alert{[\pi_1,]^M_{\Ty}, \pi_2\beta}}       && t^M \\
  \cdot\eta^M               & : \sigma^M                             && =^{\Sub^M\,\Gamma^M\,\emptyctx^M_{\Ctx}}_{\alert{\cdot\eta}}  && \emptysub_{\Sub}^M \\
  \pi\eta^M                 & : \sigma^M                             && =^{\Sub^M\,\Gamma^M\,(\Delta^M ,^M_{\Ctx} A^M)}_{\alert{\pi\eta}} {} && \pi_1^M \sigma^M ,_{\Sub}^M \pi_2^M \sigma^M \\
  [\idS]^M                  & : \subM{t^M}{\idS}                     && =^{\Tm^M\,\Gamma^M}_{\alert{[\idS]^M_{\Ty}, [\idS]}} && t^M \\
  [;]^M                     & : \subM{t^M}{\sigma^M ;^M \tau^M}      && =^{\Tm^M\,\Gamma^M}_{\alert{[;]^M_{\Ty}, [;]}} && \subM{\subM{t^M}{\tau^M}}{\sigma^M}
\end{alignat*}

\subparagraph*{Universe of small types}
\begin{alignat*}{10}
  \blank[\blank]_{\Tm}^M & : \Tm^M\;\Delta^M\;A^M\;t \to (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Tm^M\;\Gamma^M\;(\subTyM{A^M}{\sigma^M})\,(\subTm{t}{\sigma}) \\
  \El^M                  & : \Tm^M\;\Gamma^M\;\UU^M\;u \to \Ty^M\;\Gamma^M\;(\El\,u)
\end{alignat*}

\begin{alignat*}{5}
  [\idS]_{\Tm}^M      & : \subTmM{t^M}{\idS^M}                             && =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[\idS]^M_{\Ty}}}{} &&  t^M \\
  [;]^M_{\Tm}         & : \subTmM{t^M}{\sigma^M ;^M \tau^M}                && =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[;]^M_{\Ty}}} {} && \subTmM{\left(\subTmM{t^M}{\tau^M}\right)}{\sigma^M}  \\
  [\pi_1,]^M_{\Tm}    & : \subTmM{t^M}{\pi_1^M (\sigma^M ,_{\Sub}^M u^M)}   && =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[\pi_1,]^M_{\Ty}}} && \subTmM{t^M}{\sigma^M} \\
  [\pi_1;]^M_{\Tm}    & : \subTmM{t^M}{\pi_1^M (\sigma^M ;^M \tau^M)}      && =^{\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,t}_{\alert{[\pi_1;]^M_{\Ty}}} && \subTmM{\left(\subTmM{t^M}{\pi_1^M\,\tau^M}\right)}{\sigma^M} \\
  [\emptysub]^M_{\Tm} & : \subTmM{t^M}{\emptysub^M_{\Sub}}                 && = %^{\Tm^M\,\Gamma^M\;([\emptysub_{\Sub}^M]^M_{\Ty}\,A^M)\,([\emptysub]_{\Tm}\,t)}
    \subTmM{t^M}{\emptysub^M_{\Sub}}  &&  \\
    [,]_{\Tm}^M         & : \subTmM{t^M}{\sigma^M ,_{\Sub}^M u^M}          && = %^{\Tm^M\,\Gamma^M\;([\sigma^M ,_{\Sub}^M t ]^M_{\Ty}\,A^M)\,([\sigma , t]_{\Tm}\,t)}
    \subTmM{t^M}{\sigma^M ,_{\Sub}^M u^M} && \\
    [\pi_1\idS]^M_{\Tm} & : \subTmM{t^M}{\pi_1^M\,\idS^M}                    && = %^{\Tm^M\,(\Gamma^M ,^M_{\Ctx} A^M)\,([\pi_1^M\,\idS^M ]^M_{\Ty})\,A^M)\;([\pi_1\idS]_{\Tm}\,t)}{}
    \subTmM{t^M}{\pi_1^M\,\idS^M} && \\
    [\pi_1\pi_1]^M_{\Tm}& : \subTmM{t^M}{\pi_1^M\,(\pi_1^M\,\sigma^M)}       && = %^{\Tm^M\,\Gamma^M\,([\pi_1^M\,(\pi_1^1\,\sigma^M)]^M_{\Ty}\,A)\;([\pi_1(\pi_1\,\sigma)]_{\Tm}\,t)}
                      \subTmM{t^M}{\pi_1^M\,(\pi_1^M\,\sigma^M)} &&
\end{alignat*}

\begin{alignat*}{5}
  []\El^M & : \subTyM{(\El^M\;u^M)}{\sigma^M} && =^{\Ty^M\,\Gamma^M\,(\El\,u)} {} && \El^M\,(\alert{\transfib{}{[]\UU^M}{\color{black}\subTmM{u^M}{\sigma^M}}}
\end{alignat*}



\subparagraph*{$\Pi$-types}
\begin{alignat*}{5}
  (\blank)^{+M} & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) \to \Sub^M\;(\Gamma^M ,_{\Ctx}^M (\subTyM{A^M}{\sigma^M}))\;(\Delta^M ,_{\Ctx}^M A^M)\;(\sigma^+) \\
  (\sigma^M)^{+M} & \defeq (\pi_1^M \idS^M ;^M \sigma^M) ,_{\Sub}^M \alert{\transfib{\Tm^M\;\Gamma^M\;\blank\;\pi_2\idS}{([;]_{\Ty}^M)^{-1}}{\color{black}\pi_2^M \idS^M}}
\end{alignat*}

\begin{alignat*}{10}
  \blank\uparrow^M\blank & : (\sigma^M : \Sub^M\;\Gamma^M\;\Delta^M\;\sigma) (A^M : \Ty^M\Delta^M\;A) \to \Sub^M\;(\Gamma^M,_{\Ctx}^M (\subTyM{A^M}{\sigma^M}))\;(\Delta^M,_{\Ctx}^M A^M)\;(\sigma \uparrow A) \\
  \Pi^M                  & : (A^M : \Ty^M\;\Gamma^M\;A) \to \Ty^M\;(\Gamma^M ,_{\Ctx}^M A^M)\;B \to \Ty^M\;\Gamma^M\;(\Pi\,A\,B)  \\
  \lambda^M              & : \Tm^M\;(\Gamma^M ,_{\Ctx}^M A^M)\;B^M\;t \to \Tm^M\;\Gamma^M\;(\Pi^M\;A^M\;B^M)\;(\lambda\,t) \\
  \mathsf{app}^M         & : \Tm^M\;\Gamma^M\;(\Pi^M\,A^M\,B^M)\;t \to \Tm^M\;(\Gamma^M ,_{\Ctx}^M A^M)\;B^M\;(\mathsf{app}\,t)
\end{alignat*}


\begin{alignat*}{5}
  \idS\mathord{\uparrow}^M      & : \idS^M              && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\idS}_{\alert{[\idS]^M_{\Ty}}} {} && \idS^M \\
  \mathord{;\uparrow}^M         & : (\sigma^M ; \tau^M) && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\nameless}_{\alert{[;]^M_{\Ty}}} \\
                                &&& (\sigma^M \uparrow^M \subTyM{A^M}{\tau^M}) ;^M (\tau^M \uparrow^M A^M)  \\
  \mathord{\pi_1,\uparrow}^M    & : \pi_1^M(\sigma^M ,^M_{\Sub} t^M) && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\nameless}_{\alert{[\pi_1,]^M_{\Ty}}}            {} && \sigma^M \uparrow^M  A^M \\
  \mathord{\pi_1;\uparrow}^M    & : \pi_1^M(\sigma^M ;^M \tau^M)     && \uparrow^M A^M  =^{\lam{B^M} \Sub^M\,(\Gamma^M ,_{\Ctx}^M B^M)\,(\Gamma^M ,_{\Ctx}^M A^M)\;\nameless}_{\alert{[\pi_1;]^M_{\Ty}}} {} \\
                                &&& (\sigma^M \uparrow^M  \subTyM{A^M}{\pi_1^M\tau^M})\,;^M\, (\pi_1^M\tau^M \uparrow^M A^M) \\
  \mathord{\emptysub^M_{\Sub}\uparrow}^M & : \emptysub^M_{\Sub} && \uparrow^M A^M = (\emptysub^M_{\Sub})^{+M} \\
  ,\mathord{\uparrow}^M & : (\sigma^M ,_{\Sub}^M t^M)  && \uparrow^M A^M = (\sigma^M ,_{\Sub}^M t^M)^{+M} \\
  \mathord{\pi_1\idS\uparrow}^M & : (\pi_1^M\,\idS^M) && \uparrow^M A^M = (\pi_1^M\,\idS^M)^{+M} \\
  \mathord{\pi_1\pi_1\uparrow}^M & : (\pi_1^M\,(\pi_1^M\,\sigma^M)) && \uparrow^M A^M = (\pi_1^M\,(\pi_1^M\,\sigma^M))^{+M}
\end{alignat*}

\begin{alignat*}{5}
  []\Pi^M         & : \subTyM{(\Pi^M\;A^M\;B^M)}{\sigma^M}  && =^{\Ty^M\,\Gamma^M\,\left(\subTy{(\Pi\,A\,B)}{\sigma}\right)} {} && \Pi^M\;(\subTyM{A^M}{\sigma^M})\;(\subTyM{B^M}{\sigma^M \uparrow^M A^M}) \\
  []\lambda^M     & : \subM{(\lambda^M\;t^M)}{\sigma^M}     && =^{\Tm^M\,\Gamma^M}_{\alert{[]\Pi^M, []\lambda}} {} && \lambda^M\;(\subM{t^M}{\sigma^M \uparrow^M A^M}) \\
  \Pi\beta^M      & : \mathsf{app}^M\;(\lambda^M\;t^M)      && =^{\Tm^M\,(\Gamma^M,_{\Ctx}^M A^M)\,B^M}_{\alert{\Pi\beta}}   {} && t^M  \\
  \Pi\eta^M       & : t^M                                   && =^{\Tm^M\,\Gamma^M\,(\Pi\,A^M\,B^M)}_{\alert{\Pi\eta}}        {} && \lambda^M\;(\mathsf{app}^M\;t^M)
\end{alignat*}

\subparagraph*{Extensional identity types}
\begin{alignat*}{10}
  \mathsf{Id}^M          & : (a^M : \Tm^M\;\Gamma^M\;\UU^M\;a) \to \Tm^M\;\Gamma^M\;(\El^M\,a^M)\;t \to \Tm^M\;\Gamma^M\;(\El^M\,a^M)\;u \to \Ty^M\;\Gamma^M\;(\mathsf{Id}\;a\;t\;u)  \\
  \mathsf{refl}^M        & : (t^M : \Tm^M\;\Gamma^M\;(\El^M\,a^M)\;t) \to \Tm^M\;\Gamma^M\;(\mathsf{Id}^M\;a^M\;t^M\;t^M)\;(\mathsf{refl}\;t) 
\end{alignat*}

\begin{alignat*}{5}
  []\mathsf{Id}^M    :{} & \subTyM{(\mathsf{Id}^M\;a^M\;t^M\;u^M)}{\sigma^M} =^{\Ty^M\,\Gamma^M\,(\subTy{(\mathsf{Id}\,a\,t\,u)}{\sigma})} \\
                         & \mathsf{Id}^M\; (\transfib{}{[]\UU^M}{\subTmM{a^M}{\sigma^M}})\;
                         (\transfib{}{[]\El^M}{\subTmM{t^M}{\sigma^M}})\;
                         (\transfib{}{[]\El^M}{\subTmM{u^M}{\sigma^M}}) \\
  []\mathsf{refl}    :{} & \subTm{(\mathsf{refl}^M\;t^M)}{\sigma^M} =^{\Tm^M\;\Gamma^M}_{\alert{[]\mathsf{Id}^M, []\mathsf{refl}}} {} \mathsf{refl}^M\;(\transfib{%\lam{A^M}\Tm^M\,\Gamma^M\,A^M\,\nameless
                         }{[]\El^M}{\subTmM{t^M}{\sigma^M]^M}}) \\
  \mathsf{reflect}^M :{} & \Tm^M\;\Gamma^M\;(\mathsf{Id}^M\;a^M\;t^M\;u^M)\;p \to t^M =^{\Tm^M\;\Gamma^M\;A^M}_{\alert{\mathsf{reflect}\;p}} u^M
\end{alignat*}


\section{Omitted proofs}\label{appendix:proofs}

\propConfluenceTwo*
\begin{proof}
  Termination is once again clear, since all recursion is structural.
  In addition to previous cases in the proof of \cref{prop:local-confluence-1}, consider terms
  \[
    \subTy{(\El\,u)}{\idS}, \qquad \subTy{(\El\,u)}{\sigma;\tau}, \qquad \subTy{(\El\,u)}{\pi_1(\sigma, t)}, \qquad\text{and}\qquad \subTy{(\El\,u)}{\pi_1(\sigma; \tau)}
  \]
  which reduce to the following terms
  \[
    \El\,u, \qquad \El\,(\subTm{\subTm{u}{\tau}}{\sigma}), \qquad \El\,(\subTm{u}{\sigma}), \qquad\text{and}\qquad
    \El\,(\subTm{\subTm{u}{\pi_1\tau}}{\sigma})
  \]
  respectively, no matter which function clause of $\subTy{\blank}{\blank}$ is used.
  Therefore, type substitution is locally confluent.
\end{proof}

\propCorrectness*
\begin{proof}
  We show this statement by induction on $\sigma$. Since we are proving a propositional equality, and we are assuming UIP, all equality constructors are automatically respected, so we only need to worry about the point constructors.
  \begin{enumerate}
    \item For the identity substitution $\idS$, we have $\sub{t}{\idS} = t \judgeq \subTm{t}{\idS}$ by definition.
    \item For a composite substitution $\sigma; \tau$, we have
      \begin{align*}
        \sub{t}{\sigma;\tau} & = \sub{(\sub{t}{\tau})}{\sigma}            && \text{by $[;]t$} \\
%                       & = [\sigma]\,([\tau]_{\Tm}\,t)       && \text{by the induction hypothesis $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                       & = \subTm{(\subTm{t}{\tau})}{\sigma} && \text{by the induction hypothesis (twice)} \\ %$[\sigma]u = [\sigma]_{\Tm}\,u$ for any $u$} \\
                       & \judgeq \subTm{t}{\sigma;\tau} && \text{by definition.}
      \end{align*}
    \item For $\pi_1(\sigma, s)$, we have
      \begin{align*}
        \sub{t}{\pi_1(\sigma, s)} & = \sub{t}{\sigma}               && \text{by $\pi_1\beta$} \\
                            & = \subTm{t}{\sigma}       && \text{by the induction hypothesis} \\ % $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                            & \judgeq \subTm{t}{\pi_1(\sigma, s)} && \text{by definition.}
      \end{align*}
    %\item For $\pi_1(\sigma; \tau)$, it is proved similarly as the previous case.
    \item For the remaining cases, $\subTm{t}{\sigma}$ is equal to $\sub{t}{\sigma}$ strictly.
  \end{enumerate}
  Hence, we conclude that $\sub{t}{\sigma}$ is propositionally equal to $\subTm{t}{\sigma}$.
\end{proof}

\propCoherence*
\begin{proof}
  For term substitution, the claim follows by \cref{prop:correctness-1}: if
  $\cc : \sigma = \tau$ then
  \begin{align*}
    \subTm{t}{\sigma} & = \sub{t}{\sigma} && \text{by \cref{prop:correctness-1}} \\
                      & = \sub{t}{\tau} && \text{by congruence and $\cc$} \\
                      & = \subTm{t}{\tau} && \text{by \cref{prop:correctness-1}}
  \end{align*}
  For type substitution, by \cref{re:coherence-proof}, we only have to consider the following cases
  \begin{align*}
    \subTy{A}{\sigma; (\tau, t)}    & = \subTy{A}{(\sigma;\tau), \sub{t}{\sigma}},
                                     & \subTy{A}{\sigma}               & = \subTy{A}{\emptyctx},
                                     & \subTy{A}{\sigma}               & = \subTy{A}{\pi_1\sigma, \pi_2\sigma}
  \end{align*}
  while other cases hold strictly.
  Again, for each case, we prove them by induction on $A$ and consider the case $A \defeq \El\,u$ only which is added to the definition of $[\blank]_{\Ty}\blank$ in this section. 
  However, all cases follow easily from \cref{prop:correctness-1}.
  For example, consider the first case:
  \begin{align*}
    \subTy{(\El\,u)}{\sigma; (\tau, t)} & \judgeq \El\,(\subTm{u}{\sigma; (\tau, t)}) && \text{by \eqref{eq:def-type-subst-7}} \\
%                                      & = \El( \sub{u}{\sigma; (\tau, t)})            && \text{by \cref{prop:correctness-1}} \\
%                                      & = \El( \sub{u}{\sigma; \tau, \sub{t}{\sigma}})     && \text{by $\mathsf{concat}$} \\
%                                      & = \El( \subTm{u}{\sigma; \tau, \sub{t}{\sigma}}) && \text{by \cref{prop:correctness-1}} \\
                                      & = \El\,( \subTm{u}{\sigma; \tau, \sub{t}{\sigma}}) && \text{by coherence of $\subTm{\blank}{\blank}$} \\
                                      & \judgeq \subTy{\left(\El\,u\right)}{\sigma; \tau, \sub{t}{\sigma}} && \text{by \eqref{eq:def-type-subst-7} }
  \end{align*}
  The other two cases are dealt with in exactly the same way.
\end{proof}

\propConfluenceThree*
\begin{proof}
  In addition to previous cases in \cref{prop:local-confluence-1,prop:local-confluence-2}, consider
  \begin{align*}
    \subTy{(\Pi\;A\;B)}{\idS} && \subTy{(\Pi\;A\;B)}{\sigma;\tau} && \subTy{(\Pi\;A\;B)}{\pi_1(\sigma, t)} && \subTy{(\Pi\;A\;B)}{\pi_1(\sigma; \tau)}.
  \end{align*}
  Each of them reduces to the following terms after applying clauses of $\blank\uparrow\blank$ and $\subTy{\blank}{\blank}$:
  \begin{align*}
    & \Pi\;A\;B                && \Pi\;(\subTy{(\subTy{A}{\tau})}{\sigma})\;(\subTy{\subTy{B}{\tau \uparrow A}}{\sigma \uparrow \sub{A}{\tau}}) \\
    & \Pi\;([\sigma]_{\Ty}\;A)([\sigma \uparrow A]_{\Ty}\;B) && \Pi\;(\subTy{(\subTy{A}{\pi_1\tau})}{\sigma})\;(\subTy{\subTy{B}{\sigma \uparrow (\subTy{A}{\pi_1\tau})}}{\pi_1 \tau \uparrow A})
  \end{align*}
  respectively.
  Hence, the type substitution $\subTy{\blank}{\blank}$ is locally confluent.
\end{proof}

\lemIdentities*
\begin{proof}
  By the identity law $\mathsf{idr}$ and the $\eta$-law $\pi\eta$, we have
  \[
    \idS^+ \judgeq ((\pi_1\idS; \idS), \pi_2 \idS) = (\pi_1\idS, \pi_2 \idS) = \idS.
  \]
  For commuting with composition, first note that $\pi_1(\sigma; \tau) = \sigma; \pi_1 \tau$ holds similarly to \eqref{eq:pi2-comp-proof} and, in particular, we have $\pi_1 \idS ; \sigma = \sigma^+; \pi_1\idS$.
  Also note that $\pi_2\idS = \sub{\pi_2\idS}{\sigma^+}$ by \eqref{eq:pi2-comp-proof}.
  Now
  \begin{align*}
    (\sigma; \tau)^+ & \judgeq (\pi_1\idS; (\sigma; \tau)), \pi_2 \idS && \text{by definition} \\
                     & = ((\pi_1\idS; \sigma); \tau), \pi_2 \idS       && \text{by ;-$\mathsf{assoc}$}\\
                     & = ((\sigma^+; \pi_1\idS); \tau), \sub{\pi_2 \idS}{\sigma^+} && \text{by $\pi_1\idS; \sigma = \sigma^+ ; \pi_1\idS$ and $\pi_2\idS = \sub{\pi_2\idS}{\sigma^+}$}\\
                     & = (\sigma^+; (\pi_1\idS; \tau)) , \sub{\pi_2\idS}{\sigma^+}  && \text{by ;-$\mathsf{assoc}$} \\
                     & = \sigma^+; ((\pi_1\idS ; \tau) , \pi_2\idS) && \text{by $\mathsf{concat}^{-1}$} \\
                     & \judgeq \sigma^+; \tau^+ && \text{by definition}
  \end{align*}
  as required.
\end{proof}

\propCorrectnessTwo*
\begin{proof}
  We prove the statement by induction on $\sigma$ with \cref{lem:lifting}.
  Every case follows from equational reasoning straightforwardly.
  For example, if $\sigma$ is a composite $\sigma;\tau$, we have
  \begin{align*}
    (\sigma;\tau) \uparrow A & \judgeq (\sigma \uparrow \sub{A}{\tau});(\tau \uparrow A) && \text{by definition} \\
                             & = \sigma^+;\tau^+                                     && \text{by induction hypothesis} \\ 
                             & = (\sigma;\tau)^+                                     && \text{by \cref{lem:lifting}.} 
  \end{align*}
  Other cases follow similarly.
\end{proof}

\propCorrectnessThree*
\begin{proof}
  Again by induction on $\sigma$.
\end{proof}

\propCoherenceUparrow*
\begin{proof}
  These two identities follow from \cref{prop:correctness-2,prop:correctness-3}.
\end{proof}

\coherenceTel*
\begin{proof}
  The proposition is easy to prove for the following equality
  constructors, since the lifting and substitution operations compute
  independently for these cases:
  \[
    \mathsf{idr} : \sigma;\idS = \sigma, \quad
    \mathsf{idl} : \idS;\sigma = \sigma, \quad\text{and}\quad
    \textnormal{;-}\mathsf{assoc} : (\sigma;\tau);\gamma = \sigma; (\tau; \gamma),
  \]
  Take $\mathsf{idr}$ as an example, we can see 
  \begin{align*}
    (\sigma; \idS) \upuparrows \Xi & \judgeq (\sigma \upuparrows \subTel{\Xi}{\idS}) ; (\idS \upuparrows \Xi) \\
                                   & \judgeq (\sigma \upuparrows \Xi) ; \idS \\
                                   & = \sigma \upuparrows \Xi
  \end{align*}
  where the last identity follows from $\mathsf{idr}:(\sigma \upuparrows \Xi) ; \idS = \sigma \upuparrows \Xi$.

  For other two equality constructors, the arguments follow similarly.

The second set of equality constructors are more involved, as we have to prove the coherence for the lifting and substitution operations altogether mutually:
  %\LT[noinline]{Josh Ko suggests us to follow the proof structure in our formal implementation.}
  For the following equality constructors $\cc : \sigma = \tau$
  \begin{alignat*}{5}
    \pi_1\beta    & : \pi_1(\sigma, t)  && = \sigma \qquad\qquad & \mathsf{concat} & : \sigma; (\tau, t) && = (\sigma;\tau), \sub{t}{\sigma} \\
    \emptyctx\eta & : \sigma            && = \emptyctx & \pi\eta & : \sigma && = \pi_1\sigma, \pi_2\sigma
  \end{alignat*}
   the identities
  \begin{align*}
  \subTel{\Xi}{\sigma} & = \subTel{\Xi}{\tau}
                         & \subTy{A}{\sigma \upuparrows \Xi} & =^{\lam{\gamma}\Ty\;(\Gamma \dplus \subTel{\Xi}{\gamma})}_{\alert{\cc}} \subTy{A}{\tau \upuparrows \Xi} \\
  \sigma \upuparrows \Xi & =^{\lam{\gamma}\Sub\;(\Gamma\dplus \subTel{\Xi}{\gamma})\;(\Delta\dplus\Xi)}_{\alert{\cc}} \tau \upuparrows \Xi
%    &
%  [\sigma \upuparrows \Xi ]_{\Tm}\,t & =^{\lam{\gamma}\Tm\;(\Gamma \dplus [\gamma]_{\Tel}\Xi)\;([\gamma \upuparrows \Xi]_{\Ty} A)}_{\alert{p}} [\tau \upuparrows \Xi ]_{\Tm}\,t
  \end{align*}
  hold for any telescope $\Xi : \Tel\,\Delta$ and type $A : \Ty\;(\Delta\dplus \Xi)$.
  We show the statement for $\pi_1\beta: \pi_1(\sigma, t) = t$ and the other three cases follow similarly.

  First, we prove the coherence for $\subTy{A}{\blank}$ by induction on $A$ and the coherence for the other two identities $\subTel{\Xi}{\blank}$ and $\blank \upuparrows \Xi$ by induction on $\Xi$.
  \begin{enumerate}
    \item Consider the following cases for $\subTy{A}{\sigma\upuparrows\Xi} = \subTy{A}{\tau \upuparrows \xi}$ by induction on $A$.
      \begin{description}
        \item[$A$ is $\UU$:] By definition
          \[
            \subTy{\UU_{\Delta\dplus \Xi}}{\pi_1(\sigma, t) \upuparrows \Xi} \judgeq \UU_{\Gamma \dplus [\pi_1(\sigma, t)]_{\Tel}\,\Xi} \quad\text{and}\quad \subTy{\UU_{\Delta\dplus \Xi}}{\sigma\upuparrows \Xi} \judgeq \UU_{\Gamma \dplus [\sigma]_{\Tel}\,\Xi}
          \]
          By assumption, $\subTel{\Xi}{\pi_1(\sigma, t)} = \subTel{\Xi}{\sigma}$ and by congruence $\Gamma \dplus \subTel{\Xi}{\pi_1(\sigma, t)} = \Gamma \dplus \subTel{\Xi}{\sigma}$ holds.
          Then, $\UU_{\Gamma \dplus \subTel{\Xi}{\pi_1(\sigma, t)}} \simeq \UU_{\Gamma \dplus \subTel{\Xi}{\sigma}}$ holds by congruence for $\UU$.

        \item[$A$ is $\El\,u$:]
          Similar to \cref{prop:coherence-2}, we use \cref{prop:correctness-3} and the congruence law for $\sub{u}{\blank}$ to derive the desired identity.

        \item[$A$ is $\Pi\,B\,C$:]
          Note that one of the induction hypothesises is
          \[
            \subTy{C}{\pi_1(\sigma, t) \upuparrows \Xi} = \subTy{C}{\sigma \upuparrows \Xi}
          \]
          for \emph{arbitrary} $\Xi$, so we can apply the induction hypothesis to $B$ and $C$ below:
          \begin{align*}
            & \subTy{(\Pi\,B\,C)}{\pi_1(\sigma, t) \upuparrows \Xi} \\
            \judgeq{} & \Pi\,(\subTy{B}{\pi_1(\sigma, t) \upuparrows \Xi})\,(\subTy{C}{\pi_1(\sigma, t) \upuparrows \Xi \uparrow B}) && \text{by the definition of $\subTy{(\Pi\,B\,C)}{\blank}$} \\
            \judgeq{} & \Pi\,(\subTy{B}{\pi_1(\sigma, t) \upuparrows \Xi})\,(\sub{C}{\pi_1(\sigma, t) \upuparrows (\Xi, B)}) && \text{by the definition of $\upuparrows$} \\
            ={}       & \Pi\,(\subTy{B}{\sigma \upuparrows \Xi})\,(\sub{C}{\sigma \upuparrows (\Xi, B)}) && \text{by induction hypothesises} \\
            \judgeq{} & \Pi\,(\subTy{B}{\sigma \upuparrows \Xi})\,(\sub{C}{(\sigma \upuparrows \Xi) \uparrow B}) && \text{by the definition of $\upuparrows$} \\
            \judgeq{} & \subTy{(\Pi\,B\,C)}{\sigma\upuparrows \Xi} && \text{by the definition of $\subTy{(\Pi\,B\,C)}{\blank}$.}
          \end{align*}
      \end{description}
    \item By induction on $\Xi$, consider following cases for $\subTel{\Xi}{\pi_1(\sigma, t)} = \subTel{\Xi}{\sigma}$.
      \begin{description}
        \item[$\Xi$ is the empty telescope $\emptytel$:] By definition, $\subTel{\emptytel}{\pi_1(\sigma, t)} \judgeq \emptytel \judgeq \subTel{\emptytel}{\sigma}$.
        \item[$\Xi$ is the telescope extension $\Xi, A$:]
          \begin{align*}
            \subTel{(\Xi, A)}{\pi_1(\sigma, t)} & \judgeq \subTel{\Xi}{\pi_1(\sigma, t)}, \subTy{A}{\pi_1(\sigma, t) \upuparrows \Xi} && \text{by definition} \\
                                                & = \subTel{\Xi}{\sigma}, \subTy{A}{\sigma \upuparrows \Xi} \\
                                                & \judgeq \subTel{(\Xi, A)}{\sigma} && \text{by definition}
          \end{align*}
      \end{description}
    \item By induction on $\Xi$, consider the following cases for $\pi_1(\sigma, t) \upuparrows \Xi = \sigma \upuparrows\,\Xi$.
      \begin{description}
        \item[$\Xi$ is the empty telescope $\emptytel$:] $\pi_1(\sigma, t) \upuparrows \emptytel \judgeq \pi_1(\sigma, t) = \sigma \judgeq \sigma \upuparrows \emptytel$ by definition and the equality constructor.
        \item[$\Xi$ is the telescope extension $\Xi, A$:] 
          \begin{align*}
            \pi_1(\sigma, t) \upuparrows (\Xi, A) & \judgeq (\pi_1(\sigma, t) \upuparrows \Xi) \uparrow A \\
                                                  & =^{} (\pi_1(\sigma, t) \upuparrows \Xi)^{+} \\
                                                  & =^{\lam{\gamma}\Sub\,(\Gamma\dplus\subTel{\Xi}{\gamma}, \subTy{A}{\gamma \upuparrows \Xi})\,(\Delta \dplus \Xi, A)}_{p} (\sigma\upuparrows \Xi)^{+} \\
                                                  & = (\sigma \upuparrows \Xi) \uparrow A \\
                                                  & \judgeq \sigma \upuparrows (\Xi , A)
          \end{align*}
      \end{description}
  \end{enumerate}
\end{proof}

\propProvableFunc*
\begin{proof}
  These properties are proven mutually with the definition of the
  eliminators. The property $\elim_{\Ty}[]$ is proven by induction on the type $A$, while $\elim_{\Tm}[]$ and $\elim_{\Sub}[]$ are proven by induction on the substitution.
\end{proof}

\equivalence*
\begin{proof}
  See our \Agda formalisation for the exact definition of the functions back and forth, and how the roundtrips are identities.
\end{proof}

\end{document}
