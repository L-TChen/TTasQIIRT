
\documentclass[a4paper,UKenglish,numberwithinsect,cleveref,thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}

\title{Type theories as quotient inductive-recursive types}
\author{Liang-Ting Chen\footnote{Corresponding author; authors are listed in alphabetical order.}}{Institute of Information Science, Academia Sinica, Taiwan \and \url{http://l-tchen.github.io}}{ltchen@iis.sinica.edu.tw}{https://orcid.org/0000-0002-3250-1331}{Supported by the National Science and Technology Council of Taiwan under grant NSTC 114-2222-E-001-001-MY3.}
\author{Fredrik Nordvall Forsberg}{Department of Computer and Information Sciences, University of Strathclyde, UK \and \url{https://fredriknf.com}}{fredrik.nordvall-forsberg@strath.ac.uk}{https://orcid.org/0000-0001-6157-9288}{Supported by the Engineering and Physical Sciences Research Council [EP/Y000455/1].}
\author{Tzu-Chun Tsai}{Institute of Information Science, Academia Sinica, Taiwan}{gene0905@icloud.com}{}{Supported by the National Science and Technology Council of Taiwan under grant NSTC 112-2221-E-001-003-MY3.}
\authorrunning{L.-T.~Chen, F.~Nordvall Forsberg, and T.-C.~Tsai}
\Copyright{Liang-Ting Chen, Fredrik Nordvall Forsberg, and Tzu-Chun Tsai}
\ccsdesc[500]{Theory of computation~Type theory}
\keywords{inductive-inductive types, quotient inductive types, inductive-recursive types, substitution calculus, category with families}
\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{The formal development is hosted at the GitHub repository: \url{https://github.com/genetsai95/DTT-QIIRT}.}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional
\acknowledgements{We'd like to thank Hsiang-Shang Ko and Meven Lennon-Bertrand.}%optional

\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{YYY}
\EventNoEds{1}
\EventLongTitle{10th International Conference on Formal Structures for Computation and Deduction (FSCD 2025)}
\EventShortTitle{FSCD 2025}
\EventAcronym{FSCD}
\EventYear{2025}
\EventDate{July 14--20, 2025}
\EventLocation{Birmingham, United Kingdom}
\EventLogo{}
\SeriesVolume{XX}
\ArticleNo{XX}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[obeyFinal,textsize=footnotesize]{todonotes}
\usepackage{manfnt}
\newcommand{\danger}{\marginpar[\hfill\dbend]{\dbend\hfill}}
\newcommand{\LT}[2][]{\todo[inline,author={L-T},caption={},#1]{#2}}
\newcommand{\Gene}[2][]{\todo[inline,author={Gene},caption={},#1]{#2}}
\newcommand{\Fredrik}[2][]{\todo[inline,author={Fred},caption={},#1]{#2}}

\input{macro.tex}


\begin{document}

\maketitle

\begin{abstract}
  Type theory can be defined in a type theory as a quotient inductive-inductive type, but well-typed terms are littered with explicit coercions, i.e.\ \transp's along equality constructors, and proofs need to account for coercions painstakingly alongside the interesting part.
  This mess has been dubbed the `transport hell' but typically suppressed in presentation for clarity, hiding the gap between the intention and the formalisation of type theory in type theory.
  In this paper, we aim for shortening the gap using quotient inductive-inductive-recursive types and definitions by overlapping patterns altogether, reducing the use of \transp's.
  As a case study, we investigate (parallel) substitution calculus and type theory with a universe and $\Pi$-types as quotient inductive-inductive-recursive types and compare ours with quotient inductive-inductive definitions.
\end{abstract}

\section{Introduction} \label{sec:intro}

Metaprogramming and mechanised metatheory in a type-theoretic proof assistant relies on having an internal representation of type theory within type theory itself.
%
In the spirit of type theory, we would like to represent well scoped and well typed terms only --- this also has technical advantages, such as theorem statements not having to deal with impossible cases, or separately having to prove wellformedness lemmas, etc.
%
Doing this effectively seems to require several sophisticated features of the host type theory, most notably advanced inductive definitions.
%
For example, inductive families~\cite{Dybjer1994} can be used to represent the simply typed lambda calculus~\cite{Altenkirch1999}, while some kind of simultaneous definitions such as inductive-recursive~\cite{Dybjer2000} or inductive-inductive~\cite{Nordvall-Forsberg2014} definitions seem to be required for dependent type theory~\cite{Danielsson2006,Chapman2009}.
%
This is not just a matter of the pure strength of the host theory, but also expressivity and convenience: while it is known how to reduce inductive-inductive definitions to inductive families in principle~\cite{Kaposi2020a}, the resulting development would be considerable harder to work with, and most likely would have exhausted the resources of both the proof assistant and its user.

Altenkirch and Kaposi~\cite{Altenkirch2016a} showed that by employing \emph{quotient inductive-inductive types}~\cite{Altenkirch2018}, the internal representation of well typed terms could be significantly simplified, since equations such as $\beta$- and $\eta$-equality can be represented by the identity type thanks to quotient constructors.
%
Yet, there is a general phenomenon, called `transport hell', when working with quotient inductive-inductive types: to make use of equalities in later constructors and when using the eliminator for the type, the equalities need to be transported across.
%
Any method that reduces the friction this introduces seem worth exploring.
%

In this paper, we show that the development can be further streamlined by combining quotient inductive-inductive types and inductive-recursive types.
%
The basic idea, following a suggestion by Kaposi~\cite{Kaposi2023} and a precursor by Danielsson~\cite{Danielsson2006}, is to replace the inductively defined action of a substitution on a type with a recursive definition, which computes.
%
Our development also makes use of another feature not usually found in standard presentations of type theory: recursive pattern matching definitions with overlapping patterns.
%
This is helpful to again avoid transport hell in the form of equations that do not reduce due to the standard translation of pattern matching to case trees.
%
As a result, many equations will hold strictly, and we can avoid the use of transport in the definition of type theory itself and, at least, partially in the proofs of its properties.
\LT{Strict versus definitional?}
%

%However, we found that using quotient inductive-inductive-recursive types alone were not sufficient for a smooth development.
%%
%%Not only do we want the action of substitutions on types to compute definitionally, but we also want as many equations to hold strictly as possible:
%%
%%on the one hand, we want substitutions to distribute over type formers, but on the other hand we want substitutions to satisfy composition and unit laws of the category of context and substitutions up to definitional equality.
%%
%Instead, we also needed to make use of functions defined by overlapping patterns.
%%
%In a proof assistant such as Agda, this can be emulated by Agda's experimental support for rewrite rules, but with an additional proof burden on the user to show (informally) that their use is justified meta-theoretically.
%%
%To get some help with this task by Agda's confluence checker, it is often necessary to needlessly complicate a definition to convince the checker that the proposed rewrite rules are indeed confluent.

%
We emphasise that, following a fine tradition of previous attempts to represent type theory in type theory~\cite{Danielsson2006,Chapman2009,Altenkirch2016a}, we are making use of type-theoretic features that are so far not yet well understood or foundationally well motivated.
Nevertheless, Agda can be convinced to accept our development, using some experimental flags.
Indeed, we also see this paper as a case study to motivate further developments for quotient inductive-inductive-recursive types and overlapping patterns.

\Fredrik{I'm not sure if I have included all points here. I tried to stay more positive re overlapping patterns.}
\LT{Thanks!}


\paragraph*{Contributions}
\begin{itemize}
  \item Exploration of the use of quotient inductive-inductive-recursive types and definitions by overlapping patterns.
    In particular, we give in a type theory:
    \begin{itemize}
      \item a definition of parallel substitution calculus;
      \item a definition of type theory with a universe and $\Pi$-types,
    \end{itemize}
   using quotient inductive-inductive-recursive types and definitions by overlapping patterns to define type substitution and term substitution partially.
  \item Comparison with other definitions using quotient inductive-inductive types.
\end{itemize}


\subsection{Plan of the paper}

\section{Metatheory and formalisation} \label{sec:meta}

\cite{UFP2013}
\LT{
Points to include:
\begin{enumerate}
  \item identity type $x =^{A} y$ for $x, y : A$, dependent identity type, $t =^{P}_{p} u \defeq \transfib{P}{p}{t} =^{P y} u$ for $t : P(x)$ and $u : P(y)$, heterogeneous equality~\cite{McBride1999} in \Agda $x \simeq y$ for $x : A$ and $y : B$
  \item We work with intensional type theory with uniqueness of identity proof and function extensionality (only used for NbE and the standard model for the extensional identity type).
  \item We use Agda to formally implement our definitions with the following options: \texttt{-{}-with-K}, \texttt{-{}-local-confluence-check}, \texttt{-{}-exact-split}, and \texttt{-{}-rewriting} using postulated equations~\cite{Licata2011} to introduce equality constructors for quotient types.
\end{enumerate}}

\LT{The symbol \textdbend indicates a property that is proved informally or checked partially with \Agda (because of postulated quotient inductive types).}
\subsection{Inductive-recursive types}
\cite{Dybjer2003,Dybjer2000,Dybjer1999}
\LT{Introduce abbreviations here}

\LT{Mention that the recursion part of induction-recursion are already not defined by elimination rule.}

\subsection{Definitions by overlapping patterns} \label{sec:meta:overlapping}
\cite{Cockx2014,Altenkirch2016a}
\LT{We use $f\;\vec{x} \reduce \vec{t}$ to indicate a function clause of a definition by overlapping patters.}
\subsection{Quotient inductive(-inductive)-recursive types}
\LT{Give an example of QIRT: join list?}
\subsection{Definitions by rewrite rules}
\cite{Cockx2020,Cockx2021}

Unfortunately, neither general schemata of quotient inductive-inductive-recursive types nor definitions by overlapping patterns have been developed or implemented in existing proof assistants.

\paragraph*{Local confluence}
\LT{Explain the notion of critical pair; local peak}
\paragraph*{Strong normalisation}
\cite{Abel2002}
\LT{Explain how these two conditions imply global confluence}

\section{Type theories as quotient inductive-inductive-recursive types} \label{sec:QIIRTs}
\LT{
\begin{enumerate}
  \item Goal: remove transports in the definition so that less transports during reasoning.
  \item Motivation: make type substitution definitional so that we do not have to apply transport along structural rules for types explicitly.
  \item Develop the quotient inductive-inductive-recursive definition of type theory step by step (which needs to be locally confluent and terminating).
    \begin{enumerate}
      \item parallel substitution: type substitution
      \item the type of elements of $A$: term substitution needs to be split into two definitional substitution and explicit term substitution to maintain local confluence.
      \item $\Pi$-type: because of the substitution lifting $\sigma^+ \defeq (\pi_1\idS, \pi_2\idS)$ is used we need to introduce a definitional lifting to maintain local confluence.
        We prefer categorical combinator and avoid using $\left< t \right>$ in the definition, which would introduce transports in the definition.
      \item Other type formers can be introduced as usual (as long as we use categorical combinators).
    \end{enumerate}
\end{enumerate}
}

We begin with the definition of (parallel) substitution calculus~\cite{Martin-Lof1992} as a QIIT, emphasising how the use of transports in its very definition complicates formal reasoning.
Then we introduce its QIIRT counterpart (\cref{subsec:SC-QIIRT}) which shortens the gap between formal and informal reasoning.
Then, we develop a type theory with a universe (\cref{subsec:SC+U}), $\Pi$-types (\cref{subsec:SC+U+Pi}), and other type formers (\cref{subsec:SC+U+Pi+more}).

\subsection{Substitution calculus as a quotient inductive-inductive type} \label{subsec:SC-QIIT}

Substitution calculus has a type $\Ctx$ of contexts, a type $\Ty\,\Gamma$ of types under some context $\Gamma : \Ctx$, a type $\Sub\;\Gamma\;\Delta$ of substitutions from the domain $\Gamma$ and the codomain $\Delta$, and a type $\Tm\;\Gamma\;A$ of terms under a context $\Gamma$ and its type $A$. 
These types amount to the following types indexed by types being defined (hence inductive-inductive):
\begin{alignat*}{3}
  \Ctx   & : \Set                   \\
  \Ty    & : \Ctx \to \Set          \\
  \Sub   & : \Ctx \to \Ctx \to \Set \\
  \Tm    & : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Set
\end{alignat*}
The type $\Ctx$ has two constructors $\emptyctx$ for the empty context and $\blank,\blank$ for context extension:
\begin{alignat*}{3}
  \emptyctx & : \Ctx \\
  \blank,\blank & : (\Gamma : \Ctx) \to \Ty\;\Gamma \to \Ctx
\end{alignat*}
where the context extension $\blank,\blank$ requires that $\Ty$ is indexed by a context $\Gamma$, underscoring the nature of inductive-inductive definition.

Type substitution takes a substitution $\sigma : \Sub\;\Gamma\;\Delta$ and an inhabitant $A : \Ty\;\Delta$ to form a type under $\Gamma$, so type substitution as a constructor has the type
\begin{alignat*}{3}
  [\blank]\blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma
\end{alignat*}
where $\Gamma$ and $\Delta$ (coloured {\color{gray}grey}) above are quantified implicitly.

If we were defining the notion of cwfs, type substitution would be enough for $\Ty$.
For our inductive definition (i.e.\ the initial cwf), however, we need a base case in $\Ty\;\Gamma$, otherwise the type $\Ty$ would be empty as well as other types.
Hence another constructor is introduced:
\begin{alignat*}{3}
  \UU & : \implicit{\Gamma} & \Ty\, \Gamma.
\end{alignat*}
For now, $\UU$ serves as a constant, but we will reuse $\UU$ for the type of small types later.

Substitutions from $\Gamma$ to $\Delta$ can be understood intuitively as lists of terms of type $A$ under the context $\Gamma$ for each $A$ in $\Delta$, so we have the empty substitution $\emptysub$ and substitution extensions $\sigma, t$ by some term~$t$:
\begin{alignat*}{3}
  \emptysub & : \implicit{\Gamma}\;\Sub\;\Gamma\;\emptyctx \\
  \blank,\blank & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\;\Gamma\;([ \sigma ]\, A) \to \Sub\;\Gamma\;(\Delta, A),
\end{alignat*}
Note that type substitution $[\sigma]\;A$ is needed, because $A$ is well-formed under the context $\Delta$ instead of $\Gamma$.
As substitution calculus is the initial cwf with a constant type $\UU$, substitutions also have the identity substitution $\idS$ and composition $\blank;\blank$
\begin{alignat*}{3}
  \idS & : \implicit{\Gamma}\;\Sub\;\Gamma\;\Gamma \\
  \blank;\blank & : \implicit{\Gamma, \Delta, \Theta}\;\Sub\;\Gamma\;\Delta \to \Sub\;\Delta\;\Theta \to \Sub\;\Gamma\;\Theta
\end{alignat*}
satisfying certain laws (introduced later).
Context comprehension is given by projections from \emph{non-empty} substitutions $\sigma : \Sub\;\Gamma\;(\Delta, A)$
for its \emph{tail} and its \emph{head}:
\begin{alignat*}{3}
  \pi_1 & : \implicit{\Gamma, \Delta, A}\;\Sub\;\Gamma\;(\Delta, A) \to \Sub\;\Gamma\;\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A}\;(\sigma : \Sub\;\Gamma\;(\Delta, A)) \to \Tm\;\Gamma\;([ \pi_1\,\sigma ]\; A)
\end{alignat*}
respectively.
Again, type substitution $[\pi_1\,\sigma]\,A$ is needed for~$\pi_2$, because $A$ is well-formed under the context $\Delta$ instead of $\Gamma$.
Finally, we have term substitution:
\begin{alignat*}{3}
  [\blank] \blank & : \implicit{\Gamma,\Delta, A}\;(\sigma : \Sub\;\Gamma\;\Delta) \to \Tm\;\Delta\;A \to \Tm\;\Gamma\;([\sigma]\; A).
\end{alignat*}
such that $[\sigma]\,t$ is of $\Tm\;\Gamma\;([\sigma]\,A)$.
Note that $[\blank]\blank$ is overloaded for type and term substitution.

The structural rules for type substitution are stipulated by following equality constructors:
\begin{alignat*}{3}
  [\idS]_T & : \implicit{\Gamma, A}                               && [ \idS ] \;A         && =^{\Ty\,\Gamma}\;A \\
  [;]_T    & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A} && [ \sigma ; \tau ]\;A && =^{\Ty\,\Gamma} [ \sigma ]\;([ \tau ]\;A) \\
  []\UU      & : \implicit{\Gamma, \Delta, \sigma}                && [ \sigma ]\;\UU        && =^{\Ty\,\Gamma} \UU
\end{alignat*}

The codomain $\Delta$ of a substitution $\sigma:\Sub\;\Gamma\;\Delta$ also tells the length of terms in $\sigma$, giving rise two $\eta$-laws in the case that $\Delta$ is empty and non-empty:
\begin{alignat*}{5}
  \emptyctx\eta   & : \implicit{\Gamma, A, \sigma} && \sigma        && =^{\Sub\,\Gamma\,\emptyctx} & \emptysub \\
  \pi\eta         & : \implicit{\Gamma, \Delta, \sigma} && \sigma   && =^{\Sub\,\Gamma\,(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma)
\end{alignat*}

The laws for substitution composition are stipulated using equality constructors.
\begin{alignat*}{5}
  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma} && {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma} && {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  ;\text{-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \Xi, \sigma, \tau, \gamma} && (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} && \sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau) , \alert{\transfib{\Tm\,\Gamma}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] t}}
\end{alignat*}
Substitution composition $\blank;\blank$ acts like a list concatenation, so $\sigma; (\tau, t)$ is intuitively equal to $(\sigma; \tau), [\sigma]\,t$ whereas the term $t$ is of type $\Tm\;\Delta\;([\tau]\;A)$. 
However, by the type of substitution extension, $[\sigma]\,t$ requires to be of type $\Tm\;\Gamma\;([\sigma; \tau]\,A)$ instead, so we have to transport $[\sigma]\,t$ explicitly along $[;]_{\Ty}^{-1}\colon [\sigma]\,[\tau]\;A = [\sigma;\tau]\,A$ to obtain a term of type $\Tm\;\Gamma\;([\sigma;\tau]\;A)$.

The tail and the head of a non-empty substitution $(\sigma, t)$ is obviously $\sigma$ and $t$ respectively:
\begin{alignat*}{5}
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_1(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\,([\blank]\,A)}_{\alert{\pi_1\beta}} &&  t, 
\end{alignat*}
whereas $\pi_2(\sigma, t)$ is an habitant of $\Tm\;\Gamma\;([\pi_1\,(\sigma, t)]\,A)$ instead of $\Tm\;\Gamma\;([\sigma]\,A)$ on the right-hand side. 
Therefore, we have to transport $\pi_2(\sigma, t)$ along $\pi_1\beta$, so the above equality constructor is, in fact, $\transfib{\Tm\;\Gamma\;([\blank]\,A)}{\pi_1\beta}{\pi_2(\sigma, t)} =^{\Tm\;\Gamma\;([\sigma]\,A)} t$.

Similarly, for term substitution, terms are transported along the corresponding rules:
\begin{alignat*}{5}
  [\idS]_t         & : \implicit{\Gamma, A, t} && {[\idS]\,t}         && =^{\Tm\;\Gamma}_{\alert{[\idS]_\Ty}}  && t \\
  [;]_t            & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\sigma ; \tau]\,t} && =^{\Tm\;\Gamma}_{\alert{[;]_{\Ty}}}   && {[ \sigma ]\,[ \tau ]\,t}
\end{alignat*}
equivalent to the following (homogeneous) identities
\[
  \transfib{\Tm\;\Gamma}{[\idS]_{\Ty}}{[\idS]\,t} =^{\Tm\,\Gamma\,A} t
  \quad\text{and}\quad
  \transfib{\Tm\;\Gamma}{[;]_{\Ty}}{[\sigma;\tau]\,t} =^{\Tm\,\Gamma\,([\sigma]\,[\tau]A)} [\sigma]\,[\tau]\,t
\]
respectively.
Constructors introduced so far complete the definition of substitution calculus.

The use of transports in the formal definition fixes type mismatches but hinders equational reasoning about these terms even for a simple fact below.
\begin{example}\label{ex:pi2-comp}
  Given substitutions $\sigma : \Sub\;\Gamma\; \Delta$ and $\tau : \Sub\;\Delta\;(\Theta, A)$ for any $A : \Ty\,\Theta$, we may apply the projection $\pi_2$ to the composite $(\sigma; \tau)$ to access the first term $\pi_2(\sigma; \tau)$ of type $[\sigma;\tau] A$ under the context $\Gamma$, and this term should be equal to the first term $\pi_2\,\tau$ of $\tau$ after applying the substitution $\sigma$. 
  In short, the following equality apparently holds
  \[
    \pi_2\,(\sigma ; \tau) = [\sigma] (\pi_2\,\tau)
  \]
  by a back-of-the-envelope calculation
  \begin{equation} \label{eq:pi2-comp-proof}
    \pi_2\,(\sigma ; \tau) 
    = \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))
    = \pi_2\,(\sigma;\pi_1\,\tau, [\sigma]\,(\pi_2\,\tau))
    = [\sigma] (\pi_2\,\tau).
  \end{equation}
  Yet, the left-hand side is a term of type $[\pi_1\,(\sigma;\tau)] A$, but the other is $[\sigma] [\pi_1\,\tau] A$.
  Hence the above identity does not even make sense, since their types do not match.
  Alas, instead, we have to write $\pi_2\,(\sigma ; \tau) =^{\Tm\,\Gamma}_{p} [\sigma] (\pi_2\,\tau)$ for some $p: [\pi_1(\sigma; \tau)]\,A = [\sigma]\,[\pi_1\tau]\,A$ or, equivalently
  \begin{equation}\label{eq:pi2-comp-real-proof}
    ([\pi_1(\sigma; \tau)]\,A, \pi_2(\sigma; \tau)) =^{(A : \Ty\,\Gamma) \times (\Tm \Gamma A)} ([\sigma]\,[\pi_1\,\tau]A, [\sigma] (\pi_2\,\tau))
  \end{equation}
  as inhabitants of a $\Sigma$-type, so we can reason about term equalities along with type equalities.
  Moreover, in~\eqref{eq:pi2-comp-proof} we have used the rule $\mathsf{concat}$ which introduced another transported term, so we will have to remove that $\transp$ to derive the right hand side.

  To better illustrate the annoyance, note that a complete proof of \eqref{eq:pi2-comp-real-proof} requires us to show each of following equations:
  \begin{alignat*}{3}
         & ([\pi_1(\sigma; \tau)]\,A                    &&, \pi_2\,(\sigma ; \tau)) \\
    = {} & ([\pi_1(\sigma; (\pi_1\tau , \pi_2\tau))]\,A &&, \pi_2\,(\sigma; (\pi_1\,\tau, \pi_2\,\tau))) \\
    = {} & ([\pi_1(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})]\,A &&, \pi_2\,(\sigma;\pi_1\,\tau, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})) \\
    = {} & ([\sigma;\pi_1\,\tau]\,A &&, \transfib{}{[;]_{\Ty}^{-1}}{\color{black}[ \sigma ] (\pi_2\;\tau)})) \nonumber \\
    = {} & (\sub{\sigma}{\sub{\pi_1\tau}{A}} &&, [\sigma] (\pi_2\,\tau)). \nonumber
  \end{alignat*}
  The first three equations corresponding to \eqref{eq:pi2-comp-proof} follow with Lemma~2.3.4 in \cite{UFP2013}, while the last has nothing to do with substitution calculus but the path lifting property (\cite[Lemma~2.3.2]{UFP2013}).
\end{example}

\subsection{Substitution calculus as a quotient inductive-inductive-recursive type} \label{subsec:SC-QIIRT}

To retain the intuitive way of reasoning such as \eqref{eq:pi2-comp-proof} \emph{formally}, we would like to make type substitution rules definitional, since the root cause is that type substitution as a constructor does not compute so that type mismatches occur with substitution.

One possibility is to define substitution calculus as a QII`R' type where type substitution, as a simultaneously defined recursion, does compute.
Now that $[ \idS ]_{\Ty}\;A = A$ and $[ \sigma ; \tau ]_{\Ty}\;A = [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A)$ do not make $[\blank]_{\Ty}\blank$ a (total) function, we may define it by
\begin{alignat*}{3}
[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
[ \sigma ]_{\Ty}\;\UU & = \UU
\end{alignat*}
Note that this definition is \emph{not} inductive-recursive in the sense of Dybjer and Setzer~\cite{Dybjer2000,Dybjer2003}: in their schema, the codomain of a simultaneously defined function does not refer to any inductive type being defined.\footnote{%
  While the general schema for this more liberal notion of induction-recursion remains underdeveloped, this definition is accepted in \Agda and used in other formalisation of type theory~\cite{Danielsson2006}.}
Still, although $[\idS]_{\Ty}\,A$ and $[\sigma; \tau]_{\Ty}\,A$ can be proved equal to~$A$ and~$[\sigma]_{\Ty}\,[\tau]_{\Ty}\,A$ respectively, they are not definitional.
This definition fails to remove any transport in the definition of substitution calculus.

Our second attempt is to define type substitution with additional rules:
\begin{alignat}{3}
[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \nonumber \\
[ \sigma ]_{\Ty}       \;\UU  & = \UU                                   \label{eq:type-sub-at2-1} \\
[ \idS ]_{\Ty}         \;A    & = A                                     \label{eq:type-sub-at2-2} \\
[ \sigma ; \tau ]_{\Ty}\;A    & = [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \label{eq:type-sub-at2-3}
\end{alignat}
However, this definition does \emph{not} reduce \eqref{eq:type-sub-at2-2} or \eqref{eq:type-sub-at2-3} definitionally.
By design, definitions by pattern matching will be elaborated to a form that corresponds to the \emph{eliminator} either using \emph{first-match semantics}~\cite{Cockx2020a} for function clauses or an explicit construct for pattern matching.
\LT[noinline]{How about \Coq and \Lean?}
In the above definition, only the eliminator for $\Ty\;\Delta$ will be considered using the first-match semantics, which amounts to the following definition:
\begin{alignat*}{3}
[\blank]_{\Ty} \blank &: \implicit{\Gamma, \Delta} \; \Sub\;\Gamma\;\Delta \to \Ty\;\Delta \to \Ty\;\Gamma \\
[ \sigma ]_{\Ty}\;\UU  & \reduce \UU
\end{alignat*}
where $\reduce$ is used to emphasise the reduction (which entails the definitional equality): we have done nothing different from our first attempt! 
%As a result, neither  are definitional.
We may swap \eqref{eq:type-sub-at2-1} with \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} to make \eqref{eq:type-sub-at2-2} and \eqref{eq:type-sub-at2-3} definitional, but then \eqref{eq:type-sub-at2-1} will be translated to 
\[
[ \emptysub ]_{\Ty}\;\UU         \reduce \UU, \qquad
[ \sigma, t ]_{\Ty}\;\UU         \reduce \UU, \qquad\text{and}\qquad 
[ \pi_1\,\sigma ]_{\Ty}\;\UU     \reduce \UU,
\]
making $[\sigma]\;\UU = \UU$ propositional instead.
Not being able to reduce $[ \sigma ]_{\Ty}\;\UU$ to $\UU$ would make our later extension with a type $\El\,a$ for $a : \Tm\;\Gamma\;\UU$ require another transport in the definition.
Likewise, for any extension with a type former such as $\Pi$-types, structural rules would still be propositional.
That is, using the standard semantics of function definition, we are not able to make type substitution definitional for \emph{both} $\Sub\;\Gamma\;\Delta$ and $\Ty\;\Delta$.

To ensure that type substitution is definitional for all \emph{rules}, we turn to a definition by overlapping patterns (\Cref{sec:meta:overlapping}) instead to make each clause definitional. 
In addition, we can include other derived rules such as $[\pi_1(\sigma, t)]_{\Ty}\;A = [ \sigma]_{\Ty}\;A$ as long as it is locally confluent and terminating.
We end up with the following definition for type substitution:
\begin{alignat}{3}
[\blank]_{\Ty} \blank            &: \implicit{\Gamma, \Delta} \; \Sub\,\Gamma\,\Delta \to \Ty\,\Delta \to \Ty\,\Gamma \nonumber \\
[ \idS ]_{\Ty}\;A                & \reduce A \label{eq:def-type-subst-1}\\
[ \sigma ; \tau ]_{\Ty}\;A       & \reduce [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \label{eq:def-type-subst-2}\\
[ \pi_1(\sigma, t) ]_{\Ty}\;A    & \reduce [\sigma]_\Ty\;A                       \label{eq:def-type-subst-3} \\
[ \pi_1(\sigma; \tau) ]_{\Ty}\;A & \reduce [\sigma]_\Ty\;([\pi_1\tau]_\Ty\;A)    \label{eq:def-type-subst-4} \\
[ \sigma ]_{\Ty}\;\UU            & \reduce \UU                                   \label{eq:def-type-subst-5}
\end{alignat}
We first check that this definition of type substitution is confluent.\footnote{%
\Agda implements a local confluence checker with the experimental option \text{-{}-local-confluence-check}.
This option is turned on globally in our formal implementation.}
\begin{proposition}[Local confluence] \label{prop:local-confluence-1}
  Type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
  \danger
\end{proposition}
\begin{proof}
  To show the local confluence, we consider all local peaks, i.e.\ each combination of \eqref{eq:def-type-subst-5} with \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4},
  \[
    [\idS]_{\Ty}\;\UU, \qquad [\sigma;\tau]_{\Ty}\;\UU, \qquad [\pi_1(\sigma, t)]_{\Ty}\;\UU, \qquad\text{and}\qquad [\pi_1(\sigma; \tau)]_{\Ty}\;\UU
  \]
  and show that each applicable clause does result in $\UU$.

  For example, $[\sigma;\tau]_{\Ty}\;\UU \reduce [\sigma]_{\Ty}\;([\tau]_{\Ty}\;\UU) \reduce [\sigma]_{\Ty}\;\UU \reduce \UU$ using \eqref{eq:def-type-subst-2} as the first reduction and $[\sigma;\tau]_{\Ty}\;\UU \reduce \UU$ using \eqref{eq:def-type-subst-5} as the first reduction.
  It is easy to see that remaining local peaks reduce to the same term.
\end{proof}
\begin{proposition}[Termination]
  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
  \danger
\end{proposition}
\begin{proof}
  \LT{clearly terms on the RHS are structurally smaller~\cite{Abel2002}.}
  
\end{proof}


With this definition of type substitution, other equality constructors can be introduced without any $\transp$, we list updated constructors as follows.
\begin{alignat*}{5}
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} &&\sigma ; (\tau , t) && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau), [ \sigma ]\;t \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\, A} &&  t \\
  [\idS]t         & : \implicit{\Gamma, A, t} && {[\idS]\,t}          && =^{\Tm\,\Gamma\,A} && t \\
  [;]t            & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\sigma ; \tau]\,t} && =^{\Tm\,\Gamma\,[\sigma ; \tau] A} && {[ \sigma ]\;[ \tau ]\;t}
\end{alignat*}

We revisit \Cref{ex:pi2-comp} to demonstrate the pragmatic benefit of QIIRTs over QIITs.
\begin{example}
  The equation $\pi_2\,(\sigma; \tau) = [\sigma](\pi_2\,\tau)$ can be formally stated without any transport.
  The type of the term on the LHS is $[\pi_1(\sigma;\tau)]_{\Ty}\;A$ and is definitionally equal to $[\sigma]_\Ty\;([\pi_1\tau]_\Ty\;A)$, i.e.\ the type of the term on the RHS.
  Moreover, the first components in each step of the proof of \eqref{eq:pi2-comp-real-proof}, are definitionally equal because of \eqref{eq:def-type-subst-3} and \eqref{eq:def-type-subst-4}.
  Consequently, the back-of-the-envelope calculation~\eqref{eq:pi2-comp-proof} is \emph{formally correct}.
\end{example}

Yet, as we are defining a function on a quotient inductive type, we have to prove that $[\blank]_{\Ty}\blank$ is coherent.
This boils down to that $[\blank]_{\Ty}\blank$ preserves all equality constructors.
\LT[noinline]{Should we mention any general condition for coherence?} 
\begin{proposition}[Coherence]\label{prop:coherence-1}
  $[\sigma]_{\Ty}\,A$ is (propositionally) equal to $[\tau]_{\Ty}\,A$ for every equality constructor $p : \sigma = \tau$.
  \danger
\end{proposition}
\begin{proof}
  As equality constructors $[\idS]_T$, $[;]_T$, and $[]\UU$ for types become definitional, it suffices to show that following identities
  \begin{align*}
    [\sigma;\idS]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [\idS;\sigma]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [(\sigma;\tau);\gamma]_{\Ty} \;A & = [\sigma; (\tau; \gamma)]_{\Ty}A, \\
    [\pi_1(\sigma, t)]_{\Ty}\;A      & = [\sigma]_{\Ty}\;A, \\
    [\sigma; (\tau, t)]_{\Ty} \;A    & = [(\sigma;\tau), [\sigma]\, t]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\emptyctx]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\pi_1\sigma, \pi_2\sigma]_{\Ty}\;A
  \end{align*}
  hold (propositionally).
  The first two identities of the first row hold definitionally by \eqref{eq:def-type-subst-1} and \eqref{eq:def-type-subst-2}, while terms of the both sides of the third reduce to $[\sigma]_{\Ty}\;([\tau]_{\Ty}\;([\gamma]_{\Ty}\;A))$ by \eqref{eq:def-type-subst-2}.

  The sole identity of the second row is just one, i.e.\ \eqref{eq:def-type-subst-3}, of the clauses of the definition.

  We show the remaining cases by induction on $A$.
  However, $\UU$ is the only constructor for $\Ty\;\Gamma$ for any $\Gamma$ and each of identities with $A \defeq \UU$ reduce to $\UU$.
\end{proof}
\begin{remark}\label{re:coherence-proof}
  Note that in the above proof the first four identities hold definitionally by \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4}, while the last three identities follow from \eqref{eq:def-type-subst-5} by induction on $A$.
  As we extend substitution calculus with other type formers, the first four identities will always hold but the last three depend on how congruence rules for type substitution is defined.
\end{remark}

\LT{We may wonder if the last three identities can be made definitional.
Can we find a complete set of rules?}

\subsection{... with an empty universe} \label{subsec:SC+U}
\LT[noinline]{Shall we go for Coquand universes? \cite{Coquand2013}}

In this section, we extend substitution calculus with an empty universe $\UU$ of small types~$\El\,u$.
For a QII definition \cite{Altenkirch2016a}, this extension adds following constructors
\begin{alignat*}{3}
  \El   & : \implicit{\Gamma} && \Tm\,\Gamma\;\UU \to \Ty\,\Gamma \\
  []\El & : \implicit{\Gamma, \Delta, \sigma, u} && [ \sigma ]\,(\El\, u) =^{\Tm\;\Gamma\;\UU} \El\,\alert{\transfib{\Tm\;\Gamma}{[]\UU}{\color{black}[\sigma]{u}}}
\end{alignat*}
as the type $\UU$ of universe and its structural rule $[]\UU$ have been added to avoid a trivial inductive type.
The type substitution $[\sigma](\El\,u)$ is, informally, the type of the term substitution $[\sigma]\,u$ for $u : \Tm\;\Delta\;\UU$, and the transport is needed to coerce $[\sigma]\,u : \Tm\;\Gamma\;([\sigma]\;\UU)$ into $\Tm\;\Gamma\;\UU$.

In our QIIR definition, $\transfib{\Tm\;\Gamma}{[]\UU}{\blank}$ is no longer needed, since $[]\UU$ becomes definitional. 
Likewise, the equality constructor $[]\El$ may be replaced by 
\begin{alignat*}{3}
  [ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma] {u})
\end{alignat*}
Yet, this naive change breaks the local confluence!
Observe that the local peak
\[
  \El\,u \Leftarrow [\idS]_{\Ty}(\El\,u) \reduce \El([\idS]\,u).
\]
cannot reduce to the same term, since the term substitution $[\idS]\,u$ is merely a constructor.

To repair the local confluence, we add a simultaneously defined function $[\blank]_{\Tm}\blank$ for term substitution apart from the explicit term substitution $[\blank]\blank$ as follows
\begin{alignat*}{3}
  [\blank]_{\Tm}\blank & : (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Delta\,A \to \Tm\,\Gamma\,([\sigma]_{\Ty}\,A) \\
[ \idS ]_{\Tm}\,t          & \reduce t \\
[ \sigma ; \tau ]_{\Tm}\,t & \reduce [ \sigma ]_{\Tm}\;([ \tau ]_{\Tm}\;t) \\
[ \pi_1(\sigma, t) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\,t \\
[ \pi_1(\sigma; \tau) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\; ([\pi_1\tau]_\Tm \,t) \\
[ \sigma ]_{\Tm}\,t        & \reduce [ \sigma ]\,t, \quad \text{otherwise}
\end{alignat*}
which reduces substitutions that occur in \eqref{eq:def-type-subst-1}--\eqref{eq:def-type-subst-4} recursively so that the reduction can be propagated from type to term substitution.
The remaining cases reduce to the explicit term substitution $[\sigma]\,t$.
Note that $[\blank]_{\Tm}\blank$ can be defined with the standard semantics for function definition, since there are no overlapping patterns.

Then, the equality constructor $[]\El$ is accordingly changed to 
\begin{align}
  [ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma]_{\Tm} {u}) \label{eq:def-type-subst-7}
\end{align}
to retain the local confluence for type substitution:
\begin{proposition}[Local confluence] \label{prop:local-confluence-2}
  Type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
  \danger
\end{proposition}
\begin{proof}
  In addition to previous cases in the proof of \Cref{prop:local-confluence-1}, consider terms 
  \[
    [\idS]_{\Ty}\;(\El\,u), \qquad [\sigma;\tau]_{\Ty}\;(\El\,u), \qquad [\pi_1(\sigma, t)]_{\Ty}\;(\El\,u), \qquad\text{and}\qquad [\pi_1(\sigma; \tau)]_{\Ty}\;(\El\,u)
  \]
  which reduce to the following terms
  \[
    \El\,u, \qquad \El([\sigma]_{\Tm}\,[\tau]_{\Tm}\,u), \qquad \El([\sigma]_{\Tm}\,u), \qquad\text{and}\qquad
    \El([\sigma]_{\Tm}\,[\pi_1\tau]_{\Tm}\,u)
  \]
  respectively, no matter which function clause of $[\blank]_{\Ty}\blank$ is used.
  Therefore, type substitution is locally confluent.
\end{proof}
\begin{proposition}[Termination]
  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
  \danger
\end{proposition}
\begin{proof}
  \LT{clearly terms on the RHS are structurally smaller~\cite{Abel2002}.}
\end{proof}

However, we also have to show that the recursive substitution $[\blank]_{\Tm}\blank$ is propositionally equal to the explicit substitution $[\blank]\blank$, so they can be used together consistently.

\begin{proposition}\label{prop:correctness-1}
  For any $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Tm\;\Delta\;A$, the term $[\sigma]t$ is propositionally equal to $[\sigma]_{\Tm}\,t$.
\end{proposition}
\begin{proof}
  We show this statement by induction on $\sigma$.
  \begin{enumerate}
    \item For the identity substitution $\idS$, we have $[\idS]t : [\idS]t = t$ but $t \judgeq [\idS]_{\Tm} t$ by definition.
    \item For a substitution composite $\sigma; \tau$, we have
      \begin{align*}
        [\sigma;\tau]t & = [\sigma]\,[\tau] t               && \text{by $[;]t$} \\
                       & = [\sigma]\,([\tau]_{\Tm}\,t)       && \text{by the induction hypothesis $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                       & = [\sigma]_{\Tm}\,([\tau]_{\Tm}\,t) && \text{by the induction hypothesis $[\sigma]u = [\sigma]_{\Tm}\,u$ for any $u$} \\
                       & \judgeq [\sigma;\tau]_{\Tm}\,t && \text{by definition.}
      \end{align*}
    \item For $\pi_1(\sigma, t)$, we have
      \begin{align*}
        [\pi_1(\sigma, t)]t & = [\sigma] t               && \text{by $\pi_1\beta$} \\
                            & = [\sigma]_{\Tm} \,t       && \text{by the induction hypothesis $[\tau]t = [\tau]_{\Tm}\,t$ for any $t$} \\
                            & \judgeq [\pi_1(\sigma, t)]_{\Tm}\,t && \text{by definition.}
      \end{align*}
    \item For $\pi_1(\sigma; \tau)$, it is proved similarly as the previous case.
    \item For the remaining cases, $[\sigma]_{\Tm} t$ is equal to $[\sigma]\,t$ definitionally.
  \end{enumerate}
  Hence, we conclude that $[\blank]_{\Tm}\blank$ is propositionally equal to $[\blank]\blank$.
  \LT[noinline]{Shall we say anything about equality constructors?}
\end{proof}

Finally, we have to show that both $[\blank]_{\Ty}\blank$ and $[\blank]_{\Tm}\blank$ are coherent.
\begin{proposition}[Coherence] \label{prop:coherence-2}
  For every equality constructor $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$, the following identities
  \danger
  \[
    [\sigma]_{\Ty}\,A = [\tau]_{\Ty}\,A
    \quad\text{and}\quad
    [\sigma]_{\Tm}\,t = [\tau]_{\Tm}\,t
  \]
  for any type $A$ and any term $t$.
\end{proposition}
\begin{proof}
  By \Cref{re:coherence-proof}, for type substitution, we only have to consider the following cases 
  \begin{align*}
    [\sigma; (\tau, t)]_{\Ty} \;A    & = [(\sigma;\tau), [\sigma]\, t]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\emptyctx]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\pi_1\sigma, \pi_2\sigma]_{\Ty}\;A
  \end{align*}
  while other cases hold definitionally.
  Again, for each case, we prove them by induction on $A$ and consider the case $A \defeq \El\,u$ only which is added to the definition of $[\blank]_{\Ty}\blank$ in this section. 
  However, all cases follow easily from \Cref{prop:correctness-1}.
  For example, consider the first case:
  \begin{align*}
    [\sigma; (\tau, t)]_{\Ty}(\El\,u) & \judgeq \El([\sigma; (\tau, t)]_{\Tm}\,u) && \text{by \eqref{eq:def-type-subst-7}} \\
                                      & = \El( [\sigma; (\tau, t)]\,u)            && \text{by \cref{prop:correctness-1}} \\
                                      & = \El( [\sigma; \tau, [\sigma]t)]\,u)     && \text{by $\mathsf{concat}$} \\
                                      & = \El( [\sigma; \tau, [\sigma]t)]_{\Tm}\,u) && \text{by \cref{prop:correctness-1}} \\
                                      & \judgeq [\sigma; \tau, [\sigma]t)]_{\Ty}\left(\El\,u\right) && \text{by \eqref{eq:def-type-subst-7} }
  \end{align*}
  The remaining two cases are omitted.

  As for term substitution $[\blank]_{\Tm}\blank$, each case follows from \cref{prop:correctness-1} in conjunction with the congruence rule for the identity type.
\end{proof}

\begin{remark}
We have seen that a naive extension with a universe breaks the local confluence of type substitution defined in \cref{subsec:SC-QIIRT}, because the newly added function clause interacts with other existing clauses.
In general, every term occurs on the right-hand side of a clause needs to propagate the reduction to allow a confluent term to exist, and this propagation can be achieved by turning a term involving a substitution $\sigma$ into a recursion.
\end{remark}

\subsection{... and \texorpdfstring{$\Pi$}{Î }-types} \label{subsec:SC+U+Pi}

In this section, we extend the type theory in \cref{subsec:SC+U} with $\Pi$-types, i.e.\ dependent function types, whose the context of its codomain is extended with the domain type.
For the QIIT of type theory in \cite{Altenkirch2016a}, it amounts to adding the following constructors for the type formation rule, the term introduction/elimination rules:
\begin{alignat*}{3}
  \Pi     &: \implicit{\Gamma}            && (A : \Ty\,\Gamma) \to \Ty\,(\Gamma, A) \to \Ty\,\Gamma \\
  \lambda &: \implicit{\Gamma, A, B}      && \Tm\;(\Gamma, A)\;B \to \Tm\,\Gamma\,(\Pi\;A\;B) \\
  \mathsf{app} &: \implicit{\Gamma, A, B} && \Tm\;\Gamma\;(\Pi\;A\;B) \to \Tm\;(\Gamma, A)\;B
\end{alignat*}
the computation rules
\begin{alignat*}{5}
  \Pi\beta           & : \implicit{\Gamma, A, B, t} && \mathsf{app}\,(\lambda\,t) && =^{\Tm\,\Gamma,A} && t \\
  \Pi\eta            & : \implicit{\Gamma, A, B, t} && t                        && =^{\Tm\,\Gamma,A} && \lambda(\mathsf{app}\,t)
\end{alignat*}
and the structural rules for substitution
\begin{alignat}{5}
  []\Pi              & : \implicit{\Gamma, \Delta, \sigma, A, B}    && [ \sigma ]_{\Ty}\,(\Pi\;A\;B) && =^{\Ty\;\Gamma} && \Pi\,(\sub{\sigma}{A})\,([\sigma\uparrow A]\,B) \label{eq:def-type-subst-8} \\
  \mathsf{[]\lambda} & : \implicit{\Gamma, \Delta, \sigma, A, B, t} && [\sigma]_{\Tm} (\lambda\,t) && =^{\Tm\,\Gamma}_{\alert{[]\Pi}} && \lambda\,([\sigma \uparrow A]\,t) \nonumber
\end{alignat}
where $\sigma \uparrow A$ is the \emph{lifting}  of $\sigma$ by a type $A$ defined as $(\pi_1\idS; \sigma, \alert{\transfib{\Tm\;\Gamma}{[;]_T}{\color{black}\pi_2\idS}})$. 

For our QIIR definition, $\sigma\uparrow A$ and $[]\lambda$ do not need a transport since $[;]_T$ and $[]\Pi$ are definitional.
However, once again, adding \eqref{eq:def-type-subst-8} directly to the type substitution $[\blank]_{\Ty}\blank$ breaks the local confluence, because the reduction gets stuck upon the lifting $\sigma \uparrow A$.
For example, $[\idS]_{\Ty}(\Pi\;A\;B)$ reduces to $\Pi\;A\;([\idS \uparrow A]_{\Ty}B)$ where $\idS \uparrow A$ is propositional but not definitional equal to $\idS$, so the local peak $\Pi\;A\;B \Leftarrow [\idS]_{\Ty}(\Pi\;A\;B) \reduce \Pi\;A\;([\idS \uparrow A]_{\Ty}B)$ cannot be joined. 

To retain the local confluence, we turn $\sigma \uparrow A$ into a simultaneously defined function:
\begin{alignat}{3}
  \blank\uparrow \blank & : (\sigma : \Sub\,\Gamma,\Delta) \to (A : \Ty\,\Delta) \to \Sub\,(\Gamma, [\sigma]_{\Ty}\,A)\, (\Delta, A) \label{eq:type-of-lifting} \\
\idS                \uparrow A & \reduce \idS \nonumber \\
(\sigma ; \tau)     \uparrow A & \reduce (\sigma \uparrow \sub{\tau}{A} ) ; (\tau \uparrow A) \nonumber \\
\pi_1(\sigma, t)    \uparrow A & \reduce \sigma \uparrow A \nonumber \\
\pi_1(\sigma; \tau) \uparrow A & \reduce (\sigma \uparrow \sub{\pi_1 \tau}{A}) ; (\pi_1 \tau \uparrow A)\nonumber \\
\sigma              \uparrow A & \reduce \sigma^+ , \quad \text{otherwise} \nonumber
\end{alignat}
where $\sigma^+ \defeq (\pi_1\idS ; \sigma, \pi_2\idS)$.
Then, we add another clause for type substitution and an equality constructor for term substitution without transport:
\begin{alignat}{5}
                     & [ \sigma ]_{\Ty}\,(\Pi\,A\,B) && \reduce \Pi\,(\sub{\sigma}{A})\,(\sub{\sigma\uparrow A}{B}) \label{eq:def-type-subst-9} \\
  \mathsf{[]\lambda} & : [\sigma]_{\Tm} (\lambda\,t) && =^{\Tm\,\Gamma\,([\sigma]_{\Ty}(\Pi\,A\,B))} && \lambda\,([\sigma \uparrow A]_{\Tm}\,t) \nonumber
\end{alignat}

\begin{proposition}[Local confluence]\label{prop:local-confluence-3}
  Type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
  \danger
\end{proposition}
\begin{proof}
  In addition to previous cases in \cref{prop:local-confluence-1,prop:local-confluence-2}, consider
  \begin{align*}
    [\idS]_{\Ty}\;(\Pi\;A\;B) && [\sigma;\tau]_{\Ty}\;(\Pi\;A\;B) && [\pi_1(\sigma, t)]_{\Ty}\;(\Pi\;A\;B) && [\pi_1(\sigma; \tau)]_{\Ty}\;(\Pi\;A\;B).
  \end{align*}
  Each of them reduces to the following terms after applying clauses of $\blank\uparrow\blank$ and $[\blank]_{\Ty}\blank$:
  \begin{align*}
    & \Pi\;A\;B                && \Pi\;([\sigma]_{\Ty}\,[\tau]_{\Ty}\,A)\;([\sigma \uparrow [\tau]\,A ]_{\Ty}\,[\tau \uparrow A ]_{\Ty}\,B) \\
    & \Pi\;([\sigma]_{\Ty}\;A)([\sigma \uparrow A]_{\Ty}\;B) && \Pi\;([\sigma]_{\Ty}\,[\pi_1\tau]_{\Ty}\,A)\;([\sigma \uparrow [\pi_1\tau]_{\Ty}\,[\pi_1\tau \uparrow A]_{\Ty}\,B)
  \end{align*}
  respectively.
  Hence, the type substitution $[\blank]_{\Ty}\blank$ is locally confluent.
\end{proof}
\begin{proposition}[Termination]
  Type substitution $[\blank]_{\Ty}\blank$ is terminating.
  \danger
\end{proposition}

Similar to term substitution, we can show that the lifted substitution $\sigma \uparrow A$ is propositionally equal to $\sigma^+$, based on two basic properties\footnote{%
  The reader is invited to prove them using the QII definition of type theory.}
about the lifting.
\begin{lemma} \label{lem:lifting}
  The following statements hold:
  \[
    \idS^+ =^{\Sub\;(\Gamma, A)\;(\Gamma, A)} \idS
    \qquad\text{and}\qquad
    (\sigma; \tau)^+     =^{\Sub\;(\Gamma, [\sigma]_{\Ty}\,[\tau]_{\Ty}\,A)\;(\Theta, A)} \sigma^+ ; \tau^+.
  \]
\end{lemma}

\begin{proposition} \label{prop:correctness-2}
  For every $\sigma : \Sub\;\Gamma\;\Delta$, and $A : \Ty\;\Delta$, the lifting
  $\sigma \uparrow A$ is propositionally equal to $(\pi_1 \idS ; \sigma , \pi_2 \idS)$.
\end{proposition}
\begin{proof}
  We prove the statement by induction on $\sigma$ with \cref{lem:lifting}.
  Every case follows from equational reasoning straightforwardly.
  For example, if $\sigma$ is a composite $\sigma;\tau$, we have
  \begin{align*}
    (\sigma;\tau) \uparrow A & \judgeq (\sigma \uparrow [\tau]\,A);(\tau \uparrow A) && \text{by definition} \\
                             & = \sigma^+;\tau^+                                     && \text{by induction hypothesis} \\ 
                             & = (\sigma;\tau)^+                                     && \text{by \cref{lem:lifting}.} 
  \end{align*}
  Other cases follow similarly.
\end{proof}

As we are working with a different type theory from \cref{subsec:SC+U}, we still have to prove the propositional equality $[\sigma]\,t = [\sigma]_{\Tm}\,t$ but the same argument still applies:
\begin{proposition} \label{prop:correctness-3}
  For every $\sigma : \Sub\;\Gamma\;\Delta$, $A : \Ty\;\Delta$, and $t : \Ty\;\Delta\;A$,
  the term $[\sigma]t$ is propositionally equal to $[\sigma]_{\Tm}\,t$.
\end{proposition}

Finally, we show that these simultaneously defined functions are coherent.
\begin{proposition}[Coherence]
  For every $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$, the following identities
  \danger
  \[
    \sigma \uparrow A =^{\lam{\gamma}\Sub\;(\Gamma, [ \gamma ]_{\Ty} A)\;(\Delta, A)}_{\alert{p}} \tau \uparrow A
    \qquad\text{and}\qquad
    [\sigma]_{\Tm}\,t =^{\lam{\gamma}\Tm\;\Gamma\;([\gamma]_{\Ty}A)}_{\alert{p}} [\tau]_{\Tm}\,t,
  \]
  hold for any type $A$ and any term $t$.
\end{proposition}
\begin{proof}
  These two identities follow from \cref{prop:correctness-2,prop:correctness-3} easily with the heterogeneous identity (see \cref{sec:meta}).
\end{proof}

\subsubsection{Multiple lifting and the coherence of type substitution}
For the coherence of~$[\blank]_{\Ty}\blank$, we have to generalise the desired identity to account for the lifting, since a naive induction does not work: for example, unfolding $[\sigma]_{\Ty}\,(\Pi\;A\;B)$ leads to
\[
  \Pi\;([\sigma]_{\Ty}\,A)\;([\sigma\uparrow A]_{\Ty}\,B)
\]
where the induction hypothesis $[\sigma]_{\Ty}\,B = [\emptysub]_{\Ty}\,B$ cannot be applied.
Instead, we will define the \emph{multiple lifting} $\sigma \upuparrows \Xi$ by a telescope $\Xi = A_1, \dots, A_n$, which intuitively means multiple applications of lifting: $\sigma \uparrow A_1 \uparrow \dots \uparrow A_n$.
Then, we show the identity
$[\sigma \mathop{\upuparrows} \Xi ]_{\Ty}\,A = [\tau \mathop{\upuparrows} \Xi ]_{\Ty}\,A$
for arbitrary $\Xi$, subsuming the special case $[\sigma ]_{\Ty}\,A = [\tau ]_{\Ty}\,A$ for $\Xi$ being empty.

First, define an inductive-recursive type of \emph{telescopes} under a context $\Gamma$ simultaneously with a concatenation $\blank \dplus \blank$ as follows.

\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  \Tel               & :                   && \Ctx \to \Set                                     \\
  \emptytel          & : \implicit{\Gamma} && \Tel\;\Gamma \\
  \blank,\blank      & : \implicit{\Gamma} && (\Xi : \Tel\;\Gamma) (A : \Ty\;(\Gamma \dplus \Xi)) \to \Tel\;\Gamma
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  \blank & \dplus\blank     && :       (\Gamma : \Ctx) (\Xi : \Tel\;\Gamma) \to \Ctx \\
  \Gamma & \dplus \emptytel && \reduce \Gamma \\
  \Gamma & \dplus (\Xi, A)  && \reduce (\Gamma \dplus \Xi) , A
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip\noindent
Then, we define the multiple lifting $\blank \upuparrows \blank$.
Observe that its type, generalising the type \eqref{eq:type-of-lifting} of a single lifting $\blank\uparrow\blank$, should be
\[
\blank\upuparrows \blank : (\sigma : \Sub\;\Gamma\;\Delta) \to (\Xi : \Tel\;\Delta)
\to \Sub\;(\Gamma \dplus ([\sigma]_{\Tel}\,\Xi))\;(\Delta \dplus \Xi)
\]
asking for telescope substitution $[\blank]_{\Tel}\blank :  \Sub\;\Gamma\;\Delta \to \Tel\;\Delta \to \Tel\;\Gamma$, but $[\blank]_{\Tel}\blank$ also needs the multiple lifting for the case $[ \sigma ]_{\Tel}\,(\Xi, A)$ (why?).
Hence, we arrive the conclusion that telescope substitution and the multiple lifting by a telescope need to be defined mutually:
\begin{minipage}{.5\linewidth}
\begin{alignat*}{5}
  & [ \sigma ]_{\Tel}\,\emptytel && \reduce \emptytel \\
  & [ \sigma ]_{\Tel}\,(\Xi, A)  && \reduce [ \sigma ]_{\Tel}\,\Xi, [\sigma \upuparrows \Xi]_{\Ty}\,A
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\linewidth}
\begin{alignat*}{5}
  & \sigma \upuparrows \emptytel && \reduce \sigma \\
  & \sigma \upuparrows (\Xi, A)  && \reduce (\sigma \upuparrows \Xi), A
\end{alignat*}
\end{minipage}
\vskip\belowdisplayskip

To prove the coherence property for the multiple lifting, we would need the properties $(\idS\;\{\Gamma\}) \upuparrows \Xi = \idS\;\{\Gamma \dplus  \Xi\}$ and $(\sigma; \tau) \upuparrows \Xi = \sigma; \tau^+$, similar to \cref{lem:lifting}, but these identities cannot be typed: the type of $\idS \upuparrows \Xi$ is $\Sub\;(\Gamma \dplus [\idS]_{\Tel}\,\Xi)\;(\Gamma \dplus \Xi)$ while the type of $\idS$ on the RHS is $\Sub\;(\Gamma \dplus \Xi)\;(\Gamma \dplus \Xi)$; similarly for the substitution composition.

Instead of resorting to \transp, we also turn telescope substitution $[\blank]_{\Tel}\blank$ and the multiple lifting into definitions by overlapping patterns by adding following clauses:

\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  & [ \idS   ]_{\Tel}       \,\Xi && \reduce \Xi \\
  & [ \sigma ; \tau ]_{\Tel}\,\Xi && \reduce [ \sigma ]_{\Tel}\,([\tau]_{\Tel}\,\Xi)
\end{alignat*}
\end{minipage}
\begin{minipage}{.5\textwidth}
\begin{alignat*}{5}
  & \idS          \upuparrows \Xi && \reduce \idS \\
  & (\sigma;\tau) \upuparrows \Xi && \reduce (\sigma \upuparrows [ \tau ]_{\Tel} \Xi) ; (\tau \upuparrows \Xi)
\end{alignat*}
\end{minipage}\vskip\belowdisplayskip\noindent
whose confluence property is easy to see.
Now, we proceed with the coherence property for the multiple lifting, telescope substitution, and type substitution altogether.
\begin{proposition}[Coherence]
  For every equality constructor $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$, the identities
  \danger
  \begin{align*}
  [\sigma]_{\Tel}\,\Xi & = [\tau]_{\Tel}\,\Xi 
                         & [\sigma \upuparrows \Xi ]_{\Ty}\,A & =^{\lam{\gamma}\Ty\;(\Gamma \dplus [\gamma]_{\Tel}\Xi)}_{\alert{p}} [\tau \upuparrows \Xi ]_{\Ty}\,A \\
\sigma \upuparrows \Xi & =^{\lam{\gamma}\Sub\;(\Gamma\dplus [\gamma]\Xi)\;(\Delta\dplus\Xi)}_{\alert{p}} \tau \upuparrows \Xi
%    &
%  [\sigma \upuparrows \Xi ]_{\Tm}\,t & =^{\lam{\gamma}\Tm\;(\Gamma \dplus [\gamma]_{\Tel}\Xi)\;([\gamma \upuparrows \Xi]_{\Ty} A)}_{\alert{p}} [\tau \upuparrows \Xi ]_{\Tm}\,t
  \end{align*}
  hold for any telescope $\Xi$ and type $A : \Ty\;(\Delta\dplus \Xi)$.
\end{proposition}
\begin{proof}
  \LT{
    Consider the following cases 
  \begin{align*}
    [\sigma;\idS]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [\idS;\sigma]_{\Ty} \;A          & = [\sigma]_{\Ty}\;A,
                                     & [(\sigma;\tau);\gamma]_{\Ty} \;A & = [\sigma; (\tau; \gamma)]_{\Ty}A, \\
    [\pi_1(\sigma, t)]_{\Ty}\;A      & = [\sigma]_{\Ty}\;A, \\
    [\sigma; (\tau, t)]_{\Ty} \;A    & = [(\sigma;\tau), [\sigma]\, t]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\emptyctx]_{\Ty}\;A,
                                     & [\sigma]_{\Ty} \;A               & = [\pi_1\sigma, \pi_2\sigma]_{\Ty}\;A
  \end{align*}
  Identities in the firs row are straightforward (not completely trivial, though).
  We shall demonstrate the proof for $[\pi_1(\sigma, t)]_{\Ty}\;A = [\sigma]_{\Ty}\;A$ only.

  By induction on $A$ first then prove other identities by induction on $\Xi$.
  }
\end{proof}

\begin{corollary}[Coherence]
  the identity $[\sigma]_{\Ty} A = [\tau]_{\Ty}A$ holds for every equality constructor $p : \sigma = \tau : \Sub\;\Gamma\;\Delta$.
  \danger
\end{corollary}


We conclude this extension with $\Pi$-types by noting that single term substitution
\begin{alignat*}{3}
  \left<\blank\right> & : \Tm\;\Gamma\;A \to \Sub\;\Gamma\;(\Gamma, A) \\
  \left< t \right> & \defeq (\idS , t),
\end{alignat*}
used to define the ordinal application: $t \mathop{\$} u \defeq [ \left< u \right> ]_{\Tm} (\mathsf{app}\,t)$, 
can be introduced without any transport, which is $(\idS, \alert{\transfib{\Tm\;\Gamma}{[id]_T^{-1}}{\color{black}t}})$ in its QII definition.
Similarly, the structural rule for substitution on $\mathsf{app}$ can be derived
\begin{align*}
  [\sigma \uparrow A ]_{\Tm}(\mathsf{app}\;t) & = \mathsf{app}\,\lambda([\sigma \uparrow A ]_{\Tm}(\mathsf{app}\;t)) && \text{by $\Pi\beta^{-1}$} \\
                                              & = \mathsf{app}\,\left([\sigma]\,\lambda\,(\mathsf{app}\,t)\right) && \text{by $[]\lambda^{-1}$} \\
                                              & = \mathsf{app}\,([\sigma]\,t) && \text{by $\Pi\eta^{-1}$.}
\end{align*}
without any transport (cf.\ \cite{Altenkirch2016a}), since \eqref{eq:def-type-subst-8} has become definitional. 


\subsection{... and other type formers} \label{subsec:SC+U+Pi+more}
\LT{%
\begin{enumerate}
  \item Discuss the unit type.
  \item Discuss the Boolean type.
  \item Discuss the type of natural numbers.
  \item Discuss the extensional identity type.
\end{enumerate}
}

\section{The eliminator, the standard model, and the equivalence to the QII definition of type theory}
\LT{%
\begin{enumerate}
  \item Introduce motives and methods for the definition in \Cref{subsec:SC+U+Pi}.
  \item The rule $\mathsf{Elim}_{\Ty}\,([ \sigma ]_{\Ty}\,A) = [ \mathsf{Elim}_{\Sub}\,\sigma ]^{A}_{\Ty}(\mathsf{Elim}_{\Ty}\,A)$ is not defined but provable. 
  \item $\mathsf{Elim}_{\Tm}\,([ \sigma ]_{\Tm}\,t) = [ \mathsf{Elim}_{\Sub}\,\sigma ]^{A}_{\Tm}(\mathsf{Elim}_{\Tm}\,t)$ is proved.
\end{enumerate}
}

\LT{%
\begin{enumerate}
  \item Show that two definitions are equivalent (ongoing).
  \item Show that methods are equivalent (ongoing).
\end{enumerate}
}

\section{Formal implementation}
\LT{Mention the NbE for SC here}
\LT{Compare some formal proofs with pen-and-paper proofs here}
\section{Discussion}
\subsection{Related work}
\paragraph*{Formalisation of type theory in type theory}
\cite{Danielsson2006,Altenkirch2016a,Chapman2009}
\cite{Altenkirch2017}
\cite{Munoz1998}
\cite{Dybjer1996,Castellan2021}
\LT{Dybjer \cite{Dybjer1996} already says cwf is inductive-recursive}

Substitution calculus is closely related to \emph{categories with families}~\cite{Dybjer1996}.
\paragraph*{Quotient inductive-recursive definition of single substitution calculus}
\cite{Kaposi2023,Kaposi2024a}
\paragraph*{Schemata of inductive types}
\cite{Kaposi2019}
\LT{How does the general schema in \cite{Kaposi2019} model equality constructors? extensionally? Can their schemata manifest the difference of our QIIR definition and the QII definition in \cite{Altenkirch2016a}?}

\subsection{Future work}
\paragraph*{Type theory in type theory}
\cite{Pujet2022,Pujet2024,Pujet2022a}
\LT{OTT is a concrete instance of a type theory with UIP and function extensionality.}

\paragraph*{Semantics and design for definitions by overlapping patterns}
\LT{Overlapping patters are discussed by Cocks \cite{Cockx2014}, but we would like to integrate it with the schema of QIIRT.}
\LT{\cite{Eremondi2025} has recently hinted a possible direction for overlapping patterns using sheaf theory.}

\paragraph*{A schema of quotient inductive-inductive-recursive types in observation type theory}
\LT{What a general schema should have?  inductive types should be allowed as the codomain of a recursion.}
  
\LT{OTT also has a natural setoid model (which should be useful to manifest the difference between recursion and equality constructor) but quotient (inductive-)inductive(-recursive) types in OTT are underdeveloped.}


\IfFileExists{./reference.bib}{\bibliography{reference}}{\bibliography{ref}}

\appendix

\section{Complete definitions}
\begin{alignat*}{3}
  \Ctx      & : && \Set                   \\
  \Ty       & : && \Ctx \to \Set          \\
  \Sub      & : && \Ctx \to \Ctx \to \Set \\
  \Tm       & : && (\Gamma : \Ctx) \to \Ty\,\Gamma \to \Set \\
  \emptyctx & : && \Ctx \\
  \blank,\blank & : && (\Gamma : \Ctx) \to \Ty\,\Gamma \to \Ctx \\
  [\blank]\blank & : \implicit{\Gamma, \Delta} && \Sub\,\Gamma\,\Delta \to \Ty\,\Delta \to \Ty\,\Gamma \\
  \emptysub & : \implicit{\Gamma} && \Sub\,\Gamma\,\emptyctx \\
  \blank,\blank & : \implicit{\Gamma, \Delta, A} && (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Gamma\,([ \sigma ]_{\Ty} A) \to \Sub\,\Gamma,(\Delta, A) \\
  \idS & : \implicit{\Gamma} && \Sub\,\Gamma\,\Gamma \\
  \blank;\blank & : \implicit{\Gamma, \Delta, \Theta} && \Sub\,\Gamma\,\Delta \to \Sub\,\Delta\,\Theta \to \Sub\,\Gamma\,\Theta \\
  \pi_1 & : \implicit{\Gamma, \Delta, A} && \Sub\,\Gamma\,(\Delta, A) \to \Sub\,\Gamma\,\Delta \\
  \pi_2 & : \implicit{\Gamma, \Delta, A} && (\sigma : \Sub\,\Gamma\,(\Delta, A)) \to \Tm\,\Gamma\,([ \pi_1\,\sigma ]\, A) \\
  [\blank] \blank & : \implicit{\Gamma,\Delta, A} && (\sigma : \Sub\,\Gamma\,\Delta) \to \Tm\,\Delta\,A \to \Tm\,\Gamma\,([\sigma]\, A) \\
  \UU     & : \implicit{\Gamma} && \Ty\, \Gamma \\
  \El     & : \implicit{\Gamma} && \Tm\,\Gamma\,U \to \Ty\,\Gamma \\
  \Pi     & : \implicit{\Gamma} && (A : \Ty\,\Gamma) \to \Ty\,(\Gamma, A) \to \Ty\,\Gamma \\
\end{alignat*}

\begin{alignat*}{5}
[ \idS ]_{\Ty}\,A             & \reduce A \\
[ \sigma ; \tau ]_{\Ty}\,A    & \reduce [ \sigma ]_{\Ty}\;([ \tau ]_{\Ty}\;A) \\
[ \pi_1(\sigma, t) ]_{\Ty}\,A & \reduce [\sigma]_\Ty\,A \\
[ \pi_1(\sigma; \tau) ]_{\Ty}\,A & \reduce [\sigma]_\Ty ([\pi_1\tau]_\Ty \,A) \\
[ \sigma ]_{\Ty}\,\UU           & \reduce \UU \\
[ \sigma ]_{\Ty}\,(\El\, u) & \reduce \El\,([\sigma]_{\Tm}{u}) \\
[ \sigma ]_{\Ty}\,(\Pi\,A\,B) & \reduce \Pi\,(\sub{\sigma}{A})\,(\sub{\sigma\uparrow A}{B}) \\
\idS                \uparrow A & \reduce \idS \\
\sigma ; \tau       \uparrow A & \reduce (\sigma \uparrow \sub{\tau}{A} ) ; (\tau \uparrow A) \\
\pi_1(\sigma, t)    \uparrow A & \reduce \sigma \uparrow A \\
\pi_1(\sigma; \tau) \uparrow A & \reduce \sigma \uparrow (\sub{\pi_1 \tau}{A}) ; (\pi_1 \tau \uparrow A) \\
\sigma              \uparrow A & \reduce (\pi_1 \idS ; \sigma , \pi_2 \idS) & \text{otherwiese} \\
 [ \idS ]_{\Tm}\,t                & \reduce t \\
 [ \sigma ; \tau ]_{\Tm}\,t       & \reduce [ \sigma ]_{\Tm}\;([ \tau ]_{\Tm}\;t) \\
 [ \pi_1(\sigma, t) ]_{\Tm}\,t    & \reduce [\sigma]_\Tm\,t \\
 [ \pi_1(\sigma; \tau) ]_{\Tm}\,t & \reduce [\sigma]_\Tm\; ([\pi_1\tau]_\Tm \,t) \\
 [ \sigma ]_{\Tm}\,t              & \reduce [ \sigma ]\,t & \text{otherwise}
\end{alignat*}

\begin{alignat*}{5}
  \mathsf{idr}    & : \implicit{\Gamma, \Delta, \sigma} && {\sigma ; \idS_{\Delta}} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  \mathsf{idl}    & : \implicit{\Gamma, \Delta, \sigma} && {\idS_{\Gamma} ; \sigma} && =^{\Sub\,\Gamma\,\Delta} && {\sigma} \\
  ;\text{-}\mathsf{assoc} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, \gamma} && (\sigma ; \tau) ; \gamma && =^{\Sub\,\Gamma\,\Theta} &&  \sigma ; (\tau ; \gamma) \\
  \mathsf{concat} & : \implicit{\Gamma, \Delta, \Theta, \sigma, \tau, A, t} &&\sigma ; (\tau , t)      && =^{\Sub\,\Gamma\,(\Theta, A)} &&  (\sigma ; \tau) , [ \sigma ] t \\
  \emptyctx\eta   & : \implicit{\Gamma, \sigma} && \sigma                   && =^{\Sub\,\Gamma\,\emptyctx} & \emptysub \\
  \pi\eta         & : \implicit{\Gamma, A, \sigma} && \sigma                   && =^{\Sub\,\Gamma\,(\Delta, A)} &&  (\pi_1 \sigma, \pi_2 \sigma) \\
  \pi_1\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_1(\sigma , t)        && =^{\Sub\,\Gamma,\Delta} &&  \sigma \\
  \pi_2\beta      & : \implicit{\Gamma, \Delta, \Theta, \sigma, A, t} && \pi_2(\sigma , t)        && =^{\Tm\,\Gamma\, A} &&  t \\
  [\idS]t         & : \implicit{\Gamma, A, t} && {[\,\idS\,]\,t}          && =^{\Tm\,\Gamma\,A} && t \\
  [;]t            & :\implicit{\Gamma, \Delta, \Theta, \sigma, \tau, t} && {[\,\sigma ; \tau\,]\,t} && =^{\Tm\,\Gamma\,[\sigma ; \tau] A} && {[ \sigma ]\,[ \tau ]\,t} \\
\end{alignat*}

\section{Formal definitions in Agda}
\end{document}
