

@article{Dybjer1994,
  author =        {Dybjer, Peter},
  journal =       {Formal Aspects of Computing},
  number =        {4},
  pages =         {440--465},
  title =         {Inductive families},
  volume =        {6},
  year =          {1994},
  abstract =      {A general formulation of inductive and recursive
                   definitions in Martin-L{\"o}f's type theory is
                   presented. It extends Backhouse's `Do-It-Yourself
                   Type Theory'to include inductive definitions of
                   families of sets and definitions of functions by
                   recursion on the way elements of such sets are
                   generated. The formulation is in natural deduction
                   and is intended to be a natural generalisation to
                   type theory of Martin-L{\"o}f's theory of iterated
                   inductive definitions in predicate logic.},
  doi =           {10.1007/BF01211308},
  isbn =          {1433-299X},
}

@inproceedings{Altenkirch1999,
  author =        {Altenkirch, Thorsten and Reus, Bernhard},
  booktitle =     {13th International Workshop on Computer Science Logic
                   (CSL '99)},
  editor =        {Flum, J{\"{o}}rg and
                   Rodr{\'{\i}}guez{-}Artalejo, Mario},
  pages =         {453--468},
  publisher =     {Springer},
  series =        {Lecture Notes in Computer Science},
  title =         {Monadic presentations of lambda terms using
                   generalized inductive types},
  volume =        {1683},
  year =          {1999},
  doi =           {10.1007/3-540-48168-0\_32},
}

@article{Dybjer2000,
  author =        {Dybjer, Peter},
  journal =       {Journal of Symbolic Logic},
  number =        {2},
  pages =         {525--549},
  title =         {A general formulation of simultaneous
                   inductive-recursive definitions in type theory},
  volume =        {65},
  year =          {2000},
  doi =           {10.2307/2586554},
}

@phdthesis{Nordvall-Forsberg2014,
  author =        {Nordvall Forsberg, Fredrik},
  school =        {Swansea University},
  title =         {Inductive-inductive definitions},
  year =          {2014},
}

@inproceedings{Danielsson2006,
  author =        {Danielsson, Nils Anders},
  booktitle =     {Types for Proofs and Programs (TYPES 2006)},
  editor =        {Altenkirch, Thorsten and McBride, Conor},
  publisher =     {Springer, Berlin, Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {A formalisation of a dependently typed language as an
                   inductive-recursive family},
  volume =        {4502},
  year =          {2007},
  doi =           {10.1007/978-3-540-74464-1_7},
}

@article{Chapman2009,
  address =       {NLD},
  author =        {Chapman, James},
  journal =       {Electronic Notes in Theoretical Computer Science},
  month =         {jan},
  pages =         {21--36},
  publisher =     {Elsevier Science Publishers B. V.},
  title =         {Type theory should eat itself},
  volume =        {228},
  year =          {2009},
  abstract =      {In this paper I present a partial formalisation of a
                   normaliser for type theory in Agda [Ulf Norell. Agda
                   2, 2007. http://www.cs.chalmers.se/~ulfn/]; extending
                   previous work on big-step normalisation [Thorsten
                   Altenkirch and James Chapman. Big-Step Normalisation.
                   Journal of Functional Programming, 2008. Special
                   Issue on Mathematically Structured Functional
                   Programming. To appear, Thorsten Altenkirch and James
                   Chapman. Tait in one big step. In Workshop on
                   Mathematically Structured Functional Programming,
                   MSFP 2006, Kuressaare, Estonia, July 2, 2006,
                   electronic Workshop in Computing (eWiC), Kuressaare,
                   Estonia, 2006. The British Computer Society (BCS)].
                   The normaliser in written as an environment machine.
                   Only the computational behaviour of the normaliser is
                   presented omitting details of termination.},
  doi =           {10.1016/j.entcs.2008.12.114},
  issn =          {1571-0661},
}

@inproceedings{Kaposi2020a,
  address =       {Dagstuhl, Germany},
  author =        {Kaposi, Ambrus and Kov\'{a}cs, Andr\'{a}s and
                   Lafont, Ambroise},
  booktitle =     {25th International Conference on Types for Proofs and
                   Programs (TYPES 2019)},
  editor =        {Bezem, Marc and Mahboubi, Assia},
  pages =         {6:1--6:30},
  publisher =     {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r
                   Informatik},
  series =        {Leibniz International Proceedings in Informatics
                   (LIPIcs)},
  title =         {For finitary induction-induction, induction is
                   enough},
  volume =        {175},
  year =          {2020},
  annote =        {Keywords: type theory, inductive types,
                   inductive-inductive types},
  doi =           {10.4230/LIPIcs.TYPES.2019.6},
  isbn =          {978-3-95977-158-0},
  issn =          {1868-8969},
  urn =           {urn:nbn:de:0030-drops-130707},
}

@inproceedings{Altenkirch2016a,
  address =       {New York, NY, USA},
  author =        {Altenkirch, Thorsten and Kaposi, Ambrus},
  booktitle =     {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT
                   Symposium on Principles of Programming Languages},
  pages =         {18--29},
  publisher =     {Association for Computing Machinery},
  series =        {POPL '16},
  title =         {Type theory in type theory using quotient inductive
                   types},
  year =          {2016},
  abstract =      {We present an internal formalisation of a type heory
                   with dependent types in Type Theory using a special
                   case of higher inductive types from Homotopy Type
                   Theory which we call quotient inductive types (QITs).
                   Our formalisation of type theory avoids referring to
                   preterms or a typability relation but defines
                   directly well typed objects by an inductive
                   definition. We use the elimination principle to
                   define the set-theoretic and logical predicate
                   interpretation. The work has been formalized using
                   the Agda system extended with QITs using postulates.},
  doi =           {10.1145/2837614.2837638},
  isbn =          {9781450335492},
}

@inproceedings{Altenkirch2018,
  author =        {Altenkirch, Thorsten and Capriotti, Paolo and
                   Dijkstra, Gabe and Kraus, Nicolai and
                   Nordvall Forsberg, Fredrik},
  booktitle =     {Foundations of Software Science and Computation
                   Structures (FoSSaCS)},
  editor =        {Baier, Christel and Dal Lago, Ugo},
  pages =         {293--310},
  publisher =     {Springer, Cham},
  series =        {Lecture Notes in Computer Science},
  title =         {Quotient inductive-inductive types},
  volume =        {10803},
  year =          {2018},
  abstract =      {Higher inductive types (HITs) in Homotopy Type Theory
                   allow the definition of datatypes which have
                   constructors for equalities over the defined type.
                   HITs generalise quotient types, and allow to define
                   types with non-trivial higher equality types, such as
                   spheres, suspensions and the torus. However, there
                   are also interesting uses of HITs to define types
                   satisfying uniqueness of equality proofs, such as the
                   Cauchy reals, the partiality monad, and the
                   well-typed syntax of type theory. In each of these
                   examples we define several types that depend on each
                   other mutually, i.e. they are inductive-inductive
                   definitions. We call those HITs quotient
                   inductive-inductive types (QIITs). Although there has
                   been recent progress on a general theory of HITs,
                   there is not yet a theoretical foundation for the
                   combination of equality constructors and
                   induction-induction, despite many interesting
                   applications. In the present paper we present a first
                   step towards a semantic definition of QIITs. In
                   particular, we give an initial-algebra semantics. We
                   further derive a section induction principle, stating
                   that every algebra morphism into the algebra in
                   question has a section, which is close to the
                   intuitively expected elimination rules.},
  doi =           {10.1007/978-3-319-89366-2_16},
}

@article{Kaposi2019,
  address =       {New York, NY, USA},
  author =        {Kaposi, Ambrus and Kov{\'a}cs, Andr{\'a}s and
                   Altenkirch, Thorsten},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         jan,
  number =        {POPL},
  pages =         {2:1--2:24},
  publisher =     {Association for Computing Machinery},
  title =         {Constructing quotient inductive-inductive types},
  volume =        {3},
  year =          {2019},
  abstract =      {Quotient inductive-inductive types (QIITs) generalise
                   inductive types in two ways: a QIIT can have more
                   than one sort and the later sorts can be indexed over
                   the previous ones. In addition, equality constructors
                   are also allowed. We work in a setting with
                   uniqueness of identity proofs, hence we use the term
                   QIIT instead of higher inductive-inductive type. An
                   example of a QIIT is the well-typed (intrinsic)
                   syntax of type theory quotiented by conversion. In
                   this paper first we specify finitary QIITs using a
                   domain-specific type theory which we call the theory
                   of signatures. The syntax of the theory of signatures
                   is given by a QIIT as well. Then, using this syntax
                   we show that all specified QIITs exist and they have
                   a dependent elimination principle. We also show that
                   algebras of a signature form a category with families
                   (CwF) and use the internal language of this CwF to
                   show that dependent elimination is equivalent to
                   initiality.},
  doi =           {10.1145/3290315},
}

@inproceedings{Hofmann1996,
  author =        {Hofmann, Martin},
  booktitle =     {Types for Proofs and Programs (TYPES 1996)},
  editor =        {Berardi, Stefano and Coppo, Mario},
  pages =         {153--164},
  publisher =     {Springer, Berlin, Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Conservativity of equality reflection over
                   intensional type theory},
  volume =        {1158},
  year =          {1996},
  doi =           {10.1007/3-540-61780-9_68},
}

@inproceedings{Winterhalter2019,
  address =       {New York, NY, USA},
  author =        {Winterhalter, Th{\'{e}}o and Sozeau, Matthieu and
                   Tabareau, Nicolas},
  booktitle =     {Proceedings of the 8th ACM SIGPLAN International
                   Conference on Certified Programs and Proofs},
  pages =         {91--103},
  publisher =     {Association for Computing Machinery},
  series =        {CPP 2019},
  title =         {Eliminating reflection from type theory},
  year =          {2019},
  abstract =      {Type theories with equality reflection, such as
                   extensional type theory (ETT), are convenient
                   theories in which to formalise mathematics, as they
                   make it possible to consider provably equal terms as
                   convertible. Although type-checking is undecidable in
                   this context, variants of ETT have been implemented,
                   for example in NuPRL and more recently in Andromeda.
                   The actual objects that can be checked are not
                   proof-terms, but derivations of proof-terms. This
                   suggests that any derivation of ETT can be translated
                   into a typecheckable proof term of intensional type
                   theory (ITT). However, this result, investigated
                   categorically by Hofmann in 1995, and 10 years later
                   more syntactically by Oury, has never given rise to
                   an effective translation. In this paper, we provide
                   the first effective syntactical translation from ETT
                   to ITT with uniqueness of identity proofs and
                   functional extensionality. This translation has been
                   defined and proven correct in Coq and yields an
                   executable plugin that translates a derivation in ETT
                   into an actual Coq typing judgment. Additionally, we
                   show how this result is extended in the context of
                   homotopy type theory to a two-level type theory.},
  doi =           {10.1145/3293880.3294095},
  isbn =          {9781450362221},
}

@article{Kapulkin2025,
  author =        {Kapulkin, Krzysztof and Li, Yufeng},
  journal =       {Theoretical Computer Science},
  pages =         {115051},
  title =         {Extensional concepts in intensional type theory,
                   revisited},
  volume =        {1029},
  year =          {2025},
  doi =           {10.1016/j.tcs.2024.115051},
}

@misc{Kaposi2023,
  author =        {Kaposi, Ambrus},
  howpublished =  {Presented at TYPES'23 meeting},
  title =         {Towards quotient inductive-inductive-recursive types},
  year =          {2023},
  url =           {https://types2023.webs.upv.es/slides/S13/TYPES2023-
                  Kaposi.pdf},
}

@incollection{Dybjer1996,
  author =        {Dybjer, Peter},
  booktitle =     {Types for Proofs and Programs. TYPES 1995},
  editor =        {Berardi, Stefano and Coppo, Mario},
  pages =         {120--134},
  publisher =     {Springer, Berlin, Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Internal type theory},
  volume =        {1158},
  year =          {1996},
  doi =           {10.1007/3-540-61780-9_66},
}

@book{UFP2013,
  address =       {Institute for Advanced Study},
  author =        {{Univalent Foundations Program}, The},
  publisher =     {https://homotopytypetheory.org/book},
  title =         {Homotopy Type Theory: Univalent Foundations of
                   Mathematics},
  year =          {2013},
}

@misc{Licata2011,
  author =        {Licata, Dan},
  month =         {April},
  title =         {Running circles around (in) your proof assistant; or,
                   quotients that compute},
  year =          {2011},
}

@inproceedings{Dybjer1999,
  address =       {Berlin, Heidelberg},
  author =        {Dybjer, Peter and Setzer, Anton},
  booktitle =     {Typed Lambda Calculi and Applications},
  editor =        {Girard, Jean-Yves},
  pages =         {129--146},
  publisher =     {Springer Berlin Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {A finite axiomatization of inductive-recursive
                   definitions},
  volume =        {1581},
  year =          {1999},
  abstract =      {Induction-recursion is a schema which formalizes the
                   principles for introducing new sets in Martin-L{\"o}f
                   's type theory. It states that we may inductively
                   define a set while simultaneously defining a function
                   from this set into an arbitrary type by structural
                   recursion. This extends the notion of an inductively
                   defined set substantially and allows us to introduce
                   universes and higher order universes (but not a Mahlo
                   universe). In this article we give a finite
                   axiomatization of inductive-recursive definitions. We
                   prove consistency by constructing a set-theoretic
                   model which makes use of one Mahlo cardinal.},
  doi =           {10.1007/3-540-48959-2_11},
  isbn =          {978-3-540-48959-7},
}

@article{Dybjer2003,
  author =        {Dybjer, Peter and Setzer, Anton},
  journal =       {Annals of Pure and Applied Logic},
  number =        {1},
  pages =         {1--47},
  title =         {Induction--recursion and initial algebras},
  volume =        {124},
  year =          {2003},
  abstract =      {Induction--recursion is a powerful definition method
                   in intuitionistic type theory. It extends
                   (generalized) inductive definitions and allows us to
                   define all standard sets of Martin-L{\"o}f type
                   theory as well as a large collection of commonly
                   occurring inductive data structures. It also includes
                   a variety of universes which are constructive
                   analogues of inaccessibles and other large cardinals
                   below the first Mahlo cardinal. In this article we
                   give a new compact formalization of
                   inductive--recursive definitions by modeling them as
                   initial algebras in slice categories. We give generic
                   formation, introduction, elimination, and equality
                   rules generalizing the usual rules of type theory.
                   Moreover, we prove that the elimination and equality
                   rules are equivalent to the principle of the
                   existence of initial algebras for certain
                   endofunctors. We also show the equivalence of the
                   current formulation with the formulation of
                   induction--recursion as a reflection principle given
                   in Dybjer and Setzer (Lecture Notes in Comput. Sci.
                   2183 (2001) 93). Finally, we discuss two
                   type-theoretic analogues of Mahlo cardinals in set
                   theory: an external Mahlo universe which is defined
                   by induction--recursion and captured by our
                   formalization, and an internal Mahlo universe, which
                   goes beyond induction--recursion. We show that the
                   external Mahlo universe, and therefore also the
                   theory of inductive--recursive definitions, have
                   proof-theoretical strength of at least Rathjen's
                   theory KPM.},
  doi =           {10.1016/S0168-0072(02)00096-9},
  issn =          {0168-0072},
}

@article{Lumsdaine2020,
  author =        {Lumsdaine, Peter LeFanu and Shulman, Michael},
  journal =       {Mathematical Proceedings of the Cambridge
                   Philosophical Society},
  number =        {1},
  pages =         {159--208},
  title =         {Semantics of higher inductive types},
  volume =        {169},
  year =          {2020},
  doi =           {10.1017/S030500411900015X},
}

@inproceedings{Kaposi2018,
  address =       {Dagstuhl, Germany},
  author =        {Kaposi, Ambrus and Kov{\'a}cs, Andr{\'a}s},
  booktitle =     {3rd International Conference on Formal Structures for
                   Computation and Deduction (FSCD)},
  editor =        {Kirchner, H\'{e}l\`{e}ne},
  pages =         {20:1--20:18},
  publisher =     {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r
                   Informatik},
  series =        {Leibniz International Proceedings in Informatics
                   (LIPIcs)},
  title =         {A syntax for higher inductive-inductive types},
  volume =        {108},
  year =          {2018},
  annote =        {Keywords: homotopy type theory, inductive-inductive
                   types, higher inductive types, quotient inductive
                   types, logical relations},
  doi =           {10.4230/LIPIcs.FSCD.2018.20},
  isbn =          {978-3-95977-077-4},
  issn =          {1868-8969},
  urn =           {urn:nbn:de:0030-drops-91906},
}

@article{Kovacs2020,
  address =       {New York, NY, USA},
  author =        {Kov{\'a}cs, Andr{\'a}s},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         {aug},
  number =        {ICFP},
  publisher =     {Association for Computing Machinery},
  title =         {Elaboration with first-class implicit function types},
  volume =        {4},
  year =          {2020},
  abstract =      {Implicit functions are dependently typed functions,
                   such that arguments are provided (by default) by
                   inference machinery instead of programmers of the
                   surface language. Implicit functions in Agda are an
                   archetypal example. In the Haskell language as
                   implemented by the Glasgow Haskell Compiler (GHC),
                   polymorphic types are another example. Implicit
                   function types are first-class if they are treated as
                   any other type in the surface language. This holds in
                   Agda and partially holds in GHC. Inference and
                   elaboration in the presence of first-class implicit
                   functions poses a challenge; in the context of
                   Haskell and ML-like languages, this has been dubbed
                   ``impredicative instantiation'' or ``impredicative
                   inference''. We propose a new solution for
                   elaborating first-class implicit functions, which is
                   applicable to full dependent type theories and
                   compares favorably to prior solutions in terms of
                   power, generality and simplicity. We build atop
                   Norell's bidirectional elaboration algorithm for
                   Agda, and we note that the key issue is incomplete
                   information about insertions of implicit abstractions
                   and applications. We make it possible to track and
                   refine information related to such insertions, by
                   adding a function type to a core Martin-L'of type
                   theory, which supports strict (definitional)
                   currying. This allows us to represent undetermined
                   domain arities of implicit function types, and we can
                   decide at any point during elaboration whether
                   implicit abstractions should be inserted.},
  doi =           {10.1145/3408983},
}

@article{Cockx2020a,
  author =        {Cockx, Jesper and Abel, Andreas},
  journal =       {Journal of Functional Programming},
  number =        {e2},
  title =         {Elaborating dependent (co)pattern matching: No
                   pattern left behind},
  volume =        {30},
  year =          {2020},
  doi =           {10.1017/S0956796819000182},
}

@inproceedings{Cockx2014,
  author =        {Cockx, Jesper and Piessens, Frank and
                   Devriese, Dominique},
  booktitle =     {Programming Languages and Systems (ESOP)},
  editor =        {Shao, Zhong},
  pages =         {87--106},
  publisher =     {Springer, Berlin, Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Overlapping and order-independent patterns},
  volume =        {8410},
  year =          {2014},
  doi =           {10.1007/978-3-642-54833-8_6},
}

@article{Newman1942,
  author =        {Newman, M. H. A.},
  journal =       {Annals of Mathematics},
  number =        {2},
  pages =         {223--243},
  title =         {On Theories with a Combinatorial Definition of
                   ``Equivalence''},
  volume =        {43},
  year =          {1942},
  doi =           {10.2307/1968867},
}

@inproceedings{Cockx2020,
  address =       {Dagstuhl, Germany},
  author =        {Cockx, Jesper},
  booktitle =     {25th International Conference on Types for Proofs and
                   Programs (TYPES 2019)},
  editor =        {Bezem, Marc and Mahboubi, Assia},
  pages =         {2:1--2:27},
  publisher =     {Schloss Dagstuhl--Leibniz-Zentrum f{\"u}r Informatik},
  series =        {Leibniz International Proceedings in Informatics
                   (LIPIcs)},
  title =         {Type theory unchained: Extending {Agda} with
                   user-defined rewrite rules},
  volume =        {175},
  year =          {2020},
  annote =        {Keywords: Dependent types, Proof assistants, Rewrite
                   rules, Higher-order rewriting, Agda},
  doi =           {10.4230/LIPIcs.TYPES.2019.2},
  isbn =          {978-3-95977-158-0},
  issn =          {1868-8969},
  urn =           {urn:nbn:de:0030-drops-130666},
}

@article{Cockx2021,
  address =       {New York, NY, USA},
  author =        {Cockx, Jesper and Tabareau, Nicolas and
                   Winterhalter, Th{\'e}o},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         jan,
  number =        {POPL},
  publisher =     {Association for Computing Machinery},
  title =         {The taming of the {Rew}: a type theory with
                   computational assumptions},
  volume =        {5},
  year =          {2021},
  abstract =      {Dependently typed programming languages and proof
                   assistants such as Agda and Coq rely on computation
                   to automatically simplify expressions during type
                   checking. To overcome the lack of certain programming
                   primitives or logical principles in those systems, it
                   is common to appeal to axioms to postulate their
                   existence. However, one can only postulate the bare
                   existence of an axiom, not its computational
                   behaviour. Instead, users are forced to postulate
                   equality proofs and appeal to them explicitly to
                   simplify expressions, making axioms dramatically more
                   complicated to work with than built-in primitives. On
                   the other hand, the equality reflection rule from
                   extensional type theory solves these problems by
                   collapsing computation and equality, at the cost of
                   having no practical type checking algorithm. This
                   paper introduces Rewriting Type Theory (RTT), a type
                   theory where it is possible to add computational
                   assumptions in the form of rewrite rules. Rewrite
                   rules go beyond the computational capabilities of
                   intensional type theory, but in contrast to
                   extensional type theory, they are applied
                   automatically so type checking does not require input
                   from the user. To ensure type soundness of RTT---as
                   well as effective type checking---we provide a
                   framework where confluence of user-defined rewrite
                   rules can be checked modularly and automatically, and
                   where adding new rewrite rules is guaranteed to
                   preserve subject reduction. The properties of RTT
                   have been formally verified using the MetaCoq
                   framework and an implementation of rewrite rules is
                   already available in the Agda proof assistant.},
  doi =           {10.1145/3434341},
}

@unpublished{Martin-Lof1992,
  author =        {Martin-L{\"o}f, Per},
  month =         {November},
  note =          {Notes from a lecture given in G{\"{o}}teborg},
  title =         {Substitution calculus},
  year =          {1992},
}

@article{Abel2002,
  author =        {Abel, Andreas and Altenkirch, Thorsten},
  journal =       {Journal of Functional Programming},
  number =        {1},
  pages =         {1--41},
  title =         {A predicative analysis of structural recursion},
  volume =        {12},
  year =          {2002},
  doi =           {10.1017/S0956796801004191},
}

@article{Altenkirch2017,
  author =        {Altenkirch, Thorsten and Kaposi, Ambrus},
  journal =       {Logical Methods in Computer Science},
  month =         oct,
  number =        {4},
  title =         {Normalisation by evaluation for type theory, in type
                   theory},
  volume =        {13},
  year =          {2017},
  doi =           {10.23638/LMCS-13(4:1)2017},
}

@inproceedings{Munoz1998,
  author =        {Mu{\~n}oz, C{\'e}sar},
  booktitle =     {Types for Proofs and Programs (TYPES 1996)},
  editor =        {Gim{\'e}nez, Eduardo and Paulin-Mohring, Christine},
  pages =         {294--316},
  publisher =     {Springer, Berlin, Heidelberg},
  series =        {Lecture Notes in Computer Science},
  title =         {Dependent types with explicit substitutions: A
                   meta-theoretical development},
  volume =        {1512},
  year =          {1998},
  doi =           {10.1007/BFb0097798},
}

@incollection{Castellan2021,
  author =        {Castellan, Simon and Clairambault, Pierre and
                   Dybjer, Peter},
  booktitle =     {Joachim Lambek: The Interplay of Mathematics, Logic,
                   and Linguistics},
  editor =        {Casadio, Claudia and Scott, Philip J.},
  publisher =     {Springer, Cham},
  series =        {Outstanding Contributions to Logic},
  title =         {Categories with families: Unityped, simply typed, and
                   dependently typed},
  volume =        {20},
  year =          {2021},
  doi =           {10.1007/978-3-030-66545-6_5},
}

@unpublished{Kaposi2024a,
  author =        {Kaposi, Ambrus and Xie, Szumi},
  title =         {Type theory in type theory with single substitutions},
  year =          {2024},
}

@article{Pujet2022,
  address =       {New York, NY, USA},
  author =        {Pujet, Lo{\"{\i}c} and Tabareau, Nicolas},
  journal =       {Proceedings of the ACM on Programming Languages},
  month =         jan,
  number =        {POPL},
  publisher =     {Association for Computing Machinery},
  title =         {Observational equality: now for good},
  volume =        {6},
  year =          {2022},
  abstract =      {Building on the recent extension of dependent type
                   theory with a universe of definitionally
                   proof-irrelevant types, we introduce TTobs, a new
                   type theory based on the setoidal interpretation of
                   dependent type theory. TTobs equips every type with
                   an identity relation that satisfies function
                   extensionality, propositional extensionality, and
                   definitional uniqueness of identity proofs (UIP).
                   Compared to other existing proposals to enrich
                   dependent type theory with these principles, our
                   theory features a notion of reduction that is
                   normalizing and provides an algorithmic canonicity
                   result, which we formally prove in Agda using the
                   logical relation framework of Abel et al. Our paper
                   thoroughly develops the meta-theoretical properties
                   of TTobs, such as the decidability of the conversion
                   and of the type checking, as well as consistency. We
                   also explain how to extend our theory with quotient
                   types, and we introduce a setoidal version of Swan's
                   Id types that turn it into a proper extension of MLTT
                   with inductive equality.},
  doi =           {10.1145/3498693},
}

@inproceedings{Pujet2024,
  author =        {Pujet, Lo{\"\i}c and Tabareau, Nicolas},
  booktitle =     {Programming Languages and Systems (ESOP)},
  editor =        {Weirich, Stephanie},
  pages =         {275--301},
  publisher =     {Springer, Cham},
  series =        {Lecture Notes in Computer Science},
  title =         {Observational equality meets {CIC}},
  volume =        {14576},
  year =          {2024},
  doi =           {10.1007/978-3-031-57262-3_12},
}

@phdthesis{Pujet2022a,
  author =        {Pujet, Lo{\"{\i}c}},
  school =        {Nantes University},
  title =         {Computing with Extensionality Principles in Type
                   Theory},
  year =          {2022},
  url =           {https://inria.hal.science/tel-03923041/},
}

@misc{Eremondi2025,
  author =        {Eremondi, Joseph and Kammar, Ohad},
  note =          {To appear at ESOP'25},
  title =         {Coverage semantics for dependent pattern matching},
  year =          {2025},
  doi =           {10.48550/arXiv.2501.18087},
}

